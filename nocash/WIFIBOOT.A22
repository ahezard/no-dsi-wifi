        experimental_disable_ap123 equ 0;1     ;XXX for testing only
        insist_on_selected_cipher       equ 0   ;0=allow any (in-)security, 1=accept selected (in-)security only
        ;XXX insist_on_minimum_cipher  ;<-- should also implement this (for selecting MINIMUM security)
        with_crypto_selftest    equ 0
        try_sdio_ndma   equ 1
        try_fast_buffer equ 1
        use_dsi_bios    equ 0

;:----------------- nocash wifiboot (a dslink clone)
;------------------
;wifiboot based on dslink (2009-2015 from Dave Murphy aka WinterMute)
;wificore based on dswifi (2005-2006 from Stephen Stair)
;------------------
;  xxx should support "zerofill_unused_mainram_areas" here, too (via STMIA for NDS, and via NDMA for DSi)
;  xxx ead: now throws DISCONNECT every once and then?
;  xxx nds-wifi: determine enabled channels from Wifi-FLASH (or better IGNORE that)
;  xxxx error msg: DISCONNECT event (1003h), usually that means wrong password or too weak signal strength or some timeout --> (mark password=good upon Open, or WEP+connected, or WPA/WPA2+MIC=good)
;  xxx NDS: support DS download play (single gamepak multiboot)
;  xxx NDS: support WPA encryption (need wifi-flash settings though)
;   dlink: keiner
;   dlink: wep
;   dlink: 802.1x
;   dlink: wpa-psk
;   dlink: wpa
;   dlink: wpa2-personal(aes)
;   dlink: wpa2-enterprise(aes)
;   dlink: wpa-personal/wpa2-personal
;  xxxx with_warmboot_info: memorize ssid/channel and dhcp settings
;  xxxx cosmetic: rename interface HEX number to AR6002/AR6013 (when known)
;  xxxx cosmetic: rename regdomain HEX number to JAPAN/USA (when known)
;  xxxx cosmetic: freshen_rssi_display LESS often & merge recent "past" values
;     xxxx release (XXX remove experimental_disable_ap123 before release)
;------------------
;wifiboot v2.5 - 26 Jan 2019
; - dsi-wifi: detects supported cipher/combinations (from AP beacons)
; - dsi-wifi: determines best-matching-cipher (AP beacons versus FLASH settings)
; - dsi-wifi: supports wifi-flash entries with WPS-flag (ie. ignores that flag)
; - dsi-wifi: relocated all code to vram (slightly faster than slow main ram)
; - dsi-wifi: displays life-updates for current signal strength
; - dsi-wifi: source code: REG_SDIO_xxx symbols instead of numeric I/O addresses
; - dsi-wifi: uses WMI_GET_CHANNEL_LIST to determine enabled channels/domain
; - dsi-wifi: shows REG_DOMAIN country code (eg. 0188=JP, 0348=US)
;------------------
;wifiboot v2.4 - 07 Jan 2019
; - dsi-wifi: reverse-engineered dsi-wifi sdio mbox transfer protocol
; - dsi-wifi: supports WPA and WPA2 (additionally to WEP and open networks)
; - dsi-wifi: theoretically supports 54Mbit/s (but reaches only 500Kbyte/s yet)
; - dsi-wifi: crypto MD5, SHA1, HMAC, AES-Key-Wrap, RC4 software implementations
; - dsi-wifi: supports EAPOL 4-way handshake and WPA/WPA2 groupkey handshake
; - dsi-wifi: optional selftest for generating WPA/WPA2 keys and crypto stuff
; - dhcp: fixed seconds-byte-order (big-endian) and milliseconds/1000 division
;------------------
;wifiboot v2.3 - 30 Sep 2018
; - added carthdr[B0h]="DoNotZeroFillMem" for unlaunch/fastboot without zerofill
; - forces disabled cache to be MADE EMPTY before starting loaded title
; - zerofills vram/oam/palette before starting other titles (takes about 6ms)
;------------------
;wifiboot v2.2 - 24 Jul 2018
; - renamed asm source/binaries from dslink+dswifi to wifiboot+wificore
; - rearranged EXMEMCNT init, ensures ARM9 IPC IRQ enabled before waiting for it
; - adjusts BPTWL powerbutton mode for wifiboot itself and booted nds/dsi titles
; - enter_nds_mode: reloc 2FFFxxxh to 23FFxxxh, set 4MB-RAM, NDS-ROM, ARM9 67MHz
; - enter_nds_mode: set NDS-TSC-touchscr mode, NDS-SNDEXCNT
;------------------
;wifiboot v2.1 - 14 Jun 2018
; - added valid DSi cart header (needed to be sure to stay in DSi mode)
; - supports blowfish/secure_area (requires rom/itcm) and modcrypted dsi areas
; - supports SCFG, MBK's, WRAMBANK settings from dsi cart header
; - supports "cleaning" dirty cache lines (for PU cache write-bufferability)
;------------------
;wifiboot v2.0 - 2018
; - support for DWM-W024 boards and dsi carts with ARM9i/ARM7i areas
;------------------
.arm      ;use 32bit arm code
.nocash   ;assemble with a22i assembler (in no$gba utility menu)
.strict
;------------------
with_rom_cart   equ 0  ;always 0 for dslink
            wifi_with_dsi_irq equ 1
;------------------
.arm            ;select 32bit ARM instruction set
.nds            ;indicate that it's a nintendo ds program
.fix            ;automatically fix the cartridge header checksum(s)
.strict         ;insist on colons in label definitions (label:)
.nocash         ;indicate using nocash syntax instead native ARM syntax
.data?                  ;-switch to uninitialized data area
org 23cc000h  +2000h    ;-set the origin for the data field
vardata_start:
.code                   ;-switch back to cartridge memory (restores old origin)
org 0           ;origin in RAM for multiboot-cable/no$gba-cutdown compatibility
  vram_code equ 01
  mod_dma   equ 0
  aes_dma   equ 0
;------------------
;:----------------- Cartridge Header
;------------------
 db 'WIFI BOOT',0,0,0;000h    12    Game Title  (Uppercase ASCII, padded with 00h)
 db 0,0,0,0          ;00Ch    4     Gamecode    (Uppercase ASCII, NTR-<code>)
 db 0,0              ;010h    2     Makercode   (Uppercase ASCII, eg. "01"=Nintendo)
 db 02h  ;nds+dsi    ;012h    1     Unitcode    (00h=NDS, 02h=NDS+DSi, 03h=DSi)
 db 0                ;013h    1     Devicetype  (00h=Normal Cartridge)
 db 0                ;014h    1     Devicecapacity (Chipsize = 128KB SHL nn) (eg. 7 = 16MB)
 defs 7              ;015h    7     Reserved    (00h)
 db 03h              ;01Ch    1        <-- DSi requires 03h or 01h (or similar) else starting carts fails before even checking header RSA
 defs 1              ;01Dh    1     Reserved    (00h)
 db 0                ;01Eh    1     ROM Version (usually 00h)
 db 0                ;01Fh    1     Reserved    (00h)
 dd nds9_offset      ;020h    4     ARM9 rom_offset (bottom may/must? reach into secure area)
 dd nds9_entry       ;024h    4     ARM9 entry_address
 dd nds9_dest        ;028h    4     ARM9 ram_address (must be in Main RAM at 2000000h..23BFE00h)
 dd nds9_size        ;02Ch    4     ARM9 size
 dd nds7_offset      ;030h    4     ARM7 rom_offset
 dd nds7_entry       ;034h    4     ARM7 entry_address
 dd nds7_dest        ;038h    4     ARM7 ram_address
 dd nds7_size        ;03Ch    4     ARM7 size
 dd 0,0,0,0          ;040h    filesystem (none)
 dd 0,0,0,0          ;050h    overlays   (none)
 dd 00586000h,001808f8h ;060h romctrl    (default settings)
 dd icon_offset      ;068h icon/title (0=none)
 dw 0 ;(see .fix)    ;06Ch Secure Area Checksum, CRC-16 of [4000h-7FFFh]
 dw 051eh            ;06Eh rom_control_info3 (051Eh)       (purpose unknown)
 dd 0,0              ;070h autoload   (none)
 dd 0,0              ;078h rominfo    (not set)
 dd total_used_size  ;080h Total Used ROM size (remaining/unused bytes usually FFh-padded)
 dd 4000h            ;084h ROM Header Size (4000h)
 dd 0004d0b8h        ;088h DSi?
 dd 00000544h        ;08Ch DSi?
 dd 00160016h        ;090h DSi?
 defs 1Ch              ;094h Reserved (zero filled)
 db 'DoNotZeroFillMem' ;0B0h Reserved (zero filled) / or unlaunch fastboot ID
 dd   051AEFF24h,021A29A69h,00A82843Dh,0AD09E484h,0988B2411h   ;\
 dd   0217F81C0h,019BE52A3h,020CE0993h,04A4A4610h,0EC3127F8h   ;
 dd   033E8C758h,0BFCEE382h,094DFF485h,0C1094BCEh,0C08A5694h   ;
 dd   0FCA77213h,0734D849Fh,0619ACAA3h,027A39758h,0769803FCh   ; nintendo
 dd   061C71D23h,056AE0403h,0008438BFh,0FD0EA740h,003FE52FFh   ; logo
 dd   0F130956Fh,085C0FB97h,02580D660h,003BE63A9h,0E2384E01h   ;
 dd   0FF34A2F9h,044033EBBh,0CB900078h,0943A1188h,0637CC065h   ;
 dd   0AF3CF087h,08BE425D6h,072AC0A38h,007F8D421h              ;/
 dw 0cf56h  ;Nintendo Logo Checksum, CRC-16 of [0C0h-15Bh], fixed CF56h
 dw 0 ;(see .fix)      ;Header Checksum, CRC-16 of [000h-15Dh]
 dd 0,0,0         ;160h Reserved (zero filled) (except for NDS debug version)
 dd 0             ;16Ch Reserved (zero filled) (transferred, and stored, but not used)
 defs 10h         ;170h Reserved (zero filled) (transferred, but not stored in RAM)
;- - - DSi extra stuff...
 dd 0,0,0,0,0     ;180h Global MBK1..5
 dd 0,0,0         ;194h Local MBK6..8 for ARM9
 dd 0,0,0         ;1A0h Local MBK6..8 for ARM7
 dd 03000000h     ;1ACh Global MBK9 and WRAMCNT
 dd 0ffffffffh    ;1B0h Region Flags (FFFFFFFFh=Region Free)
 dd 1fh           ;1B4h Access Control (want AES keys, especially bit4=eMMC)
 dd 80040407h     ;1B8h ARM7 SCFG_EXT setting (bit0,1,2,10,18,31)
 dd   11000000h   ;1BCh Flags (stay in DSi-TSC mode, show wifi-icon)
 dd 0 ;dsi9_src   ;1C0h ARM9i src                                ;CAN BE 0?
 dd 0             ;1C4h Reserved (zero)                          ;CAN BE 0
 dd dsi9_dest     ;1C8h ARM9i  ;;dsi9_dest                       ;NEEDED!!!
 dd 0 ;dsi9_size  ;1CCh ARM9i                                    ;CAN BE 0
 dd 0 ;dsi7_src   ;1D0h ARM7i src                                ;CAN BE 0?
 dd 0             ;1D4h    SD/MMC Device List ARM7 RAM Addr; 400h-byte initialized by firmware
 dd dsi7_dest     ;1D8h ARM7i                                    ;NEEDED!!!
 dd 0 ;dsi7_size  ;1DCh ARM7i                                    ;CAN BE 0
 dd 0    ;;;ntr_mem_bot              ;1E0h Digest               ;\
 dd 0    ;;;ntr_mem_siz              ;1E4h Digest               ;
 dd 0    ;;;twl_mem_bot              ;1E8h Digest               ;
 dd 0    ;;;twl_mem_siz              ;1ECh Digest               ; CAN BE 0
 dd 0    ;;;digest_sector_table_base ;1F0h                      ;
 dd 0    ;;;digest_sector_table_size ;1F4h                      ;
 dd 0    ;;;digest_block_table_base  ;1F8h                      ;
 dd 0    ;;;digest_block_table_size  ;1FCh                      ;
 dd 0,0  ;;;400h,20h                 ;200h Digest sector/block  ;/
 dd icon_size     ;208h Icon/Title size
 dd 0             ;20Ch
 dd 0 ;twl_total  ;210h Total used ROM size (including DSi areas)  ;CAN BE 0
 dd 0             ;214h
 dd 4d084h        ;218h
 dd 52ch          ;21Ch
 dd 0,0  ;;;dsi9_src,dsi9_size  ;220h Modcrypt areas 1 (dsi9 area) ;CAN BE 0
 dd 0,0                 ;228h Modcrypt areas 2 (none)              ;CAN BE 0
 db 0,0,0,0       ;230h Title ID lsw
 db 0,0,3,0       ;234h Title ID msw
 dd 0             ;238h public.sav filesize
 dd 0             ;23Ch private.sav filesize
 defs 176         ;240h zerofilled
 .rept 10h
  db 80h          ;2F0h Parental Control ratings
 .endm
 defs 14h         ;300h sha1
 defs 14h         ;314h sha1
 defs 14h         ;328h sha1
 defs 14h         ;33Ch sha1
 defs 14h         ;350h sha1
 defs 14h         ;364h sha1
 defs 14h         ;378h zerofilled
 defs 14h         ;38Ch zerofilled
 defs 14h         ;3A0h sha1
 defs 0F80h-3B4h  ;3B4h remaining header area
 defs 80h         ;F80h rsa sha1
 defs 3000h       ;1000h remaining header area (up to secure area)
 .errif $<>4000h  ;4000h end of header area
;------------------
dsi9_dest equ 2400000h   ;reloc dest in RAM   ;<-- works on DSi
dsi7_dest equ 2E80000h   ;reloc dest in RAM   ;<-- works on DSi
;------------------
;:----------------- ARM9 Start
;------------------
.align 200h
nds9_offset:
org 2200000h
nds9_dest:
;------------------
 .if 0
  db   'encryObj'  ;secure area ID (8 bytes)
 .else
  defs 800h
 .endif
;------------------
nds9_entry:
   mov  p15,0,c7,c10,4,r0 ;=000000000h ;Drain Write Buffer
   mov  p15,0,c7,c5,0,r0  ;=000000000h ;Invalidate Entire Instruction Cache
   mov  p15,0,c7,c6,0,r0  ;=000000000h ;Invalidate Entire Data Cache

.if vram_code
 mov  r1,4000000h
 mov  r0,81h       ;vram A, mst=1, ofs=0, enable, BG at 6000000h (for Engine A)
 add  r0,8900h     ;vram B, mst=1, ofs=1, enable, BG at 6020000h (for ARM9 code/data)
 add  r0,840000h   ;vram C, mst=4, ofs=0, enable, BG at 6200000h (for Engine B)
 add  r0,80000000h ;vram D, mst=0, ofs=0, enable, ARM9 at 6860000h (for ARM7 code/data)
 str  r0,[r1,240h] ;;vramcnt_abcd
 mov  r0,03000000h
 str  r0,[r1,244h] ;vramcnt/wramcnt
 mov  r0,0
 str  r0,[r1,248h] ;vramcnt
.endif

 ldr  r0,=arm9_reloc_src
 ldr  r1,=arm9_reloc_dst
 ldr  r2,=arm9_reloc_size
@@lop:
 ldr  r3,[r0],4
 str  r3,[r1],4
 subs r2,4
 bne  @@lop
 .if vram_code
   ldr  pc,=arm9_main
 .else
   b    arm9_main
 .endif
;---
.pool
;---
 .if vram_code
   wanted_nds9_reloc_dest equ 6020000h
 .else
   wanted_nds9_reloc_dest equ 23bfe00h
 .endif
;---
arm9_reloc_src:
org wanted_nds9_reloc_dest
arm9_reloc_dst:
;;;.pack_org $
;------------------
;:----------------- Wifi
;------------------
.include wificore.a22   ;aka dswifi clone (aka dswifi ported to asm)
;------------------
;form libnds "include/nds/system.h"...
;---
ARGV_MAGIC      equ 5f617267h  ;argv struct magic number ("_arg")
__system_argv   equ 02FFFE70h  ;uh, weird, overlaps carthdr[070h..08Bh] (maybe actually intended to have used hdr[170h..18Bh]?)
__NDSHeader     equ 02FFFE00h
__DSiHeader     equ 02FFE000h
;---
;struct __argv:   ;structure used to set up argc/argv on the DS
;(nds header)     equ 000h ;070h
 Argv_argvMagic   equ 070h ;4   ;int  argvMagic    ;argv magic number, set to 0x5f617267 ('_arg') if valid
 Argv_commandLine equ 074h ;4   ;char *commandLine ;base address of command line, set of null terminated strings
 Argv_length      equ 078h ;4   ;int  length       ;total length of command line
 Argv_argc        equ 07Ch ;4   ;int  argc         ;internal use, number of arguments
 Argv_argv        equ 080h ;4   ;char **argv       ;internal use, argv pointer
 Argv_dummy       equ 084h ;4   ;int  dummy        ;internal use
 Argv_host        equ 088h ;4   ;u32  host         ;internal use, host ip for dslink
 Argv_size        equ 1Ch  ;total
;------------------
REG_DISPSTAT    equ 004h
REG_IPC_SYNC    equ 180h
PROTECT_ENABLE  equ 00000001h
;------------------
;:----------------- dslink arm7-main.c
;------------------
arm7_main:
;bl   readUserSettings        ;read User Settings from firmware
 ldr   r1,=dsi_flag                             ;\
 ldr   r0,[r1]                                  ;
 cmp   r0,0                                     ; if DSi console,
 movne r1,012h ;idx=powerbutton ;\pwrbutt:      ; init BPTWL powerbutt mode
 movne r0,000h ;dta=auto-reset  ; auto-res      ;   do BEFORE IRQ init (which may also mess with bptwl)
 blne  set_bptwl_reg_r1_to_r0   ;/              ;/
 bl   arm7_irqInit
 bl   arm7_fifoInit
;bl   initClockIRQ            ;Start the RTC tracking IRQ aka "IRQ_NETWORK" (sic.)
;bl   SetYtrigger(80)
 bl   arm7_installWifiFIFO
;bl   arm7_installSystemFIFO
;bl   arm7_irqSet(IRQ_VCOUNT, arm7_VcountHandler)
;bl   arm7_irqSet(IRQ_VBLANK, arm7_VblankHandler)
 ldr   r1,=dsi_flag                             ;\
 ldr   r0,[r1]                                  ;
 cmp   r0,0                                     ; if NDS console,
 mov   r0,30h      ;src                         ;
 ldr   r1,=nds_blowfish_key  ;dst               ; load original BIOS key seed
 ldr   r2,=1048h   ;len                         ; directly from protected BIOS
 bleq  nds7_dump_bios                           ;/

 mov  r0,IRQ_IPC_SYNC                           ;\
 bl   arm7_irqEnable                            ;/

mov r1,4000000h                         ;\
mov r0,08h   ;vblank irq enable         ;
str r0,[r1,REG_DISPSTAT]                ;/

 mov  r0,IRQ_VBLANK                             ;\
 bl   arm7_irqEnable                            ;/
;bl   irqSetAUX(IRQ_I2C, powerButtonHandler)
;bl   irqEnableAUX(IRQ_I2C)

 mov  r0,01h                                    ;\sync(1) wait for memcopy
 bl   arm7_ipc_sync                             ;/
 bl   arm7_map_mbk_from_arm7                    ;-map ARM7 wram
 ldr  r12,=__NDSHeader                          ;\
 mov  r0,2000000h + 0c00000h                    ;
 ldr  r1,[r12,38h] ;arm7dst                     ; copy ARM7 binary
 ldr  r2,[r12,3ch] ;arm7siz                     ;     XXXX BUGGED: won't work when src overlaps dest
 bl   memcopy_bytewise                          ;/
 mov  r0,02h                                    ;\sync(2) confirm memcopy
 bl   arm7_ipc_sync                             ;/
 mov  r0,03h                                    ;\sync(3) wait for boot
 bl   arm7_ipc_sync                             ;/
;- - - - ----------
 bl   arm7_Wifi_Deinit          ;-
 bl   do_modcrypt               ;-
 bl   arm7_map_mbk_from_arm7    ;-


.if 0
 ldr  r0,=1FE00h           ;src ;\       XXX or other addr
 ldr  r1,=2FFFC80h         ;dst ; load wifi flash User Settings
 mov  r2,70h               ;len ;
 bl   arm7_readFirmware         ;/
 mov  r0,36h               ;src ;\
 ldr  r1,=2FFFCF4h         ;dst ; load wifi flash MAC addr
 mov  r2,6                 ;len ;
 bl   arm7_readFirmware         ;/
.endif

;- - - - ----------
 mov  r0,04h                                    ;\sync(4) wait for reboot
 bl   arm7_ipc_sync                             ;/
;arm7_reboot...
 mov  r0,IRQ_ALL                ;\IE
 bl   arm7_irqDisable           ;/
 .if with_dsi_wifi
   mov  r0,IRQ2_ALL             ;\IE2
   bl   arm7_irqDisable2        ;/
 .endif
;- - -
   mov  r0,cpsr                   ;\cpu interrupt disable (set i flag)
   orr  r0,r0,80h                 ; done BEFORE "enter_nds_mode" (so ARM7 can
   mov  cpsr,r0                   ;/switch to NDS ROM without SWI/IRQ issues)
 mov  r0,07h                    ;\sync(7)
 bl   arm7_ipc_sync             ;/
 ldr  r1,=dsi_flag                      ;\
 ldr  r0,[r1]                           ;
 cmp  r0,0                              ;
 beq  @@skip_dsi_stuff                  ;/
 verbose_tsc_init equ 0                 ;\
 ldr  r1,=__DSiHeader                   ;
 ldr  r0,[r1,1bch] ;hdr[1BCh]           ; switch to NDS TSC mode
 tst  r0,1000000h ;bit24=tsc mode       ; (if requested in cart header)
 ldr  r1,=nds_mode_tsc_init_list        ;
 bleq send_tsc_list_r1                  ;/
 bl   arm7_enter_nds_mode               ;-switch to NDS mode if needed
 ldr  r1,=__DSiHeader                   ;\
 ldr  r0,[r1,1b8h] ;hdr[1B8h]           ;
 ldr  r1,=80040407h ;bit0,1,2,10,18,31  ;
 and  r0,r1                             ; scfg_ext7
 ldr  r1,=13FBFB00h                     ;
 orr  r0,r1                             ;
 ldr  r3,=REGBASE_SCFG                  ;
 tst  r0,40000h     ;bit18              ; ;\
 ldrh r2,[r3,REG_SCFG_CLK7]             ; ; sdmmc clk
 orrne r2,1                             ; ;
 biceq r2,1                             ; ;
 strh r2,[r3,REG_SCFG_CLK7]             ; ;/
 str  r0,[r3,REG_SCFG_EXT7]             ;/
@@skip_dsi_stuff:
;;; mov  r0,00h                    ;\sync(0)
;;; bl   arm7_ipc_sync             ;/
 mov  r4,4000000h
 mov  r0,0                      ;\
 str  r0,[r4,REG_IME]           ;
;;; str  r0,[r4,REG_IPC_SYNC]      ;
 str  r0,[r4,REG_SPI_CNT_DATA]  ;
 str  r0,[r4,REG_DISPSTAT]      ;/
 mov  r0,-1                     ;\
 str  r0,[r4,REG_IF]            ;/
 mov  r0,cpsr                   ;\
 orr  r0,80h                    ; cpu interrupt disable (set i flag)
 mov  cpsr,r0                   ;/
 mov  r0,0                      ;\
 strh r0,[r4,0bah] ;DMA0CNT     ;
 strh r0,[r4,0c6h] ;DMA1CNT     ; stop DMA
 strh r0,[r4,0d2h] ;DMA2CNT     ;
 strh r0,[r4,0deh] ;DMA3CNT     ;/
 add  r0,r4,0b0h                ;\
 mov  r1,30h                    ; clear DMA
 bl   zerofill_bytewise         ;/
 add  r0,r4,100h                ;\
 mov  r1,10h                    ; clear timers
 bl   zerofill_bytewise         ;/
 ldr  r0,=0101h                 ;\
 str  r0,[r4,REG_IPC_FIFO_CNT]  ;/
;ldr  r0,=0f0bh                 ;\
;str  r0,[r4,REG_RTC_CNT]       ;/

.comment
 ldr  r0, =0x380FFFC         @ irq vector
 mov  r1, #0
 str  r1, [r0]
 sub  r0, r0, #4             @ IRQ1 Check Bits
 str  r1, [r0]
 sub  r0, r0, #4             @ IRQ2 Check Bits  <--- BUGGED
 str  r1, [r0]
.comment

 ldr  r0,=3810000h
 mov  r1,0

 str  r1,[r0,-4h]      ;[380FFFCh] IRQ Vector
 str  r1,[r0,-8h]      ;[380FFF8h] IRQ Check Bits 1
 str  r1,[r0,-40h]     ;[380FFC0h] IRQ Check Bits 2
 mov  cpsr_c,0d3h               ;\
 add  sp,r0,0ffc0h-10000h       ; sp_svc = 380FFC0h, lr_svc=0
 mov  lr,0                      ;
 mov  spsr,10h                  ;/
 mov  cpsr_c,0d2h               ;\
 add  sp,r0,0ff80h-10000h       ; sp_irq = 380FF80h, lr_irq=0
 mov  lr,0                      ;
 mov  spsr,10h                  ;/
 mov  cpsr_c,0dfh               ;\sp_sys = 380FD80h
 add  sp,r0,0fd80h-10000h       ;/
;- - - -
.if 1
   @@reloc_dst equ 380F700h   ;or DSi:380F600h
    ldr  r0,=@@reloc_src
    ldr  r1,=@@reloc_dst
    ldr  r2,=@@reloc_len
    bl   memcopy_bytewise
    ldr  r1,=@@reloc_dst
    bx   r1
   .pool

   @@reloc_src:
   org @@reloc_dst
   .if vram_code OR 1
    mov  r0,0fh                 ;\sync(F) wait till vram_code is no longer used
    bl   @@sync_r0              ;/
   .endif
    mov  r0,0                   ;\sync(0)
    bl   @@sync_r0              ;/
   ;; mov  r1,4000000h               ;\
   ;; mov  r0,(0 shl 8)              ;
   ;; str  r0,[r1,REG_IPC_SYNC]      ;
   ;;@@sync_lop:                     ; sync(0)
   ;; ldr  r0,[r1,REG_IPC_SYNC]      ;
   ;; tst  r0,0fh                    ;
   ;; bne  @@sync_lop                ;/
.else
 mov  r0,00h                    ;\sync(0)
 bl   arm7_ipc_sync             ;/
.endif
;- - -
         ;ldmia [sp],r0-r11
 mov  cpsr_f,80000000h          ;-cpsr_sys flags
 ldr  r12,=2FFFE34h             ;\ __NDSHeader
 ldr  r12,[r12]                 ; ARM7 entrypoint
 mov  r14,r12                   ;
 bx   r12                       ;/
;---
.if 1
   @@sync_r0:
    mov  r1,4000000h               ;\
    mov  r2,r0,lsl 8               ;
    str  r2,[r1,REG_IPC_SYNC]      ;
   @@sync_lop:                     ; sync(n)
    ldr  r2,[r1,REG_IPC_SYNC]      ;
    and  r2,0fh                    ;
    cmp  r2,r0                     ;
    bne  @@sync_lop                ;/
    bx   lr
   .pool
   @@reloc_len equ $-@@reloc_dst
   org @@reloc_src+@@reloc_len
.endif
;------------------
arm7_ipc_sync:
 mov  r1,4000000h
 mov  r2,r0,lsl 8               ;\
 orr  r2,6000h                  ; output
 str  r2,[r1,REG_IPC_SYNC]      ;/

 b    @@wait_inj
@@wait_lop:

.if 01
 mov  r2,cpsr                   ;\
 tst  r2,80h                    ;
 bne  @@skip_halt               ;/
 ldr  r2,[r1,REG_IME]           ;\
 tst  r2,1                      ;
 beq  @@skip_halt               ;/
 push r0-r1,lr
 swi  06h shl 16        ;halt
 pop r0-r1,lr
@@skip_halt:
.endif
@@wait_inj:


 ldr  r2,[r1,REG_IPC_SYNC]      ;\
 and  r2,0fh                    ; wait  ;XXXX could Halt here
 cmp  r2,r0                     ;
 bne  @@wait_lop                ;/
 bx   lr
;------------------
arm7_VblankHandler:
        ;;;push lr // bl wrdot // pop lr
 ldr  r1,=vblank_count          ;\
 ldr  r0,[r1]                   ;
 add  r0,1                      ;
 str  r0,[r1]                   ;/
 mov  r1,4000000h               ;\
 mov  r0,IRQ_VBLANK             ;
 str  r0,[r1,REG_IF]            ;/
 b    arm7_Wifi_Update          ;-
;------------------
.pool
;------------------
;:----------------- DSi SDIO
;------------------
.if with_dsi_wifi
;------------------
verbose_wifi_firmware       equ 0
try_sdio_data32_mode        equ 0  ;not working?
with_rtc_init               equ 0  ;already done by launcher/unlaunch
with_wifi_firmware_loading  equ 0  ;already done by launcher/unlaunch
with_manual_wifi_decompress equ 0
sdio_dma                equ 0;1  ;XXX requires DMA channel to be free/unused
                                 ;XXX above DMA doesn't work yet with TX multiblock (len>80h)
;---
swi_wait_by_loop      equ 03h
swi_crc16             equ 0eh
;---
.data?
.align 40h      ;XXX cache?
 sdio_old_local_scratch0    dd 0
 sdio_old_wlan_system_sleep dd 0
 sdio_eeprom_addr           dd 0
 sdio_rom_version           dd 0
 sdio_firmware_part_base    dd 0
 sdio_database_addr         dd 0
;;firmbuf: defs 200h
;;sdio_firmware_buf:        defs xxx     ;-for sdio wifi firmware
;;sdio_lz_buf:              defs xxx     ;-for lz decompressor
.if try_fast_buffer=0
    sdio_xfer_buf_minus_16:    defs 2      ;\for sdio mbox etc.
    sdio_xfer_buf_minus_14:    defs 14     ; (minus_14 part is for larger NDS-style
    sdio_xfer_buf:             defs 0a00h  ;/headers)
.else
    sdio_xfer_buf_minus_16      equ 3808000h  ;\
    sdio_xfer_buf_minus_14      equ 3808002h  ; XXX works, but speed drops from 150 to 99 ?
    sdio_xfer_buf               equ 3808010h  ;/  (unless.. two NOPs in DATA16 do help!)
.endif
.align 40h      ;XXX cache?
 twlcfg_etc_buf:        defs 214h  ;copy of 2000400h..2000613h
.align 40h      ;XXX cache?
.code
;---
.include wifisdio.a22
;------------------
;disable/remove all ARM7 code, and also all W_xxx I/O address constants,
;even with all that removed, assembling wifiboot throws only a handful errors:
;  arm7_installWifiFIFO
;  arm7_wifiValue32Handler   ;this includes Init (from ARM9 via FIFO)
;  arm7_Wifi_Update
;  arm7_Wifi_Deinit
;  arm7_Wifi_Interrupt
;  IRQ_WIFI (add IRQ2_DSI_WIFI, and don't forget adding IRQ2_ALL)
;that functions need to be redirected to new "dsi7" functions, once when
;everything is working one can resurrect the old "arm7" functions (and
;make the redirection conditional) (but it's best to test "dsi7" with the
;old "arm7" stuff completely removed/disabled, to make sure that the new
;code doesn't unintentionally execute any on old NDS-wifi code).
;------------------
dsi7_wifiValue32Handler:  ;in: r0=value, r1=data/optional, out: none  ;"static"
 cmp   r0,WIFI_SYNC                     ;\WIFI_SYNC    --> sync Wifi
 beq   dsi7_Wifi_Update                 ;/
 cmp   r0,WIFI_DISABLE                  ;\
 moveq r0,IRQ2_DSI_WIFI                 ; WIFI_DISABLE --> disable Wifi IRQ
 beq   arm7_irqDisable2                 ;/
 cmp   r0,WIFI_ENABLE                   ;\
 moveq r0,IRQ2_DSI_WIFI                 ; WIFI_ENABLE  --> enable Wifi IRQ
 beq   arm7_irqEnable2                  ;/
 cmp   r0,WIFI_STARTUP                  ;\
 ldreq r0,=Wifi_Data_Struct_start       ; WIFI_STARTUP
 beq   dsi7_Wifi_Init                   ;/
 bx    lr                               ;-OTHER        --> exit/ignore
;------------------
dsi7_Wifi_Init:
 push r4-r12,lr

      .if with_crypto_selftest
        bl wifi_selftest_md5
        bl wifi_selftest_md5_hmac
        bl wifi_selftest_sha1
        bl wifi_selftest_sha1_hmac
        bl wifi_selftest_psk_unreal_fast
       ;bl wifi_selftest_psk_real_slow
        bl wifi_selftest_ptk
        bl wifi_selftest_pmkid
        bl wifi_selftest_eapol_rc4
        bl wifi_selftest_eapol_aes_wrap
        bl wifi_selftest_eapol_aes_unwrap
      .endif


 ldr  r1,=arm7_WifiData         ;\memorize ptr to wifidata (BLAH, except
 str  r0,[r1]                   ;/maybe needed as "init-done" flag)
;- - -
 mov  r0,IRQ2_DSI_WIFI          ;\enable IRQ (this was originally done by "arm7_wifiAddressHandler", which did then call "Wifi_Init", which is now merged to single "Wifi_Init" function)
 bl   arm7_irqEnable2           ;/
 bl   arm7_InitFlashData        ;-load wifi flash calibration data
 bl   arm7_GetWfcSettings       ;-load wifi flash access point data
 ldr  r0,=FlashData+36h    ;src ;\
 ldr  r1,=WifiData_MacAddr ;dst ; copy MAC addr to RAM
 bl   arm7_Wifi_CopyMacAddr     ;/
;- - -reset/shutdown wifi...
;;; bl   arm7_Wifi_Stop            ;-
;- - -


 mov  r0,1                      ;\
        ;XXXXchannel
        mov r0,11  ;XXXX????!!!! speedup boot (when using that channel)

    ldr  r1,=boot_channel_index
    mov  r0,0
    str  r0,[r1]
    ldr  r1,=boot_channel_wait
    mov  r0,2  ;1   ;2
    str  r0,[r1]
    ldr  r1,=boot_channel_list+0
    ldrb r0,[r1]

 ldr  r1,=WifiData_curChannel   ;
 strh r0,[r1]  ;=0001h          ; initially mark as channel 1
 ldr  r1,=WifiData_reqChannel   ;
 strh r0,[r1]  ;=0001h          ;/
 mov  r0,WIFIMODE_DISABLED      ;\
 ldr  r1,=WifiData_curMode      ;
 strh r0,[r1]  ;=disabled       ; initially mark as disabled
 ldr  r1,=WifiData_reqMode      ;
 strh r0,[r1]  ;=disabled       ;/
 ldr  r0,=WFLAG_PACKET_ALL-WFLAG_PACKET_BEACON  ;\initial packet requests
 ldr  r1,=WifiData_reqPacketFlags               ; (all, except beacon)
 str  r0,[r1]  ;32bit                           ;/(uh, why no beacons?)
 mov  r0,0                      ;\
 ldr  r1,=WifiData_curReqFlags  ;
 strh r0,[r1]  ;=0000h          ; initially mark req'flags zero (WFLAG_REQ_xxx)
 ldr  r1,=WifiData_reqReqFlags  ;
 strh r0,[r1]  ;=0000h          ;/
 mov  r0,0ah   ;1Mbit/s         ;\
 ldr  r1,=WifiData_maxrate7     ; initially max rate 1Mbit/s
 strh r0,[r1]  ;=000ah          ;/
;- - -
;;; mov  r0,0                      ;\disable wifi IRQs
;;; strh r0,[rx,W_IE]              ;/
;- - - set default settings...
;;; mov  r0,1                              ;\initially select channel 1
;;; bl   arm7_Wifi_SetChannel              ;/

;;; ldr  r1,=WifiData_random               ;\
;;; ldr  r0,[r1]                           ;
;;;   ldr r2,=4805F40h     ;XXXX try so..?
;;;   ldrh r3,[r2]
;;;   add  r0,r3
;;;   add  r3,123
;;;   strh r3,[r2]
;;;   ;;;ldr  r2,=sgIP_timems   ;XXXX can't do this on ARM7 (arm9 only)
;;;   ;;;str  r0,[r2]
;;; ldrh r2,[rx,W_RANDOM]                  ;
;;; eor  r0,r0,r2,lsl 0                    ; update random value
;;; eor  r0,r0,r2,lsl 11                   ;
;;; eor  r0,r0,r2,lsl 22                   ;
;;; str  r0,[r1]                           ;/
 ldr  r1,=WifiData_flags7               ;\
 ldr  r0,[r1]                           ; mark active
 orr  r0,WFLAG_ARM7_ACTIVE              ;
 str  r0,[r1]                           ;/
;- - -
 ldr  r0,=2000400h                      ;\
 ldr  r1,=twlcfg_etc_buf                ; create backup copy of incoming
 mov  r2,214h                           ; 2000400h (especially wlfirm)
 bl   memcopy_bytewise                  ;/
 bl   sdio_atheros_init                 ;--->

;- - -
 bl   sdio_prepare_scanning

;;; bl   sdio_scan_channel
;;;        ;XXX till found matching beacon
;;; bl   sdio_scan_channel
;;; bl   sdio_scan_channel
;;; bl   sdio_scan_channel
;;; bl   sdio_connect


 pop  r4-r12,pc
;------------------
dsi7_Wifi_Deinit:
 push lr

        ;XXX

.if 0
   ldr  r0,=ath_disconnect_cmd      // bl sdio_send_wmi_cmd       ;-
  @@lll:
   bl   sdio_poll_mbox            ;-poll mbox
   b @@lll   ;XXX until WMI_DISCONNECT_EVENT
.endif

.if wifi_with_dsi_irq   ;DISABLE... needed to prevented unwanted further IRQs
   ldr  r1,=REGBASE_SDIO
   ldrh r0,[r1,REG_SDIO_CARD_IRQ_STAT]          ;-
   ldrh r0,[r1,REG_SDIO_CARD_IRQ_DISABLE]       ;\
   orr  r0,1  ;Card /IRQ                        ;
   strh r0,[r1,REG_SDIO_CARD_IRQ_DISABLE]       ;/
   ldrh r0,[r1,REG_SDIO_CARD_IRQ_ENABLE]        ;\
   bic  r0,1  ;Card /IRQ                        ;
   strh r0,[r1,REG_SDIO_CARD_IRQ_ENABLE]        ;/
.endif

 pop   pc
;------------------
dsi7_Wifi_Update:  ;in/out: none   ;aka arm7_Wifi_Sync
 push r4-r5,lr
 ldr  r0,=arm7_WifiData                 ;\
 ldr  r0,[r0]                           ; exit if not yet initialized
 cmp  r0,0                              ;
 beq  @@exit                            ;/
;;; ldr  r1,=WifiData_random               ;\
;;; ldr  r0,[r1]                           ;
;;; ldrh r2,[rX,W_RANDOM]                  ;
;;; eor  r0,r0,r2,lsl 0                    ; update random value
;;; eor  r0,r0,r2,lsl 11                   ;
;;; eor  r0,r0,r2,lsl 22                   ;
;;; str  r0,[r1]                           ;/
 ldr  r1,=WifiData_stats                ;\
 ldr  r2,[r1,WSTAT_ARM7_UPDATES*4] ;\   ; raise stats
 add  r2,1                         ;    ; (num ARM7 updates)
 str  r2,[r1,WSTAT_ARM7_UPDATES*4] ;/   ;/
;check flags/requests for current mode, see if we need to change anything...
 ldr  r5,=WifiData_reqMode                                              ;\
 ldrh r5,[r5]     ;reqMode                                              ;/
 ldr  r0,=WifiData_curMode                                              ;\
 ldrh r0,[r0]                                                           ;
 cmp  r0,WIFIMODE_DISABLED        // beq @@update_disabled_mode         ;
 cmp  r0,WIFIMODE_NORMAL          // beq @@update_normal_mode           ;
 cmp  r0,WIFIMODE_SCAN            // beq @@update_scan_mode             ;
 cmp  r0,WIFIMODE_ASSOCIATE       // beq @@update_associate_mode        ;
 cmp  r0,WIFIMODE_ASSOCIATED      // beq @@update_associated_mode       ;
 cmp  r0,WIFIMODE_CANNOTASSOCIATE // beq @@update_cannot_associate_mode ;
@@finish:   ;<-- return here after above mode jumps                     ;/
;;; ldr  r0,=WifiData_reqChannel                   ;\
;;; ldrh r0,[r0]     ;reqChannel                   ;
;;; ldr  r1,=WifiData_curChannel                   ; if a new/different channel is
;;; ldrh r1,[r1]     ;curChannel                   ; requested, then set channel
;;; cmp  r0,r1                                     ;
;;;;movne r0,r0      ;reqChannel   ;\set channel   ;
;;; blne  arm7_Wifi_SetChannel     ;/              ;/

 bl   sdio_poll_mbox            ;-poll mbox

;;; bl   arm7_Wifi_Intr_RxEnd                      ;-check RX
;;; bl   arm7_Wifi_Intr_TxEnd                      ;-check if we need to TX anything, easiest way to do so at the moment.

@@exit:
 pop  r4-r5,pc
;---
@@finish_set_new_curMode:
 ldr  r1,=WifiData_curMode
 strh r0,[r1]
 b    @@finish
;--- --- --- ------
@@update_disabled_mode:   ;when in WIFIMODE_DISABLED
;;; mov  r0,LED_ON                                 ;\LED=On
;;; bl   arm7_ProxySetLedState                     ;/
 cmp  r5,WIFIMODE_DISABLED      ;reqMode        ;\if requested, stay DISABLED
 beq  @@finish                                  ;/
;;; bl   arm7_Wifi_Start           ;start          ;\start, and enter NORMAL mode
    ;aka Wifi_Start... (enables processing IRQ2_DSI_WIFI)
    ldr  r1,=WifiData_flags7               ;\
    ldr  r0,[r1]                           ; mark wifi running
    orr  r0,WFLAG_ARM7_RUNNING  ;set       ;
    str  r0,[r1]                           ;/


 mov  r0,WIFIMODE_NORMAL                        ; (may then switch from that
 b    @@finish_set_new_curMode                  ;/mode to another mode)
;--- --- --- ------
@@update_normal_mode:     ;when in WIFIMODE_NORMAL   ;main switcher function
;;; mov  r0,LED_LONGBLINK                          ;\LED=LongBlink
;;; bl   arm7_ProxySetLedState                     ;/
 cmp  r5,WIFIMODE_DISABLED      ;reqMode        ;\
 bne  @@dont_disable                            ;
;;; bl   arm7_Wifi_Stop            ;stop           ; if requested, stop and DISABLE
 mov  r0,WIFIMODE_DISABLED      ;disable...     ;
 b    @@finish_set_new_curMode  ;--> finish     ;
@@dont_disable:                                 ;/
 cmp  r5,WIFIMODE_SCAN          ;reqMode        ;\
 bne  @@dont_scan                               ;
;;; ldrh r0,[rX,W_US_COUNT1]  ;\memorize scan      ; if requested, SCAN
;;; ldr  r1,=WifiData_counter7; start time         ;
;;; str  r0,[r1]              ;/(65.5ms units)     ;  ;<-- in 65.5ms units (bit16-31 of US_COUNT)
 mov  r0,WIFIMODE_SCAN     ;-scan now...        ;
 b    @@finish_set_new_curMode  ;--> finish     ;
@@dont_scan:                                    ;/
 ldr  r1,=WifiData_curReqFlags  ;<-- curReq     ;\
 ldrh r0,[r1]                   ;\              ;
 tst  r0,WFLAG_REQ_APCONNECT    ; test          ; if already connected,
 beq  @@dont_disconnect         ;/              ; then disconnect now
 bic  r0,WFLAG_REQ_APCONNECT    ;\              ; ;\
;ldr  r1,=WifiData_curReqFlags  ; clear         ; ;
 strh r0,[r1]                   ;/              ; ;
;;; ldr  r0,=WifiData_MacAddr ;src         ;\      ; ; disconnect
;;; add  r1,rX,W_BSSID        ;dst         ;       ; ;
;;; bl   arm7_Wifi_CopyMacAddr             ;/      ; ;
;;; ldrh r0,[rX,W_RXFILTER]                ;\      ; ;
;;; bic  r0,400h  ;bit10=0 (no beacons)    ;       ; ;
;;; orr  r0,800h  ;bit11=1 (allow toDS ?)  ;       ; ;
;;; strh r0,[rX,W_RXFILTER]                ;/      ; ;
;;; ldrh r0,[rX,W_RXFILTER2]               ;\      ; ;
;;; bic  r0,2     ;clear bit1              ;       ; ;
;;; strh r0,[rX,W_RXFILTER2]               ;/      ; ;/
@@dont_disconnect:                              ;/
 ldr  r1,=WifiData_reqReqFlags  ;<-- reqReq     ;\
 ldrh r0,[r1]                   ;\              ;
 tst  r0,WFLAG_REQ_APCONNECT    ; test          ; if not connected,
 beq  @@dont_connect            ;/              ; then connect now

 bl   arm7_copy_ap_data_from_arm9  ;in: r0      ; ;\connect...
 bl   sdio_connect                              ; ;

;;; ldr  r0,=WifiData_curReqFlags                  ; ; ;\
;;; ldrh r0,[r0]                                   ; ; ; if adhoc
;;; tst  r0,WFLAG_REQ_APADHOC                      ; ; ; --> associated
;;; ldr  r1,=WifiData_authlevel               ;--> ; ; ; else
;;; movne r0,WIFI_AUTHLEVEL_ASSOCIATED   ;adhoc    ; ; ; --> disconnected
;;; moveq r0,WIFI_AUTHLEVEL_DISCONNECTED      ;<-- ; ; ; --> and send packet
;;; strh  r0,[r1]                                  ; ; ;
;;; bleq  arm7_Wifi_SendOpenSystemAuthPacket  ;<-- ; ; ;/
 ldr  r0,=WifiData_txbufOut                     ; ; ;\
 ldr  r0,[r0]                                   ; ; ; force empty
 ldr  r1,=WifiData_txbufIn                      ; ; ; tx buffer
 str  r0,[r1]                                   ; ; ;/
 ldr  r1,=WifiData_curReqFlags                  ; ; ;\
 ldrh r0,[r1]                                   ; ; ; connect request flag
 orr  r0,WFLAG_REQ_APCONNECT                    ; ; ;
 strh r0,[r1]                                   ; ; ;/
;;; ldrh r0,[rX,W_US_COUNT1]       ;\get time      ; ; ;\
;;; ldr  r1,=WifiData_counter7     ; (65.5ms units); ; ; init start time
;;; str  r0,[r1]                   ;/              ; ; ; and retry count
;;; mov  r0,0                      ;\init retry    ; ; ;
;;; ldr  r1,=WifiData_authctr      ; count         ; ; ;
;;; strh r0,[r1]                   ;/              ; ; ;/

 mov  r0,WIFIMODE_ASSOCIATE                     ; ; ;\new curMode
 b    @@finish_set_new_curMode   ;--> finish    ; ;/;/
@@dont_connect:                                 ;/
 b    @@finish
;--- --- --- ------
@@update_scan_mode:             ;when in WIFIMODE_SCAN
;;; mov  r0,LED_LONGBLINK                          ;\LED=LongBlink
;;; bl   arm7_ProxySetLedState                     ;/
 cmp  r5,WIFIMODE_SCAN          ;reqMode        ;\if scan no longer requested,
 movne r0,WIFIMODE_NORMAL                       ; switch to NORMAL
 bne   @@finish_set_new_curMode  ;--> finish    ;/
 bl   sdio_scan_channel                         ;-scan
 b    @@finish                                  ;-
;--- --- --- ------
@@update_associate_mode:        ;when in WIFIMODE_ASSOCIATE
;;; mov  r0,LED_LONGBLINK                          ;\LED=LongBlink
;;; bl   arm7_ProxySetLedState                     ;/
 ldr  r0,=WifiData_authlevel                    ;\
 ldrh r0,[r0]                                   ; if now associated okay,
 cmp  r0,WIFI_AUTHLEVEL_ASSOCIATED              ; switch to associated
 moveq r0,WIFIMODE_ASSOCIATED                   ;
 beq   @@finish_set_new_curMode  ;--> finish    ;/


.comment
   ldrh r0,[rX,W_US_COUNT1]  ;\                   ;\
   ldr  r1,=WifiData_counter7; time since start   ;
   ldr  r2,[r1]    ;counter7 ; (65.5ms units)     ; on associate timeout,
   sub  r3,r0,r2             ;                    ; reattempt connect stage...
   cmp  r3,20  ;ca. 1 sec    ;                    ;
   blo  @@no_assoc_timeout   ;/                   ;
   str  r0,[r1]    ;counter7 ;-new time origin    ;
   ldr  r1,=WifiData_authctr                      ; ;\
   ldrh r0,[r1]                                   ; ;
   add  r0,1                                      ; ; raise retry count,
   strh r0,[r1]                                   ; ; give up if too high
   cmp  r0,WIFI_MAX_ASSOC_RETRY                   ; ;
   movhi r0,WIFIMODE_CANNOTASSOCIATE              ; ;
   bhi   @@finish_set_new_curMode  ;--> finish    ; ;/
   ldr  r1,=WifiData_authlevel                    ; ;\
   ldrh r0,[r1]                                   ; ; check authlevel...
   cmp  r0,WIFI_AUTHLEVEL_DISCONNECTED            ; ; ;\
   bne  @@not_disconnected                        ; ; ; DISCONNECTED
   ldr  r0,=WifiData_curReqFlags                  ; ; ; ;\
   ldrh r0,[r0]                                   ; ; ; ; check flags
   tst  r0,WFLAG_REQ_APADHOC                      ; ; ; ;/
  ;ldreq  r1,=WifiData_authlevel                  ; ; ; ;\
   moveq  r0,WIFI_AUTHLEVEL_ASSOCIATED            ; ; ; ; change LEVEL to assoc
   streqh r0,[r1]                                 ; ; ; ;
   beq   @@finish   ;and STAY      ;--> finish    ; ; ; ;/
   bl   arm7_Wifi_SendOpenSystemAuthPacket        ; ; ; ;\or send auth packet
   b    @@finish   ;and STAY      ;--> finish     ; ; ; ;/
  @@not_disconnected:                             ; ; ;/
   cmp   r0,WIFI_AUTHLEVEL_DEASSOCIATED           ; ; ;\
   cmpne r0,WIFI_AUTHLEVEL_AUTHENTICATED          ; ; ; if DEASSOCIATED
   bne   @@dont_assoc                             ; ; ; or AUTHENTICATED,
   bl    arm7_Wifi_SendAssocPacket                ; ; ; send ASSOC packet
   b     @@finish   ;and STAY      ;--> finish    ; ; ;
  @@dont_assoc:                                   ; ; ;/
   cmp  r0,WIFI_AUTHLEVEL_ASSOCIATED              ; ; ;\
   moveq r0,WIFIMODE_ASSOCIATED                   ; ; ; ASSOCIATED
   beq   @@finish_set_new_curMode  ;--> finish    ; ; ;/
  @@no_assoc_timeout:                             ;/
.comment


 ldr  r0,=WifiData_reqReqFlags                  ;\
 ldrh r0,[r0]     ;reqReqFlags                  ; if no APCONNECT request,
 tst  r0,WFLAG_REQ_APCONNECT                    ; switch to NORMAL
 moveq r0,WIFIMODE_NORMAL                       ;
 beq   @@finish_set_new_curMode  ;--> finish    ;/
 b    @@finish
;--- --- --- ------
@@update_associated_mode:       ;when in WIFIMODE_ASSOCIATED
;;; mov  r0,LED_SHORTBLINK                         ;\LED=ShortBlink !!!
;;; bl   arm7_ProxySetLedState                     ;/
;- - -
 ldr  r0,=WifiData_reqReqFlags                  ;\
 ldrh r0,[r0]     ;reqReqFlags                  ; if no APCONNECT request,
 tst  r0,WFLAG_REQ_APCONNECT                    ; switch to NORMAL
 moveq r0,WIFIMODE_NORMAL                       ;
 beq   @@finish_set_new_curMode  ;--> finish    ;/
 ldr  r0,=WifiData_authlevel                    ;\
 ldrh r0,[r0]                                   ; if no longer associated,
 cmp  r0,WIFI_AUTHLEVEL_ASSOCIATED              ; switch to (re-)associate
 movne r0,WIFIMODE_ASSOCIATE                    ;
 bne   @@finish_set_new_curMode  ;--> finish    ;/
 b    @@finish
;--- --- --- ------
@@update_cannot_associate_mode: ;when in WIFIMODE_CANNOTASSOCIATE
;;; mov  r0,LED_LONGBLINK                          ;\LED=LongBlink
;;; bl   arm7_ProxySetLedState                     ;/
 ldr  r0,=WifiData_reqReqFlags                  ;\
 ldrh r0,[r0]     ;reqReqFlags                  ; if no APCONNECT request,
 tst  r0,WFLAG_REQ_APCONNECT                    ; switch to NORMAL
 moveq r0,WIFIMODE_NORMAL                       ;
 beq   @@finish_set_new_curMode  ;--> finish    ;/
 b    @@finish                                  ;-stay
;------------------
dsi7_ack_card_irq:

@@retry:
 mov  r1,4000000h                       ;\
 mov  r0,IRQ2_DSI_WIFI                  ; ack IF2 (wifi)
 str  r0,[r1,REG_IF2]                   ;/
;mov  r1,00005h                         ;\
;push lr                                ;
;bl   sdio_read_func0byte               ; Read Func[0:00005] = 02
;pop  lr                                ;
;tst  r0,02h                            ; (this does probably ACK the irq...?)
;beq  @@exit  ;oops, no irq             ;/
;ldr  r1,=REGBASE_SDIO                  ;\
;mov  r0,not 0001h                      ; ack card irq (NOT needed?)
;strh r0,[r1,REG_SDIO_CARD_IRQ_STAT]    ;/

         ;mov  r1,4000000h                       ;\
         ;ldr  r0,[r1,REG_IF2]                   ;
         ;tst  r0,IRQ2_DSI_WIFI                  ; IF2 (wifi)
         ;bne @@retry                            ;/
 bx   lr
;------------------
dsi7_Wifi_Interrupt:    ;XXX no idea if acknowleding is done in correct order
 push lr
        bl   dsi7_ack_card_irq
;- - -
 ldr  r0,=arm7_WifiData         ;\
 ldr  r0,[r0]                   ; exit if not yet initialized
 cmp  r0,0                      ;
 beq  @@exit                    ;/
 ldr  r0,=WifiData_flags7       ;\
 ldr  r0,[r0]                   ; exit if not running
 tst  r0,WFLAG_ARM7_RUNNING     ;
 beq  @@exit                    ;/
 bl   sdio_poll_mbox            ;-poll mbox
 b    @@done

        ;XXX ensure no NDS-style WEP stuff in RX/TX packets
        ;XXX RX data (maybe read from mbox ONLY if ARM9 is ready for data)
        ;XXX TX data send (unless await data.ack)
        ;XXX TX data.ack --> send next

;;; tst rx,01h     // blne dsi7_Wifi_Intr_RxEnd            ;\
;;; tst rx,02h     // blne dsi7_Wifi_Intr_TxEnd            ; process IRQ's
.if with_gimmicks
;;; tst rx,10h+20h // blne dsi7_Wifi_Intr_CntOverflow      ;/
.endif
;- - -
@@exit:
@@done:
 pop  pc
;------------------
.data?
.align 40h      ;XXX cache?
ath_lookahead_value     dd 0
ath_lookahead_flag      db 0  ;\
ath_cmd_ack_pending     db 0  ; XXX must be initially zero
ath_data_ack_pending    db 0  ;/
ath_await_scan_complete     db 0
ath_await_connect_complete  db 0
.align 4
.align 40h      ;XXX cache?
.code
;------------------
xlat_channel_to_mhz:
 sub   r0,1     ;1..14 --> 0..13
 cmp   r0,13
 movhi r0,0             ;oops, force first channel
 add   r0,r0,r0,lsl 2   ;mul5
 ldr   r1,=096Ch
 add   r0,r1            ;096Ch+(ch-1)*5
 ldreq r0,=09B4h  ;2484MHz (japan) if ch=14
 bx    lr
;------------------
sdio_prepare_scanning:
 push lr
 ldr  r0,=ath_error_report_cmd    // bl sdio_send_wmi_cmd       ;-
;ldr  r0,=ath_debuglog_cmd        // bl sdio_send_wmi_cmd       ;-doesn't help disabling debuglog events?
 ldr  r0,=ath_set_framerates_cmd  // bl sdio_send_wmi_cmd       ;-
;ldr  r0,=ath_error_report_cmd    // bl sdio_send_wmi_cmd       ;-again?
 ldr  r0,=ath_get_channels_cmd    // bl sdio_send_wmi_cmd       ;\
 bl   sdio_poll_mbox  ;-poll mbox (for channel_list reply)      ;/
;(above will send CHANNEL_LIST reply; depending on REG_DOMAIN)  ;/
 pop  pc
;------------------
sdio_scan_channel:
 push lr
 ldr  r1,=ath_await_scan_complete       ;\
 ldrb r0,[r1]                           ;
 cmp  r0,0                              ;
 bne  @@already_scanning                ;/
;- - -
 ldr  r0,=ath_set_bss_filter_cmd_0                      ;\filter OFF
 bl   sdio_send_wmi_cmd                                 ;/
 ldr  r0,=ath_set_probed_ssid_cmd                       ;\set probed whatever
 bl   sdio_send_wmi_cmd                                 ;/
@@retry:
 bl   arm7_get_next_scan_channel        ;-              ;\
 ldr  r1,=WifiData_reqChannel           ;\channel       ;
 ldrh r0,[r1]                           ;/              ;
 ldr  r2,=WifiData_reg_channels         ;\
 ldr  r2,[r2]  ;enabled channels mask   ; *** Some (or all?) DSi's have only channel 1-11 enabled, and throw
 mov  r3,1                              ; *** WMI_CMDERROR_EVENT when trying to set channel 12,13,14.
 tst  r2,r3,lsl r0 ;test mask,(1 shl ch);
 beq  @@retry                           ;/              ;
 ldr  r1,=WifiData_curChannel           ;\curr channel  ; set channel
 strh r0,[r1]                           ;/              ;
 bl   xlat_channel_to_mhz               ;\              ;
 mov  r1,r0                             ;/              ;
 ldr  r0,=ath_set_channel_params_cmd                    ;
 strh r1,[r0,8+04h]  ;channel in MHz                    ;
 bl   sdio_send_wmi_cmd                                 ;/
 ldr  r0,=ath_set_scan_params_cmd                       ;\
 ldr  r1,=boot_channel_wait                             ;
 ldr  r1,[r1]                                           ;
 mov  r1,r1,lsl 6  ;mul 64ms                            ; set scan params
 strh r1,[r0,8+06h]  ;msec, maxact_chdwell_time         ;
 strh r1,[r0,8+08h]  ;msec, pas_chdwell_time            ;
 strh r1,[r0,8+0ch]  ;msec, minact_chdwell_time         ;
 mov  r1,01h  ;(bit0=scan in CONNECT cmd, why?)         ;
 strb r1,[r0,8+0bh]  ;scanCtrlFlags (5bits used)        ;
 bl   sdio_send_wmi_cmd                                 ;/
 ldr  r0,=ath_set_bss_filter_cmd_1                      ;\filter ON
 bl   sdio_send_wmi_cmd                                 ;/
 ldr  r1,=ath_await_scan_complete       ;\              ;\
 mov  r0,1                              ;               ;
 strb r0,[r1]                           ;/              ; start scan
 ldr  r0,=ath_start_scan_cmd            ;\              ;
 bl   sdio_send_wmi_cmd                 ;/              ;/
;above will throw WMI_BSSINFO_EVENT(s)  --> beacon(s)
;above will throw WMI_SCAN_COMPLETE_EVENT --> dwell time ellapsed


.comment
@@scan_lop:
 bl   sdio_poll_mbox                    ; poll mbox
       ;XXX handle WMI_BSSINFO_EVENT(s)  --> beacon
       ;XXX handle WMI_SCAN_COMPLETE_EVENT
 ldr  r1,=ath_await_scan_complete       ;\
 ldrb r0,[r1]                           ;
 cmp  r0,0                              ;
 bne  @@scan_lop                        ;/
       ;XXX if NOTYET found, repeat above after SCAN_COMPLETE with new channel
.comment


@@already_scanning:
 pop  pc
;------------------
.pool
;------------------
sdio_connect:
 push r4,lr
;ldr  r0,=ath_error_report_cmd                          ;\again?
;bl   sdio_send_wmi_cmd                                 ;/
;ldr  r0,=ath_set_bss_filter_cmd_0  ;OFF no beacons     ;\
 ldr  r0,=ath_set_bss_filter_cmd_4  ;ONLY curr beacon   ; beacon filter (curr beacon, for updating RSSI display)
 bl   sdio_send_wmi_cmd                                 ;/
;ldr  r0,=ath_set_probed_ssid_cmd                       ;\again?
;bl   sdio_send_wmi_cmd                                 ;/
 ldr  r0,=ath_set_scan_params_cmd                       ;\
 mov  r1,00C8h                                          ;
 strh r1,[r0,8+06h]  ;msec, maxact_chdwell_time         ; set scan params
 strh r1,[r0,8+08h]  ;msec, pas_chdwell_time            ;
 strh r1,[r0,8+0ch]  ;msec, minact_chdwell_time         ;
 mov  r1,05h                                            ;
 strb r1,[r0,8+0bh]  ;scanCtrlFlags (5bits used)        ;
 bl   sdio_send_wmi_cmd                                 ;/
 ldr  r0,=WifiData_apchannel7 ;\get channel             ;\
 ldrb r0,[r0]                 ;/                        ;
 ldr  r1,=WifiData_reqChannel ;\req channel             ;
 strh r0,[r1]                 ;/                        ;
 ldr  r1,=WifiData_curChannel ;\curr channel            ; set channel
 strh r0,[r1]                 ;/                        ;
 bl   xlat_channel_to_mhz     ;\xlat to MHz             ;
 mov  r1,r0                   ;/                        ;
 ldr  r0,=ath_set_channel_params_cmd                    ;
 strh r1,[r0,8+04h]  ;channel in MHz                    ;
 bl   sdio_send_wmi_cmd                                 ;/
;- - -
      .if 0
        mov  r4,0  ;key.index (0..3)                           ;\
       @@del_key_lop:                                          ;
        ldr  r0,=ath_del_cipher_key_cmd                        ;
        strb r4,[r0,8+00h]   ;keyIndex (0..3)  ;-              ;
        bl   sdio_send_wmi_cmd                 ;--> send cmd   ;
        add  r4,1  ;key.index (0..3)                           ;
        cmp  r4,4                                              ;
        blo  @@del_key_lop                                     ;/
      .endif
;- - -
 ldr  r1,=WifiData_grp7                                 ;\
 ldrb r0,[r1]                                           ;
 cmp  r0,KEY_TYPE_WEP                                   ;
 bne  @@skip_wep_keys                                   ;/
 mov  r4,0  ;key.index (0..3)                           ;\
@@wep_key_lop:                                          ;
 ldr  r0,=ath_add_cipher_key_cmd+8+04h  ;\              ;
 mov  r1,08h                ;len        ; rsc (zero)    ;
 bl   zerofill_bytewise                 ;/              ;
 ldr  r0,=WifiData_wepkey7 ;src         ;\              ;
 ldr  r1,=ath_add_cipher_key_cmd+8+0Ch  ; key           ;
 mov  r2,20h               ;len         ;               ;
 bl   memcopy_bytewise                  ;/              ;
 ldr  r0,=ath_add_cipher_key_cmd                        ;
 strb r4,[r0,8+00h]   ;keyIndex (0..3)  ;-              ;
 mov  r1,KEY_TYPE_WEP ;CRYPTO_TYPE      ;\              ;
 strb r1,[r0,8+01h]   ;keyType          ;/              ;
 mov  r1,03h   ;???, 3=WEP              ;\              ;
cmp r4,0     ;key.index
movne r1,01h ;?
 strb r1,[r0,8+02h]   ;keyUsage         ;/              ;
 ldr  r1,=WifiData_wepmode7             ;\              ; apply WEP key0..3
 ldrb r1,[r1]                           ;               ; must set key1,2,3 too! -- else throws WMI_ERROR_REPORT_EVENT with errorVal=00000002h !
 mov   r2,13    ;-keylen, default       ;               ;
 cmp   r1,01h   ;\keylen, usa           ; keyLength     ;
 moveq r2,5     ;/                      ;               ;
 cmp   r1,03    ;\keylen, nonstandard   ;               ;
 moveq r2,16    ;/                      ;               ;
 strb r2,[r0,8+03h]   ;keyLength        ;/              ;
 bl   sdio_send_wmi_cmd                 ;--> send cmd   ;
 add  r4,1  ;key.index (0..3)                           ;
 cmp  r4,4                                              ;
 blo  @@wep_key_lop                                     ;/
@@skip_wep_keys:
;- - -
       ;ldr r0,=ath_set_fixrates_cmd      // bl sdio_send_wmi_cmd  ;XXX <-- browser doesn't do this
 ldr  r0,=ath_set_bitrate_cmd             // bl sdio_send_wmi_cmd       ;
 ldr  r0,=ath_set_ap_ps_cmd               // bl sdio_send_wmi_cmd       ;
 ldr  r0,=ath_synchronize_cmd_2008h       // bl sdio_send_wmi_cmd       ;
 ldr  r0,=ath_set_power_mode_cmd          // bl sdio_send_wmi_cmd       ;
 ldr  r0,=ath_synchronize_cmd_0000h       // bl sdio_send_wmi_cmd       ;
 ldr  r0,=ath_create_pstream_cmd_1st      // bl sdio_send_wmi_cmd       ;

     ;ldr  r0,=ath_create_pstream_cmd_2nd      // bl sdio_send_wmi_cmd       ;XXX ;browser does that elsewhere
     ;ldr  r0,=ath_create_pstream_cmd_3rd_4th  // bl sdio_send_wmi_cmd       ;XXX ;browser does that elsewhere
     ;ldr  r0,=ath_create_pstream_cmd_3rd_4th  // bl sdio_send_wmi_cmd       ;XXX ;browser does that elsewhere

 ldr  r0,=ath_set_wsc_status_cmd          // bl sdio_send_wmi_cmd       ;
 ldr  r0,=ath_set_disconnect_timeout_cmd  // bl sdio_send_wmi_cmd       ;
 ldr  r0,=ath_set_keepalive_cmd           // bl sdio_send_wmi_cmd       ;
;- - -
 ldr  r1,=ath_await_connect_complete    ;\              ;\
 mov  r0,1                              ;               ;
 strb r0,[r1]                           ;/              ;

 ldr  r0,=WifiData_eapol7;\eapol type type              ;
 ldrb r0,[r0]            ;/                             ; connect
 cmp    r0,EAPOL_TYPE_NONE               ;\handshake    ;
 ldrne  r1,=WifiData_4way_handshake_busy ; busy, unless ;
 movne  r2,1                             ; eapol=none   ;
 strneb r2,[r1]                          ;/             ;
 ldr   r3,=WifiData_pair7 ;\pairwise crypto type        ;
 ldrb  r3,[r3]            ;/                            ;
 ldr   r4,=WifiData_grp7  ;\group crypto type           ;
 ldrb  r4,[r4]            ;/                            ;
 mov   r1,1  ;normal      ;\                            ;
 cmp   r4,KEY_TYPE_WEP    ; dot11AuthMode               ;
 moveq r1,2  ;wep         ;/                            ;
 mov   r2,1  ;normal      ;\                            ;
 cmp   r0,EAPOL_TYPE_WPA  ;                             ;
 moveq r2,3  ;wpa         ; authMode                    ;
 cmp   r0,EAPOL_TYPE_WPA2 ;                             ;
 moveq r2,5  ;wpa2        ;/                            ;
      ;mov r0,r1 // bl wrhex8bit // bl wrspc
      ;mov r0,r2 // bl wrhex8bit // bl wrspc
      ;mov r0,r3 // bl wrhex8bit // bl wrspc
      ;mov r0,r4 // bl wrhex8bit // bl wrspc
      ;bl wrcrlf

.comment
   ldr  r1,=WifiData_wepmode7                     ;\      ;
   ldrb r0,[r1]                                   ;       ;
   cmp  r0,00h    ;0=WEP off                      ;       ;
   moveq r1,1       ;dot11AuthMode       ;\       ;       ;
   movne r2,1       ;authMode            ; open   ;       ;
   moveq r3,1       ;pairwiseCryptoType  ;        ;       ;
   moveq r4,1       ;groupCryptoType     ;/       ;       ;
   movne r1,2 ;(!)  ;dot11AuthMode       ;\       ;       ;
   movne r2,1       ;authMode            ; WEP    ;       ;
   movne r3,2       ;pairwiseCryptoType  ;        ;       ;
   movne r4,2       ;groupCryptoType     ;/       ;       ;
    XXX below had destroyed r1... but worked somehow?
   ldr  r1,=WifiData_wpamode7                     ;       ;
   ldrb r0,[r1]                                   ;       ;
   ldr  r1,=WifiData_4way_handshake_busy  ;\
   strb r0,[r1] ;0=No, 4..7=Busy          ;/
   cmp  r0,04h    ;4=WPA-TKIP                     ;       ;
   moveq r1,1       ;dot11AuthMode       ;\       ;       ;
   moveq r2,3 ;(!)  ;authMode            ; WPA    ;       ;
   moveq r3,3       ;pairwiseCryptoType  ;        ;       ;
   moveq r4,3       ;groupCryptoType     ;/       ;       ;
   cmp  r0,07h    ;4=WPA2-AES                     ;       ;
   moveq r1,1       ;dot11AuthMode       ;\       ;       ;
   moveq r2,5 ;(!)  ;authMode            ; WPA2   ;       ;
   moveq r3,4       ;pairwiseCryptoType  ;        ;       ;
   moveq r4,4       ;groupCryptoType     ;/       ;       ;
.comment


 ldr  r0,=ath_connect_cmd+8+00h                 ;\      ;
 strb r1,[r0,01h] ;dot11AuthMode                ;       ;
 strb r2,[r0,02h] ;AuthMode                     ;       ;
 strb r3,[r0,03h] ;pairwiseCryptoType           ;       ;
 strb r4,[r0,05h] ;groupCryptoType              ;/      ;
 ldr  r0,=WifiData_ssid7        ;\                      ;
 ldr  r1,=ath_connect_cmd+8+07h ; apply SSID            ;
 mov  r2,1+32                   ; (len, name)           ;
 bl   memcopy_bytewise          ;/                      ;
 ldr  r0,=WifiData_apchannel7   ;\                      ;
 ldrb r0,[r0]                   ;                       ;
 bl   xlat_channel_to_mhz       ; apply channel         ;
 ldr  r1,=ath_connect_cmd+8+28h ;                       ;
 strh r0,[r1]                   ;/                      ;
 ldr  r0,=WifiData_bssid7  ;src ;\                      ;
 ldr  r1,=ath_connect_cmd+8+2Ah ; apply bssid           ;
 bl   arm7_Wifi_CopyMacAddr     ;/                      ;
 ldr  r0,=ath_connect_cmd       ;\connect               ;
 bl   sdio_send_wmi_cmd         ;/                      ;/
    ;above can throw WMI_DISCONNECT_EVENT (eg. on bad WEP key)
    ;above can throw WMI_CONNECT_EVENT   (eg. on good WEP key)

;;;@@connect_lop:
;;; bl   sdio_poll_mbox                    ;-poll mbox
;;; ldr  r1,=ath_await_connect_complete    ;\
;;; ldrb r0,[r1]                           ; wait for CONNECT event
;;; cmp  r0,0                              ;
;;; bne  @@connect_lop                     ;/


 pop  r4,pc
;------------------
.pool
;------------------
ath_debuglog_cmd:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_EXTENSION_CMD
 dd WMIX_DBGLOG_CFG_MODULE_CMD  ;00h (PRE)
 dd 0                           ;04h (00h)  A_UINT32 4    whatever (setting this to zero doesn't help disabling debuglog events?)
@@end:
.align 4
;------------------
ath_heartbeat_cmd:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_EXTENSION_CMD
 dd WMIX_HB_CHALLENGE_RESP_CMD  ;00h (PRE)
 dd 0            ;MOD           ;04h (00h)  A_UINT32 4    cookie;   ;usually increasing 1,2,3,4,5,etc.
 dd 0                           ;08h (04h)  A_UINT32 4    source;   ;usually 0
@@end:
.align 4
;------------------
ath_set_bitrate_cmd:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_SET_BITRATE_CMD
 db 0ffh        ;00h  A_INT8  1   rateIndex     ;FFh    ;see WMI_BIT_RATE (FFh=Auto/default) (00h=1Mbit/s, 0Bh=54MBit/s)
 db 00h         ;01h  A_INT8  1   mgmtRateIndex ;0
 db 00h         ;02h  A_INT8  1   ctlRateIndex  ;0
;Note: This doesn't really work. Using rateIndex=FFh (or 0Bh) does currently
;reach only max 600Kbyte/s upload speed (which MIGHT be a bug in my software).
;However, using rateIndex=00h is slower, but still reaches more than
;200Kbyte/s (which is outright wrong and impossible at 1Mbit/s).
@@end:
.align 4
  ;------------------
  ;WMI_SET_FIXRATES_CMD  equ 0034h
  ;ath_set_fixrates_cmd:
  ;@@begin:
  ; db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_SET_FIXRATES_CMD
  ; dw 0fffh       ;00h  A_INT16 2   fixRateMask
  ;@@end:
  ;.align 4
;------------------
ath_set_ap_ps_cmd:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_SET_AP_PS_CMD
 db 01h,0a4h,0f7h,0ffh          ;whatever? (timings/type?)
@@end:
.align 4
;------------------
ath_synchronize_cmd_2008h:   ;with [06h]=2008h !!!  ;<-- as so in WEP log (but not so in WPA/WPA2-before-CONNECT logs?!)
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 2008h // dw WMI_SYNCHRONIZE_CMD
 db 00h         ;dataSyncMap
@@end:
.align 4
;------------------
ath_synchronize_cmd_0000h:   ;with [06h]=0000h !!!
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_SYNCHRONIZE_CMD
 db 00h         ;dataSyncMap
@@end:
.align 4
;------------------
ath_synchronize_cmd_0000h_01h: ;with [06h]=0000h, and param=01h !!! ;<-- as so in WPA/WPA2-after-CONNECT logs!
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_SYNCHRONIZE_CMD
 db 01h         ;dataSyncMap
@@end:
.align 4
;------------------
ath_synchronize_cmd_0000h_09h: ;with [06h]=0000h, and param=09h !!! ;<-- as so in WPA2 after handshake6 or so?
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_SYNCHRONIZE_CMD
 db 09h         ;dataSyncMap
@@end:
.align 4
;------------------
ath_dummy_data_xx_02:  ;DATA (not a CMD)
@@begin:
 db 02h,01h // dw @@end-@@begin-6, 0000h,  0200h
 ;note: in DSi browser, above byte[6] is random/garbage (eg. halfword 0200h could be 02xxh)
 ;(no data body, not even SA/DA mac addresses)
@@end:
.align 4
;------------------
;ath_dummy_data_xx_02_5:  ;DATA (not a CMD)
;@@begin:
; db 05h,01h*0000 // dw @@end-@@begin-6, 0000h,  0200h
; ;note: in DSi browser, above byte[6] is random/garbage (eg. halfword 0200h could be 02xxh)
; ;(no data body, not even SA/DA mac addresses)
;@@end:
;.align 4
;------------------
;ath_dummy_data_xx_02_z:  ;DATA (not a CMD)
;@@begin:
; db 02h,01h*000000000000 // dw @@end-@@begin-6, 0000h,  0200h
; ;note: in DSi browser, above byte[6] is random/garbage (eg. halfword 0200h could be 02xxh)
; ;(no data body, not even SA/DA mac addresses)
;@@end:
;.align 4
;------------------
ath_wpa2_handshake2_data:
@@begin:
 db 02h,01h // dw @@end-@@begin-6, 0000h,  1c00h
 defs 6    ;MOD     ;BSSID
 defs 6    ;MOD     ;MAC
 db (@@end-@@begin-6-10h)/100h          ;\len, BIG-ENDIAN
 db (@@end-@@begin-6-10h) and 0ffh      ;/
 db 0AAh,0AAh,03h,0,0,0                 ;\LLC/SNAP header
 dw PROTOCOL_ETHER_EAPOL                ;/
;- - -EAPOL...
 db 01h,03h                             ;-EAPOL ?
 db (@@end-@@begin-6-1ch)/100h          ;\EAPOL len, BIG-ENDIAN
 db (@@end-@@begin-6-1ch) and 0ffh      ;/
 db WPA2_DESCRIPTOR_TYPE                ;-EAPOL Descriptor Type (02)
 db WPA2_KEYINFO_HANDSHAKE2/100h        ;\EAPOL Key Information (01 0A)    ;SHA1/AES, Pairwise, MIC
 db WPA2_KEYINFO_HANDSHAKE2 and 0ffh    ;/
 db 0,0                                 ;    Key Length         (00 00)
 defs 8    ;MOD                         ;    Key Replay Counter (00 00 00 00 00 00 00 01)
 defs 32   ;MOD                         ;    Key Nonce          (A8 DC C3 00 67 00 55 8F 49 F7 07 F4 00 01 10 01 60 16 15 00 00 00 00 00 7F 06 9C 6C FF 2F 61 22)
 defs 16                                ;    EAPOL Key IV       (00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00)
 defs 8                                 ;    Key RSC            (00 00 00 00 00 00 00 00)
 defs 8                                 ;    Reserved           (00 00 00 00 00 00 00 00)
 defs 16   ;MOD                         ;    Key MIC            (B9 FA 85 43 28 AC 29 67 36 A8 1E 44 6E 69 08 E9)
 db (@@end-@@begin-6-1ch-5fh)/100h      ;\EAPOL Key Data Length, BIG-ENDIAN (00 16)
 db (@@end-@@begin-6-1ch-5fh) and 0ffh  ;/
;- - -Key Data...
 db 30h                       ;63h+00h   ;1  Element ID.RSNIE    (30h)
 db (@@end-@@begin-6-1ch-61h) ;63h+01h   ;1  Element Len         (14h)
 db 01h,00h                   ;63h+02h   ;2  RSNIE Version       (0001h)
 db 00h,0fh,0ach,04h   ;MOD   ;63h+04h   ;4  RSNIE OUI.grp.key   (00 0F AC 04)
 db 01h,00h                   ;63h+08h   ;2  RSNIE num.pair.keys (0001h)
 db 00h,0fh,0ach,04h   ;MOD   ;63h+0Ah   ;4  RSNIE OUI.pair.key  (00 0F AC 04)
 db 01h,00h                   ;63h+0Eh   ;2  RSNIE num.auths     (0001h)
 db 00h,0fh,0ach,02h          ;63h+10h   ;4  RSNIE OUI.auth      (00 0F AC 02)
 db 00h,00h                   ;63h+14h   ;2  RSNIE ?             (00 00)
@@end:
.align 4
;------------------
ath_wpa2_handshake4_data:
@@begin:
 db 02h,01h // dw @@end-@@begin-6, 0000h,  1c00h
 defs 6    ;MOD     ;BSSID
 defs 6    ;MOD     ;MAC
 db (@@end-@@begin-6-10h)/100h          ;\len, BIG-ENDIAN
 db (@@end-@@begin-6-10h) and 0ffh      ;/
 db 0AAh,0AAh,03h,0,0,0                 ;\LLC/SNAP header
 dw PROTOCOL_ETHER_EAPOL                ;/
;- - -EAPOL...
 db 01h,03h                             ;-EAPOL ?
 db (@@end-@@begin-6-1ch)/100h          ;\EAPOL len, BIG-ENDIAN
 db (@@end-@@begin-6-1ch) and 0ffh      ;/
 db WPA2_DESCRIPTOR_TYPE                ;-EAPOL Descriptor Type (02)
 db WPA2_KEYINFO_HANDSHAKE4/100h        ;\EAPOL Key Information (03 0A)    ;SHA1/AES, Pairwise, MIC, Secure
 db WPA2_KEYINFO_HANDSHAKE4 and 0ffh    ;/
 db 0,0                                 ;    Key Length         (00 00)
 defs 8    ;MOD                         ;    Key Replay Counter (00 00 00 00 00 00 00 01)
 defs 32                                ;    Key Nonce          (A8 DC C3 00 67 00 55 8F 49 F7 07 F4 00 01 10 01 60 16 15 00 00 00 00 00 7F 06 9C 6C FF 2F 61 22)
 defs 16                                ;    EAPOL Key IV       (00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00)
 defs 8                                 ;    Key RSC            (00 00 00 00 00 00 00 00)
 defs 8                                 ;    Reserved           (00 00 00 00 00 00 00 00)
 defs 16   ;MOD                         ;    Key MIC            (B9 FA 85 43 28 AC 29 67 36 A8 1E 44 6E 69 08 E9)
 db (@@end-@@begin-6-1ch-5fh)/100h      ;\EAPOL Key Data Length, BIG-ENDIAN (00 00)
 db (@@end-@@begin-6-1ch-5fh) and 0ffh  ;/
@@end:
.align 4
;------------------
ath_wpa2_handshake6_data:
@@begin:
 db 02h,01h // dw @@end-@@begin-6, 0101h,  1c00h
 defs 6    ;MOD     ;BSSID
 defs 6    ;MOD     ;MAC
 db (@@end-@@begin-6-10h)/100h          ;\len, BIG-ENDIAN
 db (@@end-@@begin-6-10h) and 0ffh      ;/
 db 0AAh,0AAh,03h,0,0,0                 ;\LLC/SNAP header
 dw PROTOCOL_ETHER_EAPOL                ;/
;- - -EAPOL...
 db 01h,03h                             ;-EAPOL ?
 db (@@end-@@begin-6-1ch)/100h          ;\EAPOL len, BIG-ENDIAN
 db (@@end-@@begin-6-1ch) and 0ffh      ;/
 db WPA2_DESCRIPTOR_TYPE                ;-EAPOL Descriptor Type (02)
 db WPA2_KEYINFO_HANDSHAKE6/100h        ;\EAPOL Key Information (01 0A)    ;SHA1/AES, Pairwise, MIC
 db WPA2_KEYINFO_HANDSHAKE6 and 0ffh    ;/
 db 0,0                                 ;    Key Length         (00 00)
 defs 8    ;MOD                         ;    Key Replay Counter (00 00 00 00 00 00 00 nn)  ;nn=03 and up
 defs 32                                ;    Key Nonce          (00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00)
 defs 16                                ;    EAPOL Key IV       (00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00)
 defs 8                                 ;    Key RSC            (00 00 00 00 00 00 00 00)
 defs 8                                 ;    Reserved           (00 00 00 00 00 00 00 00)
 defs 16   ;MOD                         ;    Key MIC            (B9 FA 85 43 28 AC 29 67 36 A8 1E 44 6E 69 08 E9)
 db (@@end-@@begin-6-1ch-5fh)/100h      ;\EAPOL Key Data Length, BIG-ENDIAN (00 16)
 db (@@end-@@begin-6-1ch-5fh) and 0ffh  ;/
@@end:
.align 4
;------------------
ath_wpa_handshake2_data:
@@begin:
 db 02h,01h // dw @@end-@@begin-6, 0000h,  1c00h
 defs 6    ;MOD     ;BSSID
 defs 6    ;MOD     ;MAC
 db (@@end-@@begin-6-10h)/100h          ;\len, BIG-ENDIAN
 db (@@end-@@begin-6-10h) and 0ffh      ;/
 db 0AAh,0AAh,03h,0,0,0                 ;\LLC/SNAP header
 dw PROTOCOL_ETHER_EAPOL                ;/
;- - -EAPOL...
 db 01h,03h                             ;-EAPOL ?
 db (@@end-@@begin-6-1ch)/100h          ;\EAPOL len, BIG-ENDIAN
 db (@@end-@@begin-6-1ch) and 0ffh      ;/
 db WPA_DESCRIPTOR_TYPE                 ;-EAPOL Descriptor Type (FE)
 db WPA_KEYINFO_HANDSHAKE2/100h         ;\EAPOL Key Information (01 09)    ;MD5/RC4, Pairwise, MIC
 db WPA_KEYINFO_HANDSHAKE2 and 0ffh     ;/
 db 0,20h                               ;    Key Length         (00 20)    ;unlike 00 00 in WPA2
 defs 8    ;MOD                         ;    Key Replay Counter (00 00 00 00 00 00 00 01)
 defs 32   ;MOD                         ;    Key Nonce          (A8 DC C3 00 67 00 55 8F 49 F7 07 F4 00 01 10 01 60 16 15 00 00 00 00 00 7F 06 9C 6C FF 2F 61 22)
 defs 16                                ;    EAPOL Key IV       (00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00)
 defs 8                                 ;    Key RSC            (00 00 00 00 00 00 00 00)
 defs 8                                 ;    Reserved           (00 00 00 00 00 00 00 00)
 defs 16   ;MOD                         ;    Key MIC            (B9 FA 85 43 28 AC 29 67 36 A8 1E 44 6E 69 08 E9)
 db (@@end-@@begin-6-1ch-5fh)/100h      ;\EAPOL Key Data Length, BIG-ENDIAN (00 18)
 db (@@end-@@begin-6-1ch-5fh) and 0ffh  ;/
;- - -Key Data...
 db 0ddh                        ;63h+00h    ;1  Element ID.vendor   (DD)
 db (@@end-@@begin-6-1ch-61h)   ;63h+01h    ;1  Element Len         (16)
 db 000h,050h,0F2h,001h         ;63h+02h    ;4  Element OUI.RSNIE   (00 50 F2 01)
 db 001h,000h                   ;63h+06h    ;2  RSNIE version       (01 00)
 db 000h,050h,0F2h,002h  ;MOD   ;63h+08h    ;4  RSNIE OUI.grp.key   (00 50 F2 02)
 db 001h,000h                   ;63h+0Ch    ;2  RSNIE num.pair.keys (01 00)
 db 000h,050h,0F2h,002h  ;MOD   ;63h+0Eh    ;4  RSNIE OUI.pair.key  (00 50 F2 02)
 db 001h,000h                   ;63h+12h    ;2  RSNIE num.auths     (01 00)
 db 000h,050h,0F2h,002h         ;63h+14h    ;4  RSNIE OUI.auth      (00 50 F2 02)
@@end:
.align 4
;------------------
ath_wpa_handshake4_data:
@@begin:
 db 02h,00h // dw @@end-@@begin-6, 0000h,  1c00h    ;<-- byte[1] MUST be 00h for WPA step 4 (don't request data.ack!!!) (maybe must be so because GTK isn't set yet)
 defs 6    ;MOD     ;BSSID
 defs 6    ;MOD     ;MAC
 db (@@end-@@begin-6-10h)/100h          ;\len, BIG-ENDIAN
 db (@@end-@@begin-6-10h) and 0ffh      ;/
 db 0AAh,0AAh,03h,0,0,0                 ;\LLC/SNAP header
 dw PROTOCOL_ETHER_EAPOL                ;/
;- - -EAPOL...
 db 01h,03h                             ;-EAPOL ?
 db (@@end-@@begin-6-1ch)/100h          ;\EAPOL len, BIG-ENDIAN
 db (@@end-@@begin-6-1ch) and 0ffh      ;/
 db WPA_DESCRIPTOR_TYPE                 ;-EAPOL Descriptor Type (FE)
 db WPA_KEYINFO_HANDSHAKE4/100h         ;\EAPOL Key Information (01 09)    ;MD5/RC4, Pairwise, MIC
 db WPA_KEYINFO_HANDSHAKE4 and 0ffh     ;/
 db 0,20h                               ;    Key Length         (00 20)    ;unlike 00 00 in WPA2
 defs 8    ;MOD                         ;    Key Replay Counter (00 00 00 00 00 00 00 02)
 defs 32                                ;    Key Nonce          (00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00)
 defs 16                                ;    EAPOL Key IV       (00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00)
 defs 8                                 ;    Key RSC            (00 00 00 00 00 00 00 00)
 defs 8                                 ;    Reserved           (00 00 00 00 00 00 00 00)
 defs 16   ;MOD                         ;    Key MIC            (B9 FA 85 43 28 AC 29 67 36 A8 1E 44 6E 69 08 E9)
 db (@@end-@@begin-6-1ch-5fh)/100h      ;\EAPOL Key Data Length, BIG-ENDIAN (00 00)
 db (@@end-@@begin-6-1ch-5fh) and 0ffh  ;/
@@end:
.align 4
;------------------
ath_wpa_handshake6_data:
@@begin:
 db 02h,01h // dw @@end-@@begin-6, 0000h,  1c00h
 defs 6    ;MOD     ;BSSID
 defs 6    ;MOD     ;MAC
 db (@@end-@@begin-6-10h)/100h          ;\len, BIG-ENDIAN
 db (@@end-@@begin-6-10h) and 0ffh      ;/
 db 0AAh,0AAh,03h,0,0,0                 ;\LLC/SNAP header
 dw PROTOCOL_ETHER_EAPOL                ;/
;- - -EAPOL...
 db 01h,03h                             ;-EAPOL ?
 db (@@end-@@begin-6-1ch)/100h          ;\EAPOL len, BIG-ENDIAN
 db (@@end-@@begin-6-1ch) and 0ffh      ;/
 db WPA_DESCRIPTOR_TYPE                 ;-EAPOL Descriptor Type (FE)
 db WPA_KEYINFO_HANDSHAKE6/100h         ;\EAPOL Key Information (03 21)    ;MD5/RC4, Group, Reserved?, MIC, Secure
 db WPA_KEYINFO_HANDSHAKE6 and 0ffh ;MOD;/
 db 0,20h                               ;    Key Length         (00 20)    ;unlike 00 00 in WPA2
 defs 8    ;MOD                         ;    Key Replay Counter (00 00 00 00 00 00 00 03)
 defs 32                                ;    Key Nonce          (00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00)
 defs 16                                ;    EAPOL Key IV       (00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00)
 defs 8                                 ;    Key RSC            (00 00 00 00 00 00 00 00)
 defs 8                                 ;    Reserved           (00 00 00 00 00 00 00 00)
 defs 16   ;MOD                         ;    Key MIC            (B9 FA 85 43 28 AC 29 67 36 A8 1E 44 6E 69 08 E9)
 db (@@end-@@begin-6-1ch-5fh)/100h      ;\EAPOL Key Data Length, BIG-ENDIAN (00 00)
 db (@@end-@@begin-6-1ch-5fh) and 0ffh  ;/
@@end:
.align 4
;------------------
ath_set_power_mode_cmd:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_SET_POWER_MODE_CMD
 db 02h         ;powerMode (01h=REC_POWER, 02h=MAX_PERF_POWER)
@@end:
.align 4
;------------------
ath_create_pstream_cmd_1st:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_CREATE_PSTREAM_CMD
 dd 14h         ;00h A_UINT32 4  minServiceInt      ;in msec (14h=20)
 dd 14h         ;04h A_UINT32 4  maxServiceInt      ;in msec (14h=20)
 dd 98967Fh     ;08h A_UINT32 4  inactivityInt      ;in msec (98967Fh=9999999)
 dd 0FFFFFFFFh  ;0Ch A_UINT32 4  suspensionInt      ;in msec (-1)
 dd 0           ;10h A_UINT32 4  serviceStartTime            (0)
 dd 14500h      ;14h A_UINT32 4  minDataRate        ;in bps  (14500h=83200)
 dd 14500h      ;18h A_UINT32 4  meanDataRate       ;in bps  (14500h=83200)
 dd 14500h      ;1Ch A_UINT32 4  peakDataRate       ;in bps  (14500h=83200)
 dd 0           ;20h A_UINT32 4  maxBurstSize                (0)
 dd 0           ;24h A_UINT32 4  delayBound                  (0)
 dd 5B8D80h     ;28h A_UINT32 4  minPhyRate         ;in bps  (5B8D80h=6000000)
 dd 2000h       ;2Ch A_UINT32 4  sba                         (2000h=8192)
 dd 0           ;30h A_UINT32 4  mediumTime                  (0)
 dw 80D0h       ;34h A_UINT16 2  nominalMSDU        ;in octects   ;uh, octeCts?
 dw 0D0h        ;36h A_UINT16 2  maxMSDU            ;in octects   ;uh, octeCts?
 db 00h         ;38h A_UINT8  1  trafficClass
 db 02h         ;39h A_UINT8  1  trafficDirection   ;DIR_TYPE (0=Uplink, 1=Downlink, 2=Bidir)
 db 0FFh        ;3Ah A_UINT8  1  rxQueueNum
 db 01h         ;3Bh A_UINT8  1  trafficType        ;TRAFFIC_TYPE (0=Aperiodic, 1=Periodic)
 db 00h         ;3Ch A_UINT8  1  voicePSCapability  ;VOICEPS_CAP_TYPE (0=Disable_for_this_ac, 1=Enable_for_this_ac, 2=Enable_for_all_ac)
 db 05h         ;3Dh A_UINT8  1  tsid
 db 00h         ;3Eh A_UINT8  1  userPriority       ;802.1D user priority
@@end:
.align 4
;------------------
ath_create_pstream_cmd_2nd:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_CREATE_PSTREAM_CMD
 dd 0           ;00h A_UINT32 4  minServiceInt      ;in msec (0)
 dd 0           ;04h A_UINT32 4  maxServiceInt      ;in msec (0)
 dd 1388h       ;08h A_UINT32 4  inactivityInt      ;in msec (1388h = 5000)
 dd 0           ;0Ch A_UINT32 4  suspensionInt      ;in msec (0)
 dd 0           ;10h A_UINT32 4  serviceStartTime            (0)
 dd 0           ;14h A_UINT32 4  minDataRate        ;in bps  (0)
 dd 0           ;18h A_UINT32 4  meanDataRate       ;in bps  (0)
 dd 0           ;1Ch A_UINT32 4  peakDataRate       ;in bps  (0)
 dd 0           ;20h A_UINT32 4  maxBurstSize                (0)
 dd 0           ;24h A_UINT32 4  delayBound                  (0)
 dd 0           ;28h A_UINT32 4  minPhyRate         ;in bps  (0)
 dd 0           ;2Ch A_UINT32 4  sba                         (0)
 dd 0           ;30h A_UINT32 4  mediumTime                  (0)
 dw 0           ;34h A_UINT16 2  nominalMSDU        ;in octects   ;uh, octeCts?
 dw 0           ;36h A_UINT16 2  maxMSDU            ;in octects   ;uh, octeCts?
 db 01h         ;38h A_UINT8  1  trafficClass
 db 00h ;up?    ;39h A_UINT8  1  trafficDirection   ;DIR_TYPE (0=Uplink, 1=Downlink, 2=Bidir)
 db 00h         ;3Ah A_UINT8  1  rxQueueNum
 db 00h         ;3Bh A_UINT8  1  trafficType        ;TRAFFIC_TYPE (0=Aperiodic, 1=Periodic)
 db 00h         ;3Ch A_UINT8  1  voicePSCapability  ;VOICEPS_CAP_TYPE (0=Disable_for_this_ac, 1=Enable_for_this_ac, 2=Enable_for_all_ac)
 db 0ffh        ;3Dh A_UINT8  1  tsid
 db 01h         ;3Eh A_UINT8  1  userPriority       ;802.1D user priority
@@end:
.align 4
;------------------
ath_create_pstream_cmd_3rd_4th:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 2008h // dw WMI_CREATE_PSTREAM_CMD   ;<-- 2008h
 dd 0           ;00h A_UINT32 4  minServiceInt      ;in msec (0)
 dd 0           ;04h A_UINT32 4  maxServiceInt      ;in msec (0)
 dd 1388h       ;08h A_UINT32 4  inactivityInt      ;in msec (1388h = 5000)
 dd 0           ;0Ch A_UINT32 4  suspensionInt      ;in msec (0)
 dd 0           ;10h A_UINT32 4  serviceStartTime            (0)
 dd 0           ;14h A_UINT32 4  minDataRate        ;in bps  (0)
 dd 0           ;18h A_UINT32 4  meanDataRate       ;in bps  (0)
 dd 0           ;1Ch A_UINT32 4  peakDataRate       ;in bps  (0)
 dd 0           ;20h A_UINT32 4  maxBurstSize                (0)
 dd 0           ;24h A_UINT32 4  delayBound                  (0)
 dd 0           ;28h A_UINT32 4  minPhyRate         ;in bps  (0)
 dd 0           ;2Ch A_UINT32 4  sba                         (0)
 dd 0           ;30h A_UINT32 4  mediumTime                  (0)
 dw 0           ;34h A_UINT16 2  nominalMSDU        ;in octects   ;uh, octeCts?
 dw 0           ;36h A_UINT16 2  maxMSDU            ;in octects   ;uh, octeCts?
 db 03h         ;38h A_UINT8  1  trafficClass
 db 00h ;up?    ;39h A_UINT8  1  trafficDirection   ;DIR_TYPE (0=Uplink, 1=Downlink, 2=Bidir)
 db 00h         ;3Ah A_UINT8  1  rxQueueNum
 db 00h         ;3Bh A_UINT8  1  trafficType        ;TRAFFIC_TYPE (0=Aperiodic, 1=Periodic)
 db 00h         ;3Ch A_UINT8  1  voicePSCapability  ;VOICEPS_CAP_TYPE (0=Disable_for_this_ac, 1=Enable_for_this_ac, 2=Enable_for_all_ac)
 db 0ffh        ;3Dh A_UINT8  1  tsid
 db 06h         ;3Eh A_UINT8  1  userPriority       ;802.1D user priority
@@end:
.align 4

;wifi-v2.txt:
;1st: Write Func[1:00F80] = Len:0001x0080 01 01 41 00 00 00 05 00 14 00 00 00 14 00 00 00 7F 96 98 00 FF FF FF FF 00 00 00 00 00 45 01 00 00 45 01 00 00 45 01 00 00 00 00 00 00 00 00 00 80 8D 5B 00 00 20 00 00 00 00 00 00 D0 80 D0 00 00 02 FF 01 00 05 00   ;WMI_CREATE_PSTREAM_CMD
;2nd: Write Func[1:00F80] = Len:0001x0080 01 01 41 00 00 00 05 00 00 00 00 00 00 00 00 00 88 13 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 00 FF 01   ;WMI_CREATE_PSTREAM_CMD
;3rd: Write Func[1:00F80] = Len:0001x0080 01 01 41 00 08 20 05 00 00 00 00 00 00 00 00 00 88 13 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 03 00 00 00 00 FF 06   ;WMI_CREATE_PSTREAM_CMD
;4th: Write Func[1:00F80] = Len:0001x0080 01 01 41 00 08 20 05 00 00 00 00 00 00 00 00 00 88 13 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 03 00 00 00 00 FF 06   ;WMI_CREATE_PSTREAM_CMD


;------------------
ath_set_wsc_status_cmd:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_SET_WSC_STATUS_CMD
 db 00h         ;undocumented (maybe meant to be 00h=WSC_REG_INACTIVE?)
@@end:
.align 4
;------------------
ath_set_disconnect_timeout_cmd:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_SET_DISCONNECT_TIMEOUT_CMD
 db 02h         ;disconnectTimeout (in seconds)
@@end:
.align 4
;------------------
ath_add_cipher_key_cmd:         ;4x
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_ADD_CIPHER_KEY_CMD
 db 00h      ;MOD ;00h  A_UINT8  1   keyIndex ;aka WMI_MAX_KEY_INDEX (0..3)
 db 02h      ;MOD ;01h  A_UINT8  1   keyType  ;maybe same as CryptoType aka CRYPTO_TYPE?
 db 03h      ;MOD ;02h  A_UINT8  1   keyUsage      ;KEY_USAGE (0=Pairwise, 1=Group, 2=TX/default Tx Key - Static WEP only)
 db 0Dh      ;MOD ;03h  A_UINT8  1   keyLength
 defs 8      ;MOD ;04h  A_UINT8  8   keyRSC[8]     ;key replay sequence counter
 defs 20h    ;MOD ;0Ch  A_UINT8  32  key[WMI_MAX_KEY_LEN]    ;aka password
 db 03h           ;2Ch  A_UINT8  1   key_op_ctrl   ;Additional Key Control information
   ;Bit Flag. (aka key_op_ctrl values?):
   ;  Bit 0 - Initialise TSC - default is Initialize
   ;  KEY_OP_INIT_TSC     = 01h
   ;  KEY_OP_INIT_RSC     = 02h
   ;  KEY_OP_INIT_WAPIPN  = 10h (only if "WAPI_ENABLE")
   ;  KEY_OP_INIT_VAL     = 03h     /* Default Initialise the TSC & RSC
   ;  KEY_OP_VALID_MASK   = 03h
   ;WEP: (key0,1,2,3)
   ;00 02 03 0D 00 00 00 00 00 00 00 00 64 73 6C 69 6E 6B 2D 64 73 6C 69 6E 6B 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 03   ;WMI_ADD_CIPHER_KEY_CMD
   ;01 02 01 0D 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 03   ;WMI_ADD_CIPHER_KEY_CMD
   ;02 02 01 0D 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 03   ;WMI_ADD_CIPHER_KEY_CMD
   ;03 02 01 0D 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 03   ;WMI_ADD_CIPHER_KEY_CMD
   ;WPA: (key 0,2) (aka TK,GTK)
   ;00 03 00 20 00 00 00 00 00 00 00 00 07 A2 68 3A DF B2 B5 29 2F 82 70 8E 0F C0 CB 0E 9B 5F AE 0F 0F EB 79 18 F2 BC 3A FA EA 12 FB 3C 03
   ;02 03 01 20 00 00 00 00 00 00 00 00 44 9B 5A DC 41 27 79 2E ED 65 AA 1F D3 65 36 2F 02 A4 1B DD B8 2B 2F 39 84 D0 69 6F 46 E4 55 53 03
   ;WPA2: (key 0,2) (aka TK,GTK)
   ;00 04 00 10 00 00 00 00 00 00 00 00 AB 8B 2D A2 FF C7 4F CE C5 6F CB 0A 04 BC F6 50 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 03
   ;02 04 01 10 00 00 00 00 00 00 00 00 F7 16 72 65 AF 45 DA 93 08 7D 11 7F 6D 3B 1B AF 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 03
@@end:
.align 4
;------------------
ath_del_cipher_key_cmd:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_DELETE_CIPHER_KEY_CMD
 db 03h      ;MOD ;00h  A_UINT8  1   keyIndex ;aka WMI_MAX_KEY_INDEX (0..3)
@@end:
.align 4
;------------------
ath_set_keepalive_cmd:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_SET_KEEPALIVE_CMD
 db 00h         ;keepaliveInterval
@@end:
.align 4
;------------------
ath_connect_cmd:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_CONNECT_CMD
 db 01h           ;00h  A_UINT8  1   networkType          ;somewhat NETWORK_TYPE related ?
 db 02h   ;keyMOD ;01h  A_UINT8  1   dot11AuthMode        ;aka DOT11_AUTH_MODE ?
 db 01h   ;keyMOD ;02h  A_UINT8  1   authMode             ;aka AUTH_MODE ?
 db 02h   ;keyMOD ;03h  A_UINT8  1   pairwiseCryptoType   ;aka CRYPTO_TYPE maybe ?
 db 00h           ;04h  A_UINT8  1   pairwiseCryptoLen
 db 02h   ;keyMOD ;05h  A_UINT8  1   groupCryptoType      ;aka CRYPTO_TYPE too maybe ?
 db 00h           ;06h  A_UINT8  1   groupCryptoLen
 db 03h      ;MOD ;07h  A_UINT8  1   ssidLength               (len "ead")
 defs 20h    ;MOD ;08h  A_UCHAR  32  ssid[WMI_MAX_SSID_LEN]   (name "ead")
 dw 096Ch    ;MOD ;28h  A_UINT16 2   channel              ;in MHz or so ?
 defs 6      ;MOD ;2Ah  A_UINT8  6   bssid[ATH_MAC_LEN]
 dd 00000000h     ;30h  A_UINT32 4   ctrl_flags
@@end:
.align 4

.comment
   Open:
   set no CIPHER's
   Write Func[1:00F80] = Len:0001x0080 01 01 36 00 00 00 01 00   01 01 01 01 00 01 00 03 65 61 64 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 9E 09 aa aa aa aa aa aa 00 00 00 00   ;WMI_CONNECT_CMD for "ead"

   WEP:
   set 4x CIPHER's
   Write Func[1:00F80] = Len:0001x0080 01 01 36 00 00 00 01 00   01 02 01 02 00 02 00 03 65 61 64 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 85 09 aa aa aa aa aa aa 00 00 00 00   ;WMI_CONNECT_CMD    ;"ead"
                                                                    xx    xx    xx                                                                                                       ch ch
   WPA:
                                       01 01 36 00 00 00 01 00   01 01 03 03 00 03 00 03 65 61 64 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 9E 09 aa aa aa aa aa aa 00 00 00 00   ;connect to "ead"
   WPA2:                                                            xx !! xx    xx
                                       01 01 36 00 00 00 01 00   01 01 05 04 00 04 00 03 65 61 64 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 9E 09 aa aa aa aa aa aa 00 00 00 00   ;for "ead"
.comment



.comment
     NETWORK_TYPE values:
       INFRA_NETWORK       = 01h
       ADHOC_NETWORK       = 02h
       ADHOC_CREATOR       = 04h
       AP_NETWORK          = 10h
     NETWORK_SUBTYPE values (unknown purpose, and unknown if they start at 0 or 1
     or so):
       SUBTYPE_NONE        = unknown (maybe 0 or 1 or so?)
       SUBTYPE_BT          = SUBTYPE_NONE+1
       SUBTYPE_P2PDEV      = SUBTYPE_NONE+2
       SUBTYPE_P2PCLIENT   = SUBTYPE_NONE+3
       SUBTYPE_P2PGO       = SUBTYPE_NONE+4
     DOT11_AUTH_MODE values:
       OPEN_AUTH           = 01h
       SHARED_AUTH         = 02h
       LEAP_AUTH           = 04h  /* different from IEEE_AUTH_MODE definitions
     AUTH_MODE values:
       WMI_NONE_AUTH       = 01h
       WMI_WPA_AUTH        = 02h
       WMI_WPA2_AUTH       = 04h
       WMI_WPA_PSK_AUTH    = 08h
       WMI_WPA2_PSK_AUTH   = 10h
       WMI_WPA_AUTH_CCKM   = 20h
       WMI_WPA2_AUTH_CCKM  = 40h
     CRYPTO_TYPE values:
       NONE_CRYPT          = 01h
       WEP_CRYPT           = 02h
       TKIP_CRYPT          = 04h
       AES_CRYPT           = 08h
       WAPI_CRYPT          = 10h  ;only if WAPI_ENABLE
     connect "ctrl_flags":
       0   CONNECT_ASSOC_POLICY_USER           = 0001h
       1   CONNECT_SEND_REASSOC                = 0002h
       2   CONNECT_IGNORE_WPAx_GROUP_CIPHER    = 0004h
       3   CONNECT_PROFILE_MATCH_DONE          = 0008h
       4   CONNECT_IGNORE_AAC_BEACON           = 0010h
       5   CONNECT_CSA_FOLLOW_BSS              = 0020h
       6   CONNECT_PYXIS_REMOTE                = 0040h  ;-old code from 2008
       6   CONNECT_DO_WPA_OFFLOAD              = 0040h  ;\
       7   CONNECT_DO_NOT_DEAUTH               = 0080h  ; new code from 2010
       8   CONNECT_WPS_FLAG                    = 0100h  ;
       9   CONNECT_IGNORE_BSSID_HINT           = 0200h  ;
       16  AP_NO_DISASSOC_UPON_DEAUTH          = 10000h ;/ <--AP configuration flags
     DEFAULT_CONNECT_CTRL_FLAGS = (CONNECT_CSA_FOLLOW_BSS)
.comment


;------------------
ath_disconnect_cmd:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_DISCONNECT_CMD
@@end:
.align 4
;------------------
dsi7_sdio_heartbeat:
 ldr  r0,=vblank_count                  ;\
 ldr  r0,[r0]                           ;
 ldr  r1,=recent_heartbeat              ;
 ldr  r2,[r1]                           ; exit if time hasn't ellapsed yet
 sub  r2,r0,r2                          ;
 cmp  r2,60     ;60 frames (1 second)   ;
 bxlo lr                                ;/
 ldr  r2,=ath_cmd_ack_pending           ;\
 ldrb r2,[r2]                           ; exit if old CMD is still busy
 cmp  r2,0                              ;
 bxne lr                                ;/
 str  r0,[r1] ;[recent_heartbeat]=count ;-apply new time
 ldr  r0,=ath_heartbeat_cmd             ;\
 ldr  r1,[r0,8+04h]  ;cookie  ;\raise   ;
 add  r1,1                    ; cookie  ; send heartbeat cmd
 str  r1,[r0,8+04h]  ;cookie  ;/        ;
 b    sdio_send_wmi_cmd_without_poll    ;/
;------------------
 WPA_DESCRIPTOR_TYPE     equ 0feh
 WPA_KEYINFO_HANDSHAKE1  equ 0089h
 WPA_KEYINFO_HANDSHAKE2  equ 0109h
 WPA_KEYINFO_HANDSHAKE3  equ 01C9h
 WPA_KEYINFO_HANDSHAKE4  equ 0109h ;same as handshake2
 WPA_KEYINFO_HANDSHAKE5  equ 03A1h   ;0391h --> maybe keyindex=1?
 WPA_KEYINFO_HANDSHAKE6  equ 0321h   ;;-10h --> "" ?
 WPA2_DESCRIPTOR_TYPE    equ 02h
 WPA2_KEYINFO_HANDSHAKE1 equ 008Ah
 WPA2_KEYINFO_HANDSHAKE2 equ 010Ah
 WPA2_KEYINFO_HANDSHAKE3 equ 13CAh
 WPA2_KEYINFO_HANDSHAKE4 equ 030Ah
 WPA2_KEYINFO_HANDSHAKE5 equ 1382h  ;o2acc2 throws this after some minutes/hours (key expired? short 24-hourly offline period?)
 WPA2_KEYINFO_HANDSHAKE6 equ 0302h  ;reply to above
;note: weirdly, fritzbox is occassionally sending 1382h even in WEP mode!
   ;WPA-AES
   ;008A shake1
   ;01CA shake3
   ;0392 shake5
;------------------
dsi7_Wifi_Intr_RxEapolEnd:
 push r4-r12,lr
 ldr  r4,=sdio_xfer_buf                 ;-
   ;XXX verify SA=BSSI
   ;XXX verify DA=MAC (none else, and not broadcast)
   ;XXX verify LEN
   ;XXX verify LLC header
 ldr  r3,=WifiData_eapol7
 ldrb r3,[r3]  ;EAPOL_TYPE_xxx
 ldrb r2,[r4,16h+8+4] ;Descriptor Type
 ldrb r1,[r4,16h+8+5] ;Key Information MSB
 ldrb r0,[r4,16h+8+6] ;Key Information LSB
 orr  r0,r0,r1,lsl 8
 cmp  r2,WPA_DESCRIPTOR_TYPE            ;\
 beq  @@wpa                             ;/
 cmp  r2,WPA2_DESCRIPTOR_TYPE           ;\
 beq  @@wpa2                            ;/
 b    @@bad
;---
@@wpa:
 cmp  r3,EAPOL_TYPE_WPA                 ;\reject if not WPA
 bne  @@bad                             ;/

bic r0,7   ;for WifiData_handshake_crypt

 cmp  r0,WPA_KEYINFO_HANDSHAKE1    -1     ;\
 beq  @@wpa_handshake1                  ;/
 ldr  r1,=WPA_KEYINFO_HANDSHAKE3   -1     ;\
 cmp  r0,r1                             ;
 beq  @@wpa_handshake3                  ;/
 ldr  r1,=WPA_KEYINFO_HANDSHAKE5   -1     ;\
 cmp  r0,r1                             ;
        ;;;old;;;MOVEQ r0,2
 beq  @@wpa_handshake5                  ;/

 ldr  r1,=WPA_KEYINFO_HANDSHAKE5-10h  -1  ;\
 cmp  r0,r1                             ;
        ;;;old;;;MOVEQ r0,1
 beq  @@wpa_handshake5                  ;/
       ;beq  @@xxx
 b    @@bad
;---
@@wpa2:
 cmp  r3,EAPOL_TYPE_WPA2                ;\reject if not WPA2
 bne  @@bad                             ;/

bic r0,7   ;for WifiData_handshake_crypt

 cmp  r0,WPA2_KEYINFO_HANDSHAKE1   -2   ;\
 beq  @@wpa2_handshake1                 ;/
 ldr  r1,=WPA2_KEYINFO_HANDSHAKE3  -2   ;\
 cmp  r0,r1                             ;
 beq  @@wpa2_handshake3                 ;/
 ldr  r1,=WPA2_KEYINFO_HANDSHAKE5  -2   ;\o2acc2 throws this after some minutes/hours (key expired? short 24-hourly offline period?)
 cmp  r0,r1                             ;
 beq  @@wpa2_handshake5                 ;/
 b    @@bad
;---
@@bad:
@@unexpected_handshake:
        bl wrhex16bit // bl wrspc
        mov r0,'#' // bl wrchr_r0
        mov r0,'?' // bl wrchr_r0
 ldr  r1,=WifiData_expected_handshake   ;\
 mov  r0,0      ;quit, expect none      ;
 strb r0,[r1]                           ;/
@@done:
 pop  r4-r12,pc
;--- --- ---
@@wpa_handshake1:
@@wpa2_handshake1:
 ldr  r1,=WifiData_expected_handshake   ;\
 ldrb r0,[r1]                           ;
 cmp  r0,3                              ;
 beq  @@resend_handshake2               ;
 cmp  r0,1                              ;
 bne  @@unexpected_handshake            ;/
;- - -
 ldrb r0,[r4,16h+8+05h+1] ;key.info.lsb ;\
 and  r0,07h                            ;
 ldr  r1,=WifiData_handshake_crypt      ;
 strb r0,[r1]                           ;/

 add  r0,r4,16h+8+09h  ;Replay          ;\apply Replay Counter
 ldr  r1,=WifiData_replay7              ; (0000000000000001 on fritzbox)
 mov  r2,8                              ; (0000000000000000 on o2acc2)
 bl   memcopy_bytewise                  ;/
 add  r0,r4,16h+8+11h  ;Nonce           ;\
 ldr  r1,=WifiData_anonce7              ; apply ANonce
 mov  r2,20h                            ;
 bl   memcopy_bytewise                  ;/
 ldr  r0,=WifiData_snonce7              ;\
 mov  r1,20h  ;size                     ; create random SNonce
 bl   get_random_bytes                  ;/
 ldr  r6,=WifiData_MacAddr              ;\
 ldr  r7,=WifiData_bssid7               ;
 mov  r0,r6                             ;
 mov  r1,r7                             ; get MAC's and sort min,max
 mov  r2,6  ;len                        ;
 bl   memcompare_bytewise               ;
 movhi r0,r6  ;\                        ;
 movhi r6,r7  ; swap r6,r7              ;
 movhi r7,r0  ;/                        ;/
 ldr  r8,=WifiData_anonce7              ;\
 ldr  r9,=WifiData_snonce7              ;
 mov  r0,r8                             ;
 mov  r1,r9                             ; get Nonces's and sort min,max
 mov  r2,32 ;len                        ;
 bl   memcompare_bytewise               ;
 movhi r0,r8  ;\                        ;
 movhi r8,r9  ; swap r8,r9              ;
 movhi r9,r0  ;/                        ;/
;- - -
 sub  sp,100  ;=22+1+6+6+32+32+1  ;---> alloc nonces
 mov  r1,sp   ;nonces                   ;-dst for MAC's and Nonce's
 ldr  r0,=pairwise_prefix               ;\
 mov  r2,pairwise_prefixlen             ; append "Pairwise key expansion",00h
 bl   memcopy_bytewise                  ;/
 mov  r0,r6   ;mac.min                  ;\
 mov  r2,6                              ; append smaller mac
 bl   memcopy_bytewise                  ;/
 mov  r0,r7   ;mac.max                  ;\
 mov  r2,6                              ; append bigger mac
 bl   memcopy_bytewise                  ;/
 mov  r0,r8   ;nonce.min                ;\
 mov  r2,32                             ; append smaller nonce
 bl   memcopy_bytewise                  ;/
 mov  r0,r9   ;nonce.max                ;\
 mov  r2,32                             ; append bigger nonce
 bl   memcopy_bytewise                  ;/
 mov  r0,00h                            ;\append 00h (initial count value)
 strb r0,[r1],1                         ;/
 mov  r0,sp  ;nonces    ;\src=prefix+AA+SPA+ANonce+SNonce+00h   ;\
 mov  r1,100 ;nonceslen ;/                                      ;
 ldr  r2,=WifiData_psk7 ;\key=PSK (aka PMK)                     ;
 mov  r3,32  ;psklen    ;/                                      ; calc PTK
 ldr  r4,=WifiData_ptk7 ;\dst=PTK (PTK=64 bytes max)            ;
 mov  r5,64  ;ptklen    ;/                                      ;
 mov  r6,1              ;-numrounds=1                           ;
 bl   wifi_calc_prf     ;---> calc PTK                          ;/
 add  sp,100  ;=22+1+6+6+32+32+1  ;<--- dealloc nonces
;- - -
 ldr  r1,=WifiData_expected_handshake   ;\
 mov  r0,3                              ;
 strb r0,[r1]                           ;/
@@resend_handshake2:
 ldr  r3,=WifiData_eapol7     ;\                ;\
 ldrb r3,[r3]                 ;                 ;
 cmp  r3,EAPOL_TYPE_WPA       ;/                ;
 ldreq r0,=wpa_tx_callback_handshake2_list      ; send handshake2
 ldrne r0,=wpa2_tx_callback_handshake2_list     ;
 ldr  r1,=curr_wpa_tx_callback_list_ptr         ;
 str  r0,[r1]                                   ;/
;;;mov r0,'#' // bl wrchr_r0 // mov r0,'1' // bl wrchr_r0
 b    @@done
;--- --- ---
@@wpa_handshake3:
@@wpa2_handshake3:
 add  r0,r4,16h+8                       ;\
 bl   wpa2_verify_eapol_mic             ; verify EAPOL MIC (before decrypt)
 bne  @@bad_handshake3                  ;/
 add  r0,r4,16h+8+11h  ;Nonce           ;\
 ldr  r1,=WifiData_anonce7              ;
 mov  r2,20h                            ; want same ANonce
 bl   memcompare_bytewise               ;
 bne  @@bad_handshake3                  ;/
 ldr  r1,=WifiData_expected_handshake   ;\
 ldrb r0,[r1]                           ;
 cmp  r0,5                              ; expected handshake number
 beq  @@resend_handshake4               ;
 cmp  r0,3                              ;
 bne  @@unexpected_handshake            ;/
;- - -
 add  r0,r4,16h+8                       ;\
 bl   eapol_raise_and_verify_reply_count; replay count
 bne  @@unexpected_handshake            ;/
;- - -
 ldr  r3,=WifiData_eapol7    ;\         ;\
 ldrb r3,[r3]                ;          ; for WPA2 only (not WPA)
 cmp  r3,EAPOL_TYPE_WPA2     ;          ;
 bne  @@skip_wpa2_aes_stuff  ;/         ;
 add  r0,r4,16h+8+41h  ;RSC             ; ;\
 ldr  r1,=WifiData_rsc7                 ; ; WPA2 apply RSC for GTK
 mov  r2,8                              ; ;
 bl   memcopy_bytewise                  ; ;/
 add  r0,r4,16h+8      ;EAPOL           ; ;\
 bl   eapol_decrypt                     ; ; WPA2 decrypt GTK
 bne  @@bad_handshake3                  ; ;/
 add  r0,r4,16h+8      ;EAPOL           ; ;\
 bl   wpa2_apply_gtk                    ; ; WPA2 apply GTK
 bne  @@bad_handshake3                  ; ;/
@@skip_wpa2_aes_stuff:                  ;/
 ldr  r1,=WifiData_expected_handshake   ;\
 mov  r0,5                              ;
 strb r0,[r1]                           ;/
@@resend_handshake4:
 ldr  r3,=WifiData_eapol7                       ;\
 ldrb r3,[r3]                                   ;
 cmp  r3,EAPOL_TYPE_WPA                         ; send handshake4
 ldreq r0,=wpa_tx_callback_handshake4_list      ; (plus further cmd's)
 ldrne r0,=wpa2_tx_callback_handshake4_list     ;
 ldr  r1,=curr_wpa_tx_callback_list_ptr         ;
 str  r0,[r1]                                   ;/
;;;mov r0,'#' // bl wrchr_r0 // mov r0,'3' // bl wrchr_r0
 b    @@done
;---
@@bad_handshake3:
  mov r0,'B' // bl wrchr_r0
  mov r0,'A' // bl wrchr_r0
  mov r0,'D' // bl wrchr_r0
  mov r0,'#' // bl wrchr_r0
  mov r0,'3' // bl wrchr_r0
 b    @@done
;--- --- ---
@@wpa_handshake5:
@@wpa2_handshake5:
;;;old;;; ldr  r3,=WifiData_gtk_index7           ;\apply keyIndex for GTK (1..3)
;;;old;;; strb r0,[r3]                           ;/(from "Reserved" Key Info bits!)
;- - -
 ldr  r1,=WifiData_expected_handshake   ;\
 ldrb r0,[r1]                           ;
 cmp  r0,5                              ;
 bne  @@unexpected_handshake            ;/
;- - -
 add  r0,r4,16h+8                       ;\
 bl   wpa2_verify_eapol_mic             ; verify EAPOL MIC (before decrypt)
 bne  @@bad_handshake5                  ;/
        ;XXX if same reply_count --> resend (but ONLY if it was ALREADY sent)
 add  r0,r4,16h+8                       ;\
 bl   eapol_raise_and_verify_reply_count;      XXX or just apply replay7 as so
;;;123 bne  @@unexpected_handshake            ;/    ;<-- FAILs on DLINK+WPA-AES (but works on o2acc WPA-AES)


;add  r0,r4,16h+8+11h  ;Nonce           ;\
;ldr  r1,=WifiData_gnonce7              ; could memorize GNonce (which is probably/maybe stored in this field... but it's useless, not needed)
;mov  r2,20h                            ;
;bl   memcopy_bytewise                  ;/
;- - -
 add  r0,r4,16h+8+41h  ;RSC             ;\
 ldr  r1,=WifiData_rsc7                 ; apply RSC for GTK
 mov  r2,8                              ;
 bl   memcopy_bytewise                  ;/
 add  r0,r4,16h+8      ;EAPOL           ;\
 bl   eapol_decrypt                     ; decrypt GTK
 bne  @@bad_handshake5                  ;/
;- - -
 ldr  r3,=WifiData_eapol7                       ;\
 ldrb r3,[r3]                                   ;
 cmp  r3,EAPOL_TYPE_WPA                         ;
 beq  @@wpa_groupkey                            ;/
;- - -                    ;--WPA2--
 add  r0,r4,16h+8      ;EAPOL           ;\
 bl   wpa2_apply_gtk                    ; WPA2 apply GTK
 bne  @@bad_handshake5                  ;/
 b    @@finish_handshake5
;---
@@wpa_groupkey:      ;--WPA--
 add  r0,r4,16h+8      ;EAPOL           ;\
 bl   wpa_apply_gtk                     ; WPA apply GTK
 bne  @@bad_handshake5                  ;/
;- - -
@@finish_handshake5:
 ldr  r3,=WifiData_eapol7                       ;\
 ldrb r3,[r3]                                   ;
 cmp  r3,EAPOL_TYPE_WPA                         ; send handshake6
 ldreq r0,=wpa_tx_callback_handshake6_list      ; (plus further cmd's)
 ldrne r0,=wpa2_tx_callback_handshake6_list     ;
 ldr  r1,=curr_wpa_tx_callback_list_ptr         ;
 str  r0,[r1]                                   ;/
;;;mov r0,'#' // bl wrchr_r0 // mov r0,'5' // bl wrchr_r0
 b    @@done
;---
@@bad_handshake5:
  mov r0,'B' // bl wrchr_r0
  mov r0,'A' // bl wrchr_r0
  mov r0,'D' // bl wrchr_r0
  mov r0,'#' // bl wrchr_r0
  mov r0,'5' // bl wrchr_r0
 b    @@done
;------------------
wpa2_tx_callback_handshake2_list:
 dd wpa2_callback_send_data_handshake2  ;-handshake2
 dd 0
;---
wpa2_tx_callback_handshake4_list:
.if 1
 dd wpa2_callback_send_data_handshake4   ;-handshake4
 dd wpa2_callback_send_cmd_synchronize   ;\
 dd wpa2_callback_send_data_dummy_xx_02  ;
 dd wpa2_callback_send_data_dummy_xx_02  ; set TK and GTK
 dd wpa2_callback_send_cmd_cipher_tk     ;
 dd wpa2_callback_send_cmd_cipher_gtk    ;
 dd wpa2_callback_send_cmd_synchronize   ;/
 dd wpa2_callback_handshake_done         ;-done
 dd 0
.else   ;below is same as above, but in separate steps (as done by dsi browser)
 dd wpa2_callback_send_data_handshake4   ;-handshake4
 dd wpa2_callback_send_cmd_synchronize   ;\
 dd wpa2_callback_send_data_dummy_xx_02  ;
 dd wpa2_callback_send_data_dummy_xx_02  ; set TK
 dd wpa2_callback_send_cmd_cipher_tk     ;
 dd wpa2_callback_send_cmd_synchronize   ;/
 dd wpa2_callback_send_cmd_synchronize   ;\
 dd wpa2_callback_send_data_dummy_xx_02  ;
 dd wpa2_callback_send_data_dummy_xx_02  ; set GTK
 dd wpa2_callback_send_cmd_cipher_gtk    ;
 dd wpa2_callback_send_cmd_synchronize   ;/
 dd wpa2_callback_handshake_done         ;-done
 dd 0
.endif
;---
wpa2_tx_callback_handshake6_list:
 ;note: DSi browser sends WMI_SYNCHRONIZE (with param 01h or 09h), and dummy
 ;data writes (with 02h=data or 05h=data? in 1st byte), to some level that's
 ;working (in terms of applying the new key during idle periods).
 ;but, if it occurs DURING acive wifiboot upload then the upload hangs,
 ;workaround is to omit the sync/dummy stuff, and just apply the GTK key and
 ;send the handshake, that works too (and doesn't break uploads):
 dd wpa2_callback_send_cmd_cipher_gtk    ;-set GTK
 dd wpa2_callback_send_data_handshake6   ;-handshake6
 dd wpa2_callback_handshake_done         ;-done
 dd 0
;------------------
wpa_tx_callback_handshake2_list:
 dd wpa_callback_send_data_handshake2   ;-handshake2
 dd 0
;---
wpa_tx_callback_handshake4_list:
 dd wpa_callback_send_data_handshake4   ;-
 dd wpa_callback_send_cmd_synchronize   ;\
 dd wpa_callback_send_data_dummy_xx_02  ;
 dd wpa_callback_send_data_dummy_xx_02  ; set TK
 dd wpa_callback_send_cmd_cipher_tk     ;
 dd wpa_callback_send_cmd_synchronize   ;/
 dd 0                                   ;-now await handshake5 for WPA
;---
wpa_tx_callback_handshake6_list:
;no wpa_callback_send_cmd_synchronize   ;-blah (disturbs DURING uploads)
;no wpa_callback_send_data_dummy_xx_02  ;-blah (disturbs DURING uploads)
;no wpa_callback_send_data_dummy_xx_02  ;-blah (disturbs DURING uploads)
 dd wpa_callback_send_cmd_cipher_gtk    ;-set GTK
;no wpa_callback_send_cmd_synchronize   ;-blah (disturbs DURING uploads)
 dd wpa_callback_send_data_handshake6   ;-handshake6
 dd wpa_callback_handshake_done         ;-done
 dd 0
;------------------
wpa_callback_handshake_done:
wpa2_callback_handshake_done:
 ldr  r1,=WifiData_4way_handshake_busy  ;\
 mov  r0,0                              ; allow DHCP now
 strb r0,[r1]                           ;/
 bx   lr
;------------------
get_xlat_crypto_to_oui:  ;in: r0=src/type, r1=dst/oui
 ldrb  r0,[r0]   ;WifiData_grp7/pair7
 cmp   r0,KEY_TYPE_TKIP
 moveq r2,02h  ;TKIP
 movne r2,04h  ;AES (CCMP)
 strb  r2,[r1,03h]  ;adjust OUI[3]
 bx    lr
;------------------
wpa_callback_send_data_handshake2:
 push lr
 ldr  r0,=WifiData_grp7                         ;\
 ldr  r1,=ath_wpa_handshake2_data+16h+8+63h+08h ; adjust OUI for group key
 bl   get_xlat_crypto_to_oui                    ;/
 ldr  r0,=WifiData_pair7                        ;\
 ldr  r1,=ath_wpa_handshake2_data+16h+8+63h+0Eh ; adjust OUI for pairwise key
 bl   get_xlat_crypto_to_oui                    ;/
 ldr  r0,=ath_wpa_handshake2_data               ;\
 ldr  r1,=WifiData_replay7                      ;
 ldr  r2,=WifiData_snonce7                      ;
 bl   eapol_adjust_and_send                     ;/
 pop  pc
;---
wpa_callback_send_data_handshake4:
 ldr  r0,=ath_wpa_handshake4_data
 ldr  r1,=WifiData_replay7
 mov  r2,0  ;nonce=zerofilled
 b    eapol_adjust_and_send
;---
wpa_callback_send_data_handshake6:
 ldr  r0,=ath_wpa_handshake6_data
          ldr  r1,=WifiData_gtk_index7
          ldrb r1,[r1]
          ldrb r2,[r0,16h+8+05h+1] ;KeyInfo lsb
          bic  r2,30h             ;WPA_KEYINFO_HANDSHAKE6 .lsb
          orr  r2,r2,r1,lsl 4
          strb r2,[r0,16h+8+05h+1] ;KeyInfo lsb

 ldr  r1,=WifiData_replay7
 mov  r2,0  ;nonce=zerofilled
 b    eapol_adjust_and_send
;------------------
wpa2_callback_send_data_handshake2:
 push lr
 ldr  r0,=WifiData_grp7                         ;\
 ldr  r1,=ath_wpa2_handshake2_data+16h+8+63h+04h; adjust OUI for group key
 bl   get_xlat_crypto_to_oui                    ;/
 ldr  r0,=WifiData_pair7                        ;\
 ldr  r1,=ath_wpa2_handshake2_data+16h+8+63h+0Ah; adjust OUI for pairwise key
 bl   get_xlat_crypto_to_oui                    ;/
 ldr  r0,=ath_wpa2_handshake2_data
 ldr  r1,=WifiData_replay7
 ldr  r2,=WifiData_snonce7
 bl   eapol_adjust_and_send
 pop  pc
;---
wpa2_callback_send_data_handshake4:
 ldr  r0,=ath_wpa2_handshake4_data
 ldr  r1,=WifiData_replay7
 mov  r2,0  ;nonce=zerofilled
 b    eapol_adjust_and_send
;---
wpa2_callback_send_data_handshake6:
 ldr  r0,=ath_wpa2_handshake6_data
 ldr  r1,=WifiData_replay7
 mov  r2,0  ;nonce=zerofilled
 b    eapol_adjust_and_send
;------------------
eapol_adjust_and_send:
 push r4-r6,lr
 mov  r4,r0     ;packet
 mov  r5,r1     ;replay_counter
 mov  r6,r2     ;nonce
;- - -


 ldr  r1,=WifiData_handshake_crypt      ;\
 ldrb r1,[r1]                           ;
 ldrb r0,[r4,16h+8+05h+1] ;key.info.lsb ;
 bic  r0,07h                            ;
 orr  r0,r1                             ;
 strb r0,[r4,16h+8+05h+1] ;key.info.lsb ;/


 ldr  r0,=WifiData_bssid7               ;\
 add  r1,r4,8+0                         ; BSSID
 bl   arm7_Wifi_CopyMacAddr             ;/
 ldr  r0,=WifiData_MacAddr              ;\
 add  r1,r4,8+6                         ; MAC addr of DSi
 bl   arm7_Wifi_CopyMacAddr             ;/
 mov  r0,r5     ;replay_counter         ;\
 add  r1,r4,16h+8+09h                   ; EAPOL Replay Counter (as from handshake1)
 mov  r2,8                              ;
 bl   memcopy_bytewise                  ;/
 add  r0,r4,16h+8+11h                   ;\
 mov  r1,32                             ; EAPOL SNonce (initially zerofill)
 bl   zerofill_bytewise                 ;/
 movs r0,r6     ;nonce                  ;\
 add  r1,r4,16h+8+11h                   ; EAPOL SNonce (if any)
 mov  r2,32                             ;
 blne memcopy_bytewise                  ;/
 add  r0,r4,16h+8                       ;\EAPOL MIC
 bl   wpa2_adjust_eapol_mic             ;/
;- - -
 mov  r0,r4                             ;\okay, send handshake
 bl   sdio_send_wmi_data                ;/
;- - -
;note: if access point dislikes handshake2/handshake4 data (eg. bad len,MIC),
;then WMI_DISCONNECT_EVENT occurs IMMEDIATELY after sending the handshake
;- - -
 pop  r4-r6,pc
;------------------
wpa_callback_send_data_dummy_xx_02:
wpa2_callback_send_data_dummy_xx_02:
 ldr  r0,=ath_dummy_data_xx_02          ;\
 b    sdio_send_wmi_data                ;/
;------------------
;wpa2_callback_send_data_dummy_xx_02_5:
; ldr  r0,=ath_dummy_data_xx_02_5        ;\
; b    sdio_send_wmi_data                ;/
;------------------
;wpa_callback_send_data_dummy_xx_02_z:
;wpa2_callback_send_data_dummy_xx_02_z:
; ldr  r0,=ath_dummy_data_xx_02_z        ;\
; b    sdio_send_wmi_data                ;/
;------------------
wpa_callback_send_cmd_synchronize:
wpa2_callback_send_cmd_synchronize:
 ldr  r0,=ath_synchronize_cmd_0000h_01h ;\
 b    sdio_send_wmi_cmd_without_poll    ;/
;------------------
wpa2_callback_send_cmd_synchronize9:
 ldr  r0,=ath_synchronize_cmd_0000h_09h ;\
 b    sdio_send_wmi_cmd_without_poll    ;/
;------------------
wpa_callback_send_cmd_cipher_tk:
wpa2_callback_send_cmd_cipher_tk:
 ldr   r0,=WifiData_ptk7+20h    ;-key (TK)
 mov   r1,0                     ;-RSC (none/zero for TK)
 ldr   r2,=WifiData_pair7       ;\bytes LLUUTTIIh:
 ldrb  r2,[r2]                  ; LL=Len=10h/20h
 mov   r2,r2,lsl 8    ;Type     ; UU=Usage=00h=Pairwise
 cmp   r2,KEY_TYPE_TKIP*100h    ; TT=Type=AES/TKIP
 orreq r2,20h shl 24  ;TKIP.len ; II=KeyIndex=00h
 orrne r2,10h shl 24  ;AES.len  ;/
 b    wpa_wpa2_callback_send_cmd_cipher
;---
wpa_callback_send_cmd_cipher_gtk:
wpa2_callback_send_cmd_cipher_gtk:
 ldr   r0,=WifiData_gtk7+00h    ;-key (GTK)
 ldr   r1,=WifiData_rsc7        ;-rsc (from handshake3/5) (needed for o2acc2, which has nonzero value in handshake3) (not needed for fritzbox, because that has zeroes in handshake3)
 ldr   r2,=WifiData_grp7        ;\
 ldrb  r2,[r2]                  ;
 mov   r2,r2,lsl 8    ;Type     ; bytes LLUUTTIIh:
 CMP   R2,key_type_tkip*100H    ; LL=Len=10h/20h
 orreq r2,20h shl 24  ;TKIP.len ; UU=Usage=01h=Group
 orrne r2,10h shl 24  ;AES.len  ; TT=Type=AES/TKIP
 orr   r2,01h shl 16  ;Group    ; II=KeyIndex=01h/02h
 ldr   r3,=WifiData_gtk_index7  ;
 ldrb  r3,[r3]                  ;
 orr   r2,r3          ;Index    ;/
 b    wpa_wpa2_callback_send_cmd_cipher
;------------------
wpa_wpa2_callback_send_cmd_cipher:
 push r4-r7,lr
 mov  r4,r0  ;key
 mov  r5,r1  ;rsc
 mov  r6,r2  ;bytes
 ldr  r7,=ath_add_cipher_key_cmd
;- - -
 mov  r0,r4        ;src (key)                   ;\
 add  r1,r7,8+0Ch  ;dst                         ; key (first 10h bytes)
 mov  r2,10h       ;len                         ; (for WPA and WPA2)
 bl   memcopy_bytewise                          ;/
 add  r0,r4,10h+8  ;src (key+18h)               ;\key (more 8 bytes)
 mov  r2,8         ;len                         ; (for WPA only, not WPA2)
 bl   memcopy_bytewise                          ;/
 add  r0,r4,10h+0  ;src (key+10h)               ;\key (more 8 bytes)
 mov  r2,8         ;len                         ; (for WPA only, not WPA2)
 bl   memcopy_bytewise                          ;/
 add  r0,r7,8+04h                               ;\
 mov  r1,08h       ;len                         ; rsc (initially/zero for TK)
 bl   zerofill_bytewise                         ;/
 movs r0,r5        ;src (rsc)                   ;\
 add  r1,r7,8+04h  ;dst                         ; rsc (for GTK only, not TK)
 mov  r2,08h       ;len                         ;
 blne memcopy_bytewise                          ;/
 str  r6,[r7,8+00h]  ;bytes                     ;-bytes LLUUTTII (LenUsageTypeIndex)
 mov  r0,r7                                     ;\send add cipher cmd
 bl   sdio_send_wmi_cmd_without_poll            ;/
 pop  r4-r7,pc
;------------------
dsi7_sdio_tx_callback:  ;EAPOL callbacks for DATA/CMDs (if any)
 ldr  r0,=curr_wpa_tx_callback_list_ptr ;\
 ldr  r1,[r0]  ;ptr in callback_list    ; exit if no callback list
 cmp  r1,0                              ;
 bxeq lr    ;no_callback                ;/
 ldr  r2,=ath_cmd_ack_pending           ;\
 ldrb r2,[r2]                           ; exit if old CMD or TX is still busy
 ldr  r3,=ath_data_ack_pending          ; (callbacks may send either CMD or DATA, so wait for BOTH being non-busy) (MAYBE that's even required, ie. not to send DATA when the CMD wasn't done yet, or vice-versa)
 ldrb r3,[r3]                           ;
 orrs r2,r3                             ;
 bxne lr                                ;/
;- - -
 ldr  r2,[r1],4  ;get proc=[list]
 str  r1,[r0]  ;ptr in callback_list
 cmp  r2,0
 bxne r2    ;------> callback !!!
;- - -
 str  r2,[r0]  ;ptr in callback_list=0  ;-mark list empty (ptr=0)
 bx   lr
;------------------
dsi7_Wifi_Intr_TxEnd:  ;in/out: none
 push r4-r9,lr
 ldr  r1,=ath_data_ack_pending          ;\
 ldrb r0,[r1]                           ; exit if old TX is still busy
 cmp  r0,0                              ;
 bne  @@exit                            ;/
;- - -
;NDS code would check "arm7qlen" here (managment frames TXed from ARM7),
;that's not needed for DSi (as managment is done automatically by CMD/EVENTs).
;However, WPA/WPA2 needs sending EAPOL data packets and CIPHER CMDs,
;that's done via "dsi7_sdio_tx_callback" via callbacks instead of via queue.
;- - -
 ldr  r0,=sdio_xfer_buf_minus_14        ;\copy packet to TX_LOC3 in WifiRAM
 bl   arm7_Wifi_CopyFirstTxData         ; (exit if failed; ie. queue empty,
 cmp  r0,0   ;0=failed                  ; or packet not fully queued yet)
 beq  @@exit ;--> oops                  ;/
;- - -
 .if with_gimmicks
   ;NDS code would redirect "FrameControl=Beacon" to WIFIRAM_TX_BEACON_START
   ;here (but dunno if "FrameControl<>Data" is possible with DSi-Wifi at all)
 .endif
;- - -
 ldr  r0,=sdio_xfer_buf_minus_14 ;NDS-style 36-byte hdr ;\
 ldr  r1,=sdio_xfer_buf          ;DSi-style 22-byte hdr ;
 ldrh   r2,[r0,0ah]     ;-len=hw.hdr[0Ah]               ; now convert NDS-style
 ldrh   r3,[r0,0ch+00h] ;-FC=ieee.hdr[00h]              ; header to DSi-style
 tst    r3,100h         ;-FC.ToDS (0=ADHOC)             ;
 ldreqh r4,[r0,0ch+04h] ;\                              ; NDS-style src is:
 ldreqh r5,[r0,0ch+06h] ; Addr1 (DA/BSSID)              ;   12 byte HW header               ;\36 bytes
 ldreqh r6,[r0,0ch+08h] ;/                              ;   24 byte IEEE header             ;/
 ldrh   r7,[r0,0ch+0ah] ;\                              ;   .. data LLC etc.
 ldrh   r8,[r0,0ch+0ch] ; Addr2 (SA)                    ; DSi-style dst is:
 ldrh   r9,[r0,0ch+0eh] ;/                              ;    6 byte MBOX header             ;\
 ldrneh r4,[r0,0ch+10h] ;\                              ;    2 byte 0000h (or 1C00h)        ;
 ldrneh r5,[r0,0ch+12h] ; Addr3 (BSSID/DA)              ;    6 byte dest.mac                ; 22 bytes
 ldrneh r6,[r0,0ch+14h] ;/                              ;    6 byte src.mac                 ;
 add  r2,10h-24-4       ;-plus mbox(10h)-ieee(24)-crc(4);    2 byte data.len in BIG-ENDIAN  ;/
 ldr  r0,=0102h  ;data, and request data.ack            ;   .. data LLC etc.
        ;;mov r0,02h  ;XXX <-- this would trigger unexpected xtra.data responses during upload
 strh r0,[r1,00h]       ;-mbox.hdr[00h]=type/req        ;
 strh r2,[r1,02h]       ;-mbox.hdr[02h]=len             ; and with SA/DA as how
 mov  r0,0                                              ; they were stored by
 strh r0,[r1,04h]       ;-mbox.hdr[04h]=0 (or 2008h)    ; "arm9_Wifi_TransmitFunction"

   ldrh r0,[r1,16h+6]
   ldr  r3,=PROTOCOL_ETHER_ARP
   cmp  r3,r0       ;dsi browser does somewhat like so (but it works also with always=0000h or always=1C00h)
   moveq r0,1c00h   ;o2wlan64 throws ONE such after DHCP and ONE after receving "dsboot" broadcast
   movne r0,0000h   ;o2wlan64 throws TWO such for DCHP
            ;;;MOV r0,0     ;XXX

 strh r0,[r1,06h]       ;-mbox.hdr[06h]=0 (or 1C00h)    ;
 strh r4,[r1,08h]       ;\                              ;
 strh r5,[r1,0ah]       ; mbox.hdr[08h]=DA              ;
 strh r6,[r1,0ch]       ;/                              ;
 strh r7,[r1,0eh]       ;\                              ;
 strh r8,[r1,10h]       ; mbox.hdr[0Eh]=SA              ;
 strh r9,[r1,12h]       ;/                              ;
 sub  r2,10h  ;len-10h  ;\                              ;
 mov  r0,r2,lsl 8       ; mbox.hdr[14h]=len-10h         ;
 orr  r0,r0,r2,lsr 8    ; (in BIG-ENDIAN)               ;
 strh r0,[r1,14h]       ;/                              ;/
;- - -

       .if show_tx_info
        mov r0,'T' // bl wrchr_r0
        mov r0,13h // bl wrchr_r0
        mov r0,r4 // bl wrhex16bit         ;DA
        mov r0,12h // bl wrchr_r0
        mov r0,r7 // bl wrhex16bit         ;SA
        ldrh r0,[r1,02h] // bl wrhex16bit  ;len
        ldrh r0,[r1,06h] // bl wrhex16bit  ;0000h/1C00h
        mov r0,10h // bl wrchr_r0
            ; mov r0,r5 ;DA (FFFF for dhcp)
            ; bl wrhex16bit
            ; mov r0,r8 ;SA (F407 for dsi)
            ; bl wrhex16bit
            ;      ldr  r0,=sdio_xfer_buf
            ;      ldrh r0,[r0,14h]   ;=5001h aka 150h big-end (DHCP)
            ;      bl wrhex16bit
            ;      ldr  r0,=sdio_xfer_buf
            ;      ldrh r0,[r0,16h]   ;=AAAAh LLC
            ;      bl wrhex16bit
            ;      ldr  r0,=sdio_xfer_buf
            ;      ldrh r0,[r0,2]   ;=160h (DHCP)
            ;      bl wrhex16bit
            ;    mov r0,'T' // bl wrchr_r0
       .endif

 ldr  r0,=sdio_xfer_buf   ;src          ;\okay, send the TX data packet
 bl   sdio_send_wmi_data                ;/
@@exit:
 pop  r4-r9,pc
;------------------
dsi7_Wifi_Intr_RxEnd:  ;in/out: none
 push r4-r9,lr
        .if show_rx_info
           bl wrdot
        .endif
 ldr  r1,=sdio_xfer_buf          ;DSi-style 22-byte hdr ;\
;ldrb r0,[r1,00h]       ;-mbox.hdr[00h]=type            ;
 ldrb r0,[r1,01h]       ;-mbox.hdr[00h]=req             ;
 ldrh r2,[r1,02h]       ;\mbox.hdr[02h]=len             ;
 sub  r2,10h  ;len.body ;/                              ;
 cmp  r0,02h  ;req      ;\                              ;
 ldreqb r0,[r1,04h]     ; mbox.hdr[04h]=xtra.len        ; DSi-style header
 subeq  r2,r0 ;len.body ;/                              ;
;ldrb r0,[r1,05h]       ;-mbox.hdr[05h]=00h/7Fh/F4h/FFh ;
 ldrb r3,[r1,06h]       ;-mbox.hdr[06h]=SNR             ;
;ldrb r0,[r1,07h]       ;-mbox.hdr[07h]=00h             ;
 ldrh r4,[r1,08h]       ;\                              ;
 ldrh r5,[r1,0ah]       ; mbox.hdr[08h]=DA              ;
 ldrh r6,[r1,0ch]       ;/                              ;
 ldrh r7,[r1,0eh]       ;\                              ;
 ldrh r8,[r1,10h]       ; mbox.hdr[0Eh]=SA              ;
 ldrh r9,[r1,12h]       ;/                              ;
 ldrh r0,[r1,14h]       ;\                              ;
 orr  r0,r0,r0,lsl 16   ; mbox.hdr[14h]=len-10h         ;
 bic  r0,0ff000000h     ; (in BIG-ENDIAN)               ;
 mov  r0,r0,lsr 8       ;                               ;
 cmp  r0,r2   ;len.body :                               ;
 bne  @@oops            ;/                              ;/
 ldr  r1,=sdio_xfer_buf_minus_14 ;NDS-style 36-byte hdr ;\
 mov  r0,0018h          ;\hw.hdr[00h]=flags/data        ;
 strh r0,[r1,00h]       ;/                              ;
 mov  r0,0040h          ;\hw.hdr[02h]=0040h             ;
 strh r0,[r1,02h]       ;/                              ; NDS-style header
 mov  r0,0000h          ;\hw.hdr[04h]=time since last?  ;
 strh r0,[r1,04h]       ;/                              ;
 mov  r0,000ah          ;\hw.hdr[06h]=N*0.1Mbit/s       ;
 strh r0,[r1,06h]       ;/                              ;
 add  r2,24  ;ieee+body ;\hw.hdr[08h]=len ieee(24)+body ;
 strh r2,[r1,08h]       ;/                              ;
 strh r3,[r1,0ah]       ;-hw.hdr[08h]=max rssi          ;
 strh r3,[r1,0ch]       ;-hw.hdr[08h]=min rssi          ;
 mov    r3,0008h ;? XXX ;\ieee.hdr[00h]=FC (data)       ;
 strh   r3,[r1,0ch+00h] ;/                              ;
 mov    r0,0000h        ;\ieee.hdr[02h]=Duration/ID     ;
 strh   r0,[r1,0ch+02h] ;/                              ;
 tst    r3,200h         ;-FC.FromDS                     ;
 strh   r4,[r1,0ch+04h] ;\                              ;
 strh   r5,[r1,0ch+06h] ; ieee.hdr[04h]=Addr1 (DA)      ;
 strh   r6,[r1,0ch+08h] ;/                              ; with DA/SA as expected
 streqh r7,[r1,0ch+0ah] ;\                              ; in "arm9_Wifi_Update"
 streqh r8,[r1,0ch+0ch] ; ieee.hdr[0Ah]=Addr2 (SA/BSSID);
 streqh r9,[r1,0ch+0eh] ;/                              ;
 strneh r7,[r1,0ch+10h] ;\                              ;
 strneh r8,[r1,0ch+12h] ; ieee.hdr[10h]=Addr3 (BSSID/SA);
 strneh r9,[r1,0ch+14h] ;/                              ;
;(and could/should store BSSID in the Addr2/Addr3)      ;
 mov    r0,0000h        ;\ieee.hdr[16h]=SequenceCtrl    ;
 strh   r0,[r1,0ch+16h] ;/                              ;/
;- - -
 add  r8,r2,12+3 ;len, hw.hdr(12) plus round-up(3)      ;\
 bic  r8,3       ;len, align                            ;/
;- - -
 ldr  r1,=WifiData_stats                ;\
 ldr  r0,[r1,WSTAT_RXPACKETS*4]      ;\ ;
 add  r0,1                           ;  ;
 ldr  r0,[r1,WSTAT_RXPACKETS*4]      ;/ ;
 ldr  r0,[r1,WSTAT_RXBYTES*4]        ;\ ; raise stats
 add  r0,r8                          ;  ;
 ldr  r0,[r1,WSTAT_RXBYTES*4]        ;/ ;
 ldr  r0,[r1,WSTAT_RXDATABYTES*4]    ;\ ;
 add  r0,r8                          ;  ;
 sub  r0,12  ;exclude hw header      ;  ;
 ldr  r0,[r1,WSTAT_RXDATABYTES*4]    ;/ ;/
;- - -
 mov  r0,WFLAG_PACKET_DATA              ;-always Data for DSi-wifi (unlike NDS-wifi, which uses "arm7_Wifi_ProcessReceivedFrame" to distinguish between Control/Managment/Data frames)
 ldr  r1,=WifiData_reqPacketFlags       ;\
 ldr  r1,[r1]                           ; check if above indicated
 tst  r1,r0   ;type (from above call)   ; a requested type (or if
 ldreq  r1,=WifiData_reqReqFlags        ; "PROMISC" is requested),
 ldreqh r1,[r1]                         ; ignore packet if not so
 tsteq  r1,WFLAG_REQ_PROMISC            ;
 beq  @@ignore_packet                   ;/
 ldr  r1,=keepalive_time                ;\
 mov  r0,0                              ; okay, reset keepalive (uh, upon RECEIVE? shouldn't it be done only when SENDING something to access point? so the access point KNOWS the connection is alive)
 str  r0,[r1]                           ;/
 ldr  r0,=sdio_xfer_buf_minus_14 ;src                   ;\
 mov  r1,r8     ;len                                    ; okay,
 mov  r2,0ffffffffh  ;dummy.wrap.end  (no wrapping)     ; forward to rx queue
 mov  r3,0           ;dummy.wrap.size (no wrapping)     ;
 bl   arm7_Wifi_QueueRxMacData   ;--->                  ;
;cmp  r0,0  ;error (ignored for now)                    ;/
 b    @@done
@@oops:
@@ignore_packet:
        mov r0,'?' // bl wrchr_r0
@@done:
 pop  r4-r9,pc
;------------------
sdio_send_wmi_data:   ;in: r0
 push lr

        ;;;mov  r2,0 ;1c00h        ;\XXXXXX not good (hangs when forced to 0000 or 1C00)
        ;;;strh r2,[r0,06h]        ;/

   ldrb r2,[r0,01h]  ;cmd.ack.req         ;\
   ldr  r1,=ath_data_ack_pending          ; mark data.ack pending
   strb r2,[r1]                           ;/


;mov  r0,r0               ;src          ;\okay, send the TX data packet
 bl   sdio_send_mbox_block              ;/

;; ldr  r1,=ath_data_ack_pending          ;\
;; mov  r0,1                              ; mark data transfer busy now
;; strb r0,[r1]                           ;/

 pop  pc
;------------------
sdio_send_wmi_cmd:      ;in: r0
 push r4,lr
 mov  r4,r0  ;cmd
@@wait_lop:                             ;\
 bl   sdio_poll_mbox                    ; poll mbox
 ldr  r1,=ath_cmd_ack_pending           ; and
 ldrb r0,[r1]                           ; wait until no cmd.ack pending
 cmp  r0,0                              ;
 bne  @@wait_lop                        ;/
 mov  r0,r4  ;cmd                       ;\send command
 bl   sdio_send_mbox_block              ;/
 ldrb r0,[r4,01h]  ;cmd.ack.req         ;\
 ldr  r1,=ath_cmd_ack_pending           ; mark cmd.ack pending
 strb r0,[r1]                           ;/
 pop  r4,pc
;------------------
sdio_send_wmi_cmd_without_poll:    ;in: r0    ;WITHOUT poll (for use in callbacks from INSIDE of polling)
 push r4,lr
 mov  r4,r0  ;cmd
;mov  r0,r0  ;cmd                       ;\send command
 bl   sdio_send_mbox_block              ;/
 ldrb r0,[r4,01h]  ;cmd.ack.req         ;\
 ldr  r1,=ath_cmd_ack_pending           ; mark cmd.ack pending
 strb r0,[r1]                           ;/
 pop  r4,pc
;------------------
sdio_poll_mbox:
 push r4-r6,lr
 bl   arm7_disable_ime                  ;\
 mov  r5,r0                             ;/
 ldr  r4,=sdio_xfer_buf                 ;-buffer for STAT and MBOX
       ;mov  r6,100     ;XXX limit below to MAX <nn> polls per call
        mov  r6,10      ;XXX limit below to MAX <nn> polls per call
                        ;NB. NEVER came here from "dsi7_Wifi_Interrupt" !!!

@@poll_mbox_lop:
               .if 0
                mov r0,r6
                bl wrhex8bit
               .endif
        subs r6,1
        beq  @@done_enough
 bl   dsi7_sdio_heartbeat               ;-send heartbeat (if any, if possible)
 bl   dsi7_sdio_tx_callback             ;-send callbacks (if any, if possible)
 bl   dsi7_Wifi_Intr_TxEnd              ;-send TX data (if any, if possible)

 ldr  r1,=ath_lookahead_flag            ;\
 ldrb r0,[r1]                           ; skip check if already having
 cmp  r0,0                              ; memorized lookahead
 bne  @@not_empty                       ;/
 bl   sdio_check_mbox_state             ;\
       ldrb r0,[r4,00h]  ;HOST_INT_STATUS     ;\
       tst  r0,1     ;test mbox0 not empty    ;
       beq  @@done_empty                      ;/
      ;@@wait_enough:
       ldrb r0,[r4,04h]  ;MBOX_FRAME          ;\
       tst  r0,01h   ;test mbox0 SOM          ;
       beq  @@wait_enough ;@@done_empty       ;
      ;tst  r0,10h   ;test mbox0 EOM          ;   <-- fixed 1/2018 (but bit4 is NEVER set?)
      ;beq  @@wait_enough ;@@done_empty       ;/
 ldrb r0,[r4,05h]  ;RX_LOOKAHEAD_VALID  ; check if mbox empty
 tst  r0,1     ;test mbox0 min 4 bytes  ;
 beq  @@wait_enough ;@@done_empty                      ;/
;XXX maybe also need to test SOM and EOM flags for knowing if FULL packet is available?
 ldr  r0,[r4,08h]  ;RX_LOOKAHEAD0 ;\    ;\
 ldr  r1,=ath_lookahead_value     ;     ;
 str  r0,[r1]                     ;/    ;/
@@not_empty:
;- - -
   ;XXX do below as RAW recv (without further "sdio_check_mbox_state")
   ;XXX use lookahead_value in RECV function (for transfer len) ;\
   ;XXX support MULTIPLE 80h-byte blocks                        ;/
   ;XXX support DATA exceeding max MBOX size (however that's done)
.if 1
   ldr  r1,=ath_lookahead_value     ;\
   ldrh r2,[r1,2]                   ;/
   add  r2,6   ;total_len
   add  r2,7fh ;round up
   bic  r2,7fh

   ldr  r0,=sdio_xfer_buf ;dst (temp buf) ;\
   ldr  r1,=18001000h     ;src (mbox/blk) ; receive mbox block
   sub  r1,r2  ;src-len                   ;
   mov  r2,r2,lsr 7  ;len/80h ;len (blks) ;
   bl   sdio_cmd53_read                   ;/  ;in: r0=dst(mem), r1=src(io), r2=len
.else
   bl   sdio_recv_mbox_block                                    ;-RECV
.endif

 ldr  r1,=ath_lookahead_flag            ;\
 mov  r0,0                              ; mark lookahead now empty
 strb r0,[r1]                           ;/
;- - -
 ldrb r0,[r4,01h]       ;xtra.flag      ;\
 cmp  r0,00h       ;no trailer          ;
 beq  @@xtra_done                       ;
 cmp  r0,02h       ;with trailer        ;
 bne  @@unknown                         ;/
 ldrb r2,[r4,04h]       ;xtra.len       ;\
 cmp  r2,0                              ;
 beq  @@xtra_done                       ;/
 ldrh r0,[r4,02h]       ;total.len      ;\
 subs r0,r2                             ;
 blo  @@unknown                         ;
 add  r0,6                              ;
 add  r1,r4,r0                          ;/
@@xtra_lop:
 subs r2,2              ;xtra.len
 blo  @@unknown
 ldrb r0,[r1],1         ;xtra.item.type ;\
 ldrb r3,[r1],1         ;xtra.item.len  ;
 subs r2,r3             ;xtra.len-item.len
 blo  @@unknown
 cmp  r0,01h              ;\            ;
 beq  @@xtra_ack          ;/            ; xtra item
 cmp  r0,02h              ;\            ;
 beq  @@xtra_lookahead    ;/            ;
    ;cmp  r0,12h   ;XXX       ;\appears in 1004h  (12h,18h,60h,2Dh,1Ah,FEh,18h,1Fh)?
    ;beq  @@xtra_done         ;/
    ;    bl wrhex8bit
 b    @@unknown   ;oops                 ;
@@xtra_back:                            ;/
; add  r3,2   ;item.len+2                ;\
; subs r2,r3  ;len-(item.len+2)          ; xtra next
; bhi  @@xtra_lop                        ;
; blo  @@unknown   ;oops                 ;/
 cmp  r2,0   ;xtra.len                  ;\xtra next
 bne  @@xtra_lop                        ;/
@@xtra_done:
;- - -
 ldr  r0,[r4,00h]                       ;\
 and  r2,r0,0ffh                        ;
 cmp  r2,01h                            ;
 blo  @@ack                             ; primary type
 beq  @@event                           ;
 cmp  r2,02h                            ;
 beq  @@data                            ;

   cmp  r2,05h  ;\occurs on o2acc2 ??   ;
   beq  @@data  ;/                      ;

 b    @@unknown                         ;/
;---
@@done_empty:
      @@wait_enough:
@@done_enough:
 mov  r0,r5                             ;\
 bl   arm7_restore_ime                  ;/
 pop  r4-r6,pc
;--- --- ---
@@xtra_ack:

        ;XXX Read (handshake with len=0Eh) (acklen=4) (!!!)    00 02 0E 00 0E 00  01 04 01 01 02 01 02 06 00 00 00 00 00 00  ;(this isn't WPA related, just interesting because it does deliver a "Cmd.ack" and "Data.ack" in the same packet)
@@xtra_ack_lop:
 subs r3,2      ;xtra.item.len          ;\verify expected len
 blo  @@unknown                         ;/
 ldrb r0,[r1],1                         ;\
 cmp  r0,01h                    ;\      ;
 ldreq r0,=ath_cmd_ack_pending  ; cmd   ;
 beq  @@this_xtra_ack           ;/      ; check ack type
 cmp  r0,02h                    ;\      ;
 ldreq r0,=ath_data_ack_pending ; data  ;
 beq  @@this_xtra_ack           ;/      ;
 cmp  r0,05h                    ;\      ;
 ldreq r0,=ath_data_ack_pending ; data? ;
 beq  @@this_xtra_ack           ;/      ;
 b    @@unknown                         ;/
@@this_xtra_ack:                        ;\
 push r1                                ;
 mov  r1,0  ;no more pending            ; mark ack no longer pending
 strb r1,[r0]                           ;
 pop  r1                                ;/
 ldrb r0,[r1],1                         ;\
 cmp  r0,01h                            ; verify whatever (01h)
 bne  @@unknown                         ;/
 cmp  r3,0      ;xtra.item.len  ;\lop more (when dual ack for cmd+data)
 bne  @@xtra_ack_lop            ;/
 b    @@xtra_back
;---
@@xtra_lookahead:
 cmp  r3,6      ;xtra.item.len  ;\verify expected len
 bne  @@unknown                 ;/
 push r2-r7                             ;\
 ldrb r2,[r1],1  ;-ID1                  ;
 ldrb r3,[r1],1  ;\                     ;
 ldrb r4,[r1],1  ; value (unaligned)    ;
 ldrb r5,[r1],1  ;                      ;
 ldrb r6,[r1],1  ;/                     ; memorize appended lookahead info
 ldrb r7,[r1],1  ;-ID2                  ; (if any)
 cmp   r2,0aah  ;ID1                    ; (ie. if MBOX already has more data)
 cmpeq r7,055h  ;ID2                    ;
 bne  @@no_lookahead                    ;
 ldr  r2,=ath_lookahead_value   ;\      ;
 orr  r3,r3,r4,lsl 8            ;       ;
 orr  r3,r3,r5,lsl 16           ;       ;
 orr  r3,r3,r6,lsl 24           ;       ;
 str  r3,[r2]                   ;/      ;
 ldr  r2,=ath_lookahead_flag    ;\      ;
 mov  r3,1                      ;       ;
 strb r3,[r2]                   ;/      ;
@@no_lookahead:                         ;
 pop  r2-r7                             ;/
 b    @@xtra_back
;--- --- ---
@@data:
 ldr  r2,=sdio_xfer_buf                 ;\
 ldrh r0,[r2,16h+6]                     ;
 ldr  r1,=PROTOCOL_ETHER_EAPOL          ; redirect EAPOL
 cmp  r0,r1                             ;
 beq  @@maybe_data_eapol                ;/
 bl   dsi7_Wifi_Intr_RxEnd              ;-process data
 b    @@poll_mbox_lop                   ;-try poll more
;--- --- ---
@@maybe_data_eapol:
 bl   dsi7_Wifi_Intr_RxEapolEnd         ;-process EAPOL data
 b    @@poll_mbox_lop                   ;-try poll more
;--- --- ---
@@ack:
 ldrb r0,[r4,01h]       ;xtra.flag (02h);\
 cmp  r0,002h                           ;
 bne  @@unknown                         ;/
 ldrh r0,[r4,02h]       ;total.len      ;\
 ldrb r2,[r4,04h]       ;xtra.len       ;
 cmp  r0,r2                             ;
 bne  @@unknown                         ;/
 b    @@poll_mbox_lop                   ;-try poll more
;--- --- ---
@@event:
 ldrh r0,[r4,06h]  ;event number
 add  r1,r4,8      ;event params
 ldrh r2,[r4,02h]  ;total.len

 ldrb r3,[r4,01h]       ;xtra.flag      ;\
 cmp  r3,02h
 movne  r3,00h  ;xtra.len=0=none
 ldreqb r3,[r4,04h]  ;xtra.len
;;; cmp  r3,0ffh ;only if xtra.flag were 00h
;;; moveq r3,0   ;only if xtra.flag were 00h
 add  r3,2         ;cmd+xtra.len
 subs r2,r3        ;param.len
 blo  @@unknown
 sub  r3,r0,1000h  ;EVENT-1000h
 cmp  r3,WMI_EXTENSION_EVENT-1000h      ;\prefix for WMIX events
 beq  @@extension_event                 ;/
 cmp  r3,WMI_BSSINFO_EVENT-1000h        ;\
 beq  @@bssinfo_event                   ;/
 cmp  r3,WMI_SCAN_COMPLETE_EVENT-1000h  ;\
 beq  @@scan_complete_event             ;/
 cmp  r3,WMI_CONNECT_EVENT-1000h        ;\
 beq  @@connect_event                   ;/
 cmp  r3,WMI_NEIGHBOR_REPORT_EVENT-1000h;\
 beq  @@neighbor_event                  ;/
 cmp  r3,WMI_PSTREAM_TIMEOUT_EVENT-1000h;\
 beq  @@pstream_timeout_event           ;/
 cmp  r3,WMI_READY_EVENT-1000h          ;\
 beq  @@ready_event                     ;/
 cmp  r3,WMI_REGDOMAIN_EVENT-1000h      ;\
 beq  @@regdomain_event                 ;/
 cmp  r3,WMI_ERROR_REPORT_EVENT-1000h   ;\
 beq  @@error_report_event              ;/
;cmp  r3,WMI_CMDERROR_EVENT-1000h       ;\
;beq  @@cmderror_event                  ;/
 cmp  r0,WMI_GET_CHANNEL_LIST_REPLY-0   ;\
 beq  @@channel_list_reply              ;/
 b    @@unknown                         ;-oops
@@event_back:
 b    @@poll_mbox_lop                   ;-try poll more
;--- --- ---
@@extension_event:
 ldr  r0,[r1],4  ;WMIX event number
 subs r2,4       ;param.len
 blo  @@unknown
 sub  r3,r0,3000h  ;EVENT-3000h
 cmp  r3,WMIX_HB_CHALLENGE_RESP_EVENT-3000h     ;\
 beq  @@heartbeat_event                         ;/
 cmp  r3,WMIX_DBGLOG_EVENT-3000h                ;\
 beq  @@debuglog_event                          ;/
 b    @@unknown                                 ;-oops
;--- --- ---
@@debuglog_event:
@@neighbor_event:
@@heartbeat_event:
@@pstream_timeout_event:
@@cmderror_event:
@@error_report_event:
        ;XXX whatever/ignore
 b    @@event_back
;--- --- ---
@@channel_list_reply:
 ldrb r0,[r1],1  ;get/skip reserved byte
 ldrb r2,[r1],1  ;get num channels
 mov  r3,0       ;channel mask (initially none)
@@channel_list_lop:
 ldrh r0,[r1],2
 sub  r0,900h  ;msb
 cmp  r0,9B4h-900h  ;ch14
 orreq r3,1 shl 14
 beq   @@channel_list_next
 sub  r0,96Ch-900h  ;ch1
 cmp  r0,9a8h-96ch  ;ch12
 bhi  @@channel_list_next  ;oops
 push r1-r3
 mov  r1,5
 swi  swi_div
 add  r2,r0,1 ;result+1
 mov  r0,1
 mov  r0,r0,lsl r2
 cmp  r1,0    ;remainder --> zf
 pop  r1-r3
 bne  @@channel_list_next  ;oops
 orr  r3,r0
@@channel_list_next:
 subs r2,1  ;num channels
 bne  @@channel_list_lop
 ldr  r1,=WifiData_reg_channels         ;\apply enabled channels
 str  r3,[r1]                           ;/
 b    @@event_back
;--- --- ---
@@ready_event:
        ;XXX could also parse READY_EVENT (or omit so, when omitting the whole BMI stuff, since that was already done by firmware)
        ;uhm, AR6002 should return 2100007Bh (firmware version)     ;maybe so on firmware-upload?
        ;but, AR6002 sometimes? returns 02000001h (chip version)?   ;maybe so on soft-reset?
        ;---
        ;bl wrcrlf
        ;ldrh r0,[r1,06h] // bl wrhex16bit // bl wrspc
        ;ldr  r0,[r1,08h] // bl wrhex32bit // bl wrspc
        ;bl wrcrlf
 b    @@event_back
;--- --- ---
@@regdomain_event:  ;REGDOMAIN aka REG_DOMAIN
 ldr  r0,[r1]                           ;\
 ldr  r3,=WifiData_reg_domain           ; parse REGDOMAIN_EVENT (or omit so, when omitting the whole BMI stuff, since that was already done by firmware)
 str  r0,[r3]                           ;/
 b    @@event_back
;--- --- ---
@@connect_event:
 mov  r0,WIFI_AUTHLEVEL_ASSOCIATED    ;\set new level to associated and
 ldr  r1,=WifiData_authlevel          ; reset auth ctr
 strh r0,[r1]  ;new auth level        ;
 mov  r0,0                            ;
 ldr  r1,=WifiData_authctr            ;
 strh r0,[r1]  ;new auth ctr          ;/

 ldr  r1,=WifiData_eapol7                       ;\
 ldrb r0,[r1]                                   ; for WPA/WPA2,
 cmp  r0,EAPOL_TYPE_NONE                        ; expect handshake1
 ldr  r1,=WifiData_expected_handshake           ;
 moveq r0,0  ;expect none for open/wep          ;
 movne r0,1  ;expect handshake1 for wpa/wpa2    ;
 strb r0,[r1]                                   ;/

        ;XXX gather whatever info from event param's
 ldr  r1,=ath_await_connect_complete    ;\
 mov  r0,0                              ; mark connect completed
 strb r0,[r1]                           ;/
 b    @@event_back
;--- --- ---
@@bssinfo_event:
 push r4-r7
 sub  sp,sgBeacon_size  ;\alloc beacon header info
 mov  r4,sp             ;/
 mov  r5,r1     ;params
 mov  r6,r2     ;param.len
;- - -
 ldrb r0,[r5,03h]  ;EVENT params SNR    ;\get SNR (signal strength)
 strb r0,[r4,sgBeacon_strength]         ;/(don't use the buggy RSSI entry)
 add  r0,r5,06h    ;EVENT params BSSID  ;\
 add  r1,r4,sgBeacon_sa            ;dst ; get SA (aka use BSSID here, too)
 bl   arm7_Wifi_CopyMacAddr             ;/       (uh, dswifi did somehow distinguish between SA and BSSID, and did set ADHOC flag if they were different - however, it did ignore the ADHOC flag thereafter, and also seems to have used only the BSSID value in the end)
 add  r0,r5,06h    ;EVENT params BSSID  ;\
 add  r1,r4,sgBeacon_bssid         ;dst ; get BSSID
 bl   arm7_Wifi_CopyMacAddr             ;/
;- - -
 mov  r0,r4     ;beacon info                    ;\
 add  r1,r5,16  ;frame body, after EVENT hdr(16);
 subs r2,r6,16  ;frame len                      ;
 blhi arm7_parse_beacon_or_probe_response       ;/
;- - -
 add  sp,sgBeacon_size  ;dealloc
 pop  r4-r7
 b    @@event_back
;--- --- ---
@@scan_complete_event:
 ldr  r3,=ath_await_scan_complete       ;\
 mov  r0,0                              ; mark scan completed
 strb r0,[r3]                           ;/
 cmp  r2,4      ;param.len              ;\
 bne  @@unknown                         ;/
 ldr  r0,[r1]                           ;\
 cmp  r0,0      ;whatever status        ; verify whatever param
  cmpne r0,10h  ;whatever OTHER status
 bne  @@unknown                         ;/
 b    @@event_back
;---
@@unknown:
        bl  wrcrlf
        ldr  r1,=ath_lookahead_value     ;\
        ldr  r0,[r1]                     ;/
        bl   wrhex32bit

        mov  r1,r4              ;XXX throw warning
        mov  r2,0
        bl  wrcrlf
       @@error_ylop:
        bl  wrcrlf
       @@error_xlop:
        ldrb r0,[r1],1
        bl   wrhex8bit
        bl   wrspc
        add  r2,1
        tst  r2,7
        bne  @@error_xlop
        cmp  r2,8*8
        bne  @@error_ylop
        bl  wrcrlf
        bl  wrcrlf
       ;- - -
        ldrb r2,[r4,04h] ;xtra.len
        cmp   r2,00h
        cmpne r2,0ffh
        beq  @@no_xtra
        ldrh r0,[r4,02h] ;total.len
        add  r0,6        ;total+6
        sub  r0,r2       ;total-xtra
        add  r1,r4,r0    ;total+base
       @@error_xtralop:
        ldrb r0,[r1],1
        bl   wrhex8bit
        bl   wrspc
        subs r2,1        ;xtra.len
        bne  @@error_xtralop
        bl  wrcrlf
       @@no_xtra:

        b   $

 b    @@poll_mbox_lop                   ;-try poll more
;------------------
.pool
;------------------
WMI_CONNECT_CMD                         equ 0001h
WMI_DISCONNECT_CMD                      equ 0003h
WMI_SYNCHRONIZE_CMD                     equ 0004h
WMI_CREATE_PSTREAM_CMD                  equ 0005h
WMI_START_SCAN_CMD                      equ 0007h
WMI_SET_SCAN_PARAMS_CMD                 equ 0008h
WMI_SET_BSS_FILTER_CMD                  equ 0009h
WMI_SET_PROBED_SSID_CMD                 equ 000Ah
WMI_SET_DISCONNECT_TIMEOUT_CMD          equ 000Dh
WMI_GET_CHANNEL_LIST_CMD                equ 000Eh
WMI_SET_CHANNEL_PARAMS_CMD              equ 0011h
WMI_SET_POWER_MODE_CMD                  equ 0012h
WMI_ADD_CIPHER_KEY_CMD                  equ 0016h
WMI_DELETE_CIPHER_KEY_CMD               equ 0017h
WMI_TARGET_ERROR_REPORT_BITMASK_CMD     equ 0022h
WMI_EXTENSION_CMD                       equ 002Eh  ;prefix for WMIX commands
WMI_SET_WSC_STATUS_CMD                  equ 0041h
WMI_SET_FRAMERATES_CMD                  equ 0047h
WMI_SET_AP_PS_CMD                       equ 0048h
WMI_SET_KEEPALIVE_CMD                   equ 003Dh
WMI_SET_BITRATE_CMD                     equ 0F000h
WMIX_HB_CHALLENGE_RESP_CMD              equ 00002008h   ;XXX

WMIX_DBGLOG_CFG_MODULE_CMD              equ 00002009h
;---
WMI_GET_CHANNEL_LIST_REPLY              equ 000Eh
WMI_READY_EVENT                         equ 1001h ;(for BMI completion)
WMI_CONNECT_EVENT                       equ 1002h
;WMI_DISCONNECT_EVENT                    equ 1003h  ;<-- occurs after CONNECT_CMD (when bad params?)
WMI_BSSINFO_EVENT                       equ 1004h
WMI_CMDERROR_EVENT                      equ 1005h
WMI_REGDOMAIN_EVENT                     equ 1006h ;(for BMI completion)
WMI_PSTREAM_TIMEOUT_EVENT               equ 1007h
WMI_NEIGHBOR_REPORT_EVENT               equ 1008h
WMI_SCAN_COMPLETE_EVENT                 equ 100Ah
WMI_ERROR_REPORT_EVENT                  equ 100Dh
WMI_EXTENSION_EVENT                     equ 1010h ;prefix for WMIX events
WMIX_HB_CHALLENGE_RESP_EVENT            equ 00003007h
WMIX_DBGLOG_EVENT                       equ 00003008h
;------------------
ath_error_report_cmd:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_TARGET_ERROR_REPORT_BITMASK_CMD
 dd 0000007Fh   ;bitmask
@@end:
.align 4
;------------------
ath_set_framerates_cmd:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_SET_FRAMERATES_CMD
 db 02h         ;bEnableMask              ;=?
 db 00h         ;frameType                ;=?
 dw 0000h       ;frameRateMask (0..FFFh)  ;=all off?
@@end:
.align 4
;------------------
ath_get_channels_cmd:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_GET_CHANNEL_LIST_CMD
 ;(no parameters)
@@end:
.align 4
;------------------
ath_start_scan_cmd:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_START_SCAN_CMD
 dd 0           ; 00h  A_BOOL   4   forceFgScan
 dd 0           ; 04h  A_BOOL   4   isLegacy            For Legacy Cisco AP compatibility
 dd 14h   ;?    ; 08h  A_UINT32 4   homeDwellTime       Max duration in the home channel (msec)
 dd 0           ; 0Ch  A_UINT32 4   forceScanInterval   Time interval between scans (msec)
 db 0           ; 10h  A_UINT8  1   scanType            WMI_SCAN_TYPE
 db 0           ; 11h  A_UINT8  1   numChannels         how many channels follow
 dw 0     ;?    ; 12h  A_UINT16 N*2 channelList[1]      channels in MHz
@@end:
.align 4
;------------------
ath_set_scan_params_cmd:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_SET_SCAN_PARAMS_CMD
 dw 0ffffh      ;00h  A_UINT16 2  fg_start_period         ;seconds
 dw 0ffffh      ;02h  A_UINT16 2  fg_end_period           ;seconds
 dw 0ffffh      ;04h  A_UINT16 2  bg_period               ;seconds
 dw 006fh  ;MOD ;06h  A_UINT16 2  maxact_chdwell_time     ;msec
 dw 006fh  ;MOD ;08h  A_UINT16 2  pas_chdwell_time        ;msec
 db 00h         ;0Ah  A_UINT8  1  shortScanRatio          ;how many shorts scan for one long
 db 01h    ;MOD ;0Bh  A_UINT8  1  scanCtrlFlags (5bits used) (bit0=scan in CONNECT cmd, why?)
 dw 006fh  ;MOD ;0Ch  A_UINT16 2  minact_chdwell_time     ;msec
 dw 0000h       ;0Eh  A_UINT16 2  maxact_scan_per_ssid    ;max active scans per ssid
 dd 00000000h   ;10h  A_UINT32 4  max_dfsch_act_time      ;msec
@@end:
.align 4
;------------------
ath_set_channel_params_cmd:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_SET_CHANNEL_PARAMS_CMD
 db 00h         ;00h reserved
 db 00h         ;01h scanParam     ;set if enable scan (off, or still off?)
 db 02h         ;02h phyMode       ;see WMI_PHY_MODE (2=11G)
 db 01h         ;03h numChannels   ;how many channels follow (one)
 dw 096Ch  ;MOD ;04h channelList   ;channel(s) in MHz (96Ch=ch1)  ;max 32 channels
@@end:
.align 4
;------------------
ath_set_probed_ssid_cmd:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_SET_PROBED_SSID_CMD
 db 00h         ;entryIndex (0 to MAX_PROBED_SSID_INDEX) (aka 0..15)
 db 00h         ;flag (0,1,2) (0=disables entry, 1=specific ssid, 2=any ssid)
 db 00h         ;ssidLength        ;XXX weird, above SHOULD be flag=02h, but isn't?!
 defs 20h       ;ssid[32]
@@end:
.align 4
;------------------
ath_set_bss_filter_cmd_0:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_SET_BSS_FILTER_CMD
 db 00h         ;bssFilter             ;<-- CLEAR (00h=No beacons forwarded)
 db 0,0,0       ;reserved/alignment
 dd 0           ;ieMask
@@end:
.align 4
;------------------
ath_set_bss_filter_cmd_1:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_SET_BSS_FILTER_CMD
 db 01h         ;bssFilter             ;<-- SET (01h=All beacons forwarded)
 db 0,0,0       ;reserved/alignment
 dd 0           ;ieMask
@@end:
.align 4
;------------------
ath_set_bss_filter_cmd_4:
@@begin:
 db 01h,01h // dw @@end-@@begin-6 // dw 0000h // dw WMI_SET_BSS_FILTER_CMD
 db 04h         ;bssFilter             ;<-- (04h=current BSS beacon forwarded)
 db 0,0,0       ;reserved/alignment
 dd 0           ;ieMask
@@end:
.align 4
;---
;  NONE_BSS_FILTER        = 00h  ;no beacons forwarded
;  ALL_BSS_FILTER         = 01h  ;all beacons forwarded
;  PROFILE_FILTER         = 02h  ;only beacons matching profile
;  ALL_BUT_PROFILE_FILTER = 03h  ;all but beacons matching profile
;  CURRENT_BSS_FILTER     = 04h  ;only beacons matching current BSS
;  ALL_BUT_BSS_FILTER     = 05h  ;all but beacons matching BSS
;  PROBED_SSID_FILTER     = 06h  ;beacons matching probed ssid
;  LAST_BSS_FILTER        = 07h  ;marker only
;------------------
.if with_nds_wifi=0  ;<-- if so, always redirect (else use conditional redirect)
  arm7_Wifi_Update        equ dsi7_Wifi_Update
  arm7_Wifi_Deinit        equ dsi7_Wifi_Deinit
  arm7_wifiValue32Handler equ dsi7_wifiValue32Handler
.endif
;------------------
;:----------------- NDS7 Bootcode RTC
;------------------
;;;.if with_rtc_init
;------------------
wait_r0_us:
 mov  r0,r0,lsl 5-2     ;mul 32 (32MHz clk), div 4 (four cycles per loop)
 swi  swi_wait_by_loop  ;wait r0*4 cycles at 32MHz memory-clock
 bx   lr
;------------------
nds7_rtc_select:
 push r0-r1,lr
 mov  r1,4000000h
 mov  r0,73h                    ;\CS=Off, CLK=Hi, DTA=Hi, Dir=Write
 strb r0,[r1,REG_RTC_CNT]       ;/
 mov  r0,1  ;1us                ;\wait 1us
 bl   wait_r0_us                ;/
 mov  r0,73h+4                  ;\CS=On
 strb r0,[r1,REG_RTC_CNT]       ;/
 pop  r0-r1,pc
;------------------
nds7_rtc_deselect:
 push r0-r1,lr
 mov  r1,4000000h
 mov  r0,73h                    ;\CS=Off, CLK=Hi, DTA=Hi, Dir=Write
 strb r0,[r1,REG_RTC_CNT]       ;/
 pop  r0-r1,pc
;------------------
nds7_rtc_send_byte_r0:
 push r1-r5,lr
 mov  r5,74h            ; CS=On, CLK=Low, DTA=Dta, Dir=Write
 b    nds7_rtc_getsend_inj
;- - - - ----------
nds7_rtc_get_byte_r0:
 push r1-r5,lr
 mov  r5,64h            ; CS=On, CLK=Low, DTA=Dta, Dir=Read
;- - - - - - ------
nds7_rtc_getsend_inj:
 mov  r4,4000000h
 mov  r2,8
 and  r3,r0,0ffh
@@lop:
 movs r3,r3,lsr 1               ;\
 adc  r1,r5,0  ;cy=dta          ; CLK=Lo, DTA=Dta_out
 strb r1,[r4,REG_RTC_CNT]       ;/
 mov  r0,5  ;5us                ;\wait 5us
 bl   wait_r0_us                ;/
 orr  r1,02h                    ;\CLK=Hi, other=same
 strb r1,[r4,REG_RTC_CNT]       ;/
 mov  r0,5  ;5us                ;\wait 5us
 bl   wait_r0_us                ;/
 ldrb r0,[r4,REG_RTC_CNT]       ;\Read Dta_in
 orr  r3,r3,r0,lsl 31           ;/
 subs r2,1
 bne  @@lop
 mov  r0,r3,lsr 24              ;-return value (for read)
 pop  r1-r5,pc
;------------------
nds7_rtc_get_params:  ;in: r0=index, r1=dest, r2=len
 push r0-r2,lr
 bl   nds7_rtc_select           ;-begin
 mov  r0,r0,lsl 4               ;\
 orr  r0,80h+06h ;read+idcode   ; send read command, index, idcode
 bl   nds7_rtc_send_byte_r0     ;/
@@lop:                          ;\
 bl   nds7_rtc_get_byte_r0      ;
 strb r0,[r1],1                 ; data block
 subs r2,1                      ;
 bne  @@lop                     ;/
 bl   nds7_rtc_deselect         ;-finish
 pop  r0-r2,pc
;------------------
;nds7_rtc_set_params:  ;in: r0=index1byte/data3byte, r2=len
; push r0-r2,lr
; bl   nds7_rtc_select           ;-begin
; mov  r0,r0,ror 24
; push r0
; mov  r0,r0,lsl 4               ;\
; orr  r0,00h+06h ;write+idcode  ; send write command, index, idcode
; bl   nds7_rtc_send_byte_r0     ;/
; pop  r0
;@@lop:                          ;\
; mov  r0,r0,ror 24
; push r0
; bl   nds7_rtc_send_byte_r0     ; data block
; pop  r0
; subs r2,1                      ;
; bne  @@lop                     ;/
; bl   nds7_rtc_deselect         ;-finish
; pop  r0-r2,pc
;------------------
;nds7_rtc_set_params_r1:  ;in: r0=index, r1=params, r2=len
; push r0-r2,lr
; bl   nds7_rtc_select           ;-begin
; mov  r0,r0,lsl 4               ;\
; orr  r0,00h+06h ;write+idcode  ; send write command, index, idcode
; bl   nds7_rtc_send_byte_r0     ;/
;@@lop:                          ;\
; ldrb r0,[r1],1                 ;
; bl   nds7_rtc_send_byte_r0     ; data block
; subs r2,1                      ;
; bne  @@lop                     ;/
; bl   nds7_rtc_deselect         ;-finish
; pop  r0-r2,pc
;------------------
nds7_read_rtc_time_date:
 push lr
;; ldr   r1,=23fee00h                     ;\
;; ldrb  r0,[r1,xset_cent] ;century       ;
;; bl    make_bcd                         ;
;; strb  r0,[rtc_datetime+0]              ;/
 mov  r0,02h ;index                     ;\
 ldr  r1,=rtc_datetime+1                ;
 mov  r2,7   ;len                       ;
 bl   nds7_rtc_get_params               ;/
 pop  pc
;------------------
;;;.endif ;with_rtc_init
;------------------
get_random_bytes:   ;in: r0=dst, r1=size
 push r4-r7,lr
 sub  sp,@@alloc
@@struct equ 00h   ;64h
@@sha1   equ 64h   ;14h
@@alloc  equ 78h   ;total
 mov  r6,r0     ;dst
 mov  r7,r1     ;len
 bl   nds7_read_rtc_time_date   ;-get current RTC date/time
 ldr  r1,=random_count          ;\
 ldr  r0,[r1]                   ; raise random count
 add  r0,1                      ; (for each new random value)
 str  r0,[r1]                   ;/
;- - -
 add  r0,sp,@@struct    ;\      ;\
 bl   md5sha1_init      ;/      ;
 ldr  r4,=@@random_seed_list    ;
@@collect_seed_lop:             ;
 add  r0,sp,@@struct    ;\      ; calc SHA1 on random sources
 ldr  r1,[r4],4  ;src   ;       ;
 ldr  r2,[r4],4  ;len   ;       ;
 bl   md5sha1_update    ;/      ;
 ldr  r0,[r4]    ;src   ;\      ;
 cmp  r0,0              ;       ;
 bne  @@collect_seed_lop;/      ;
 add  r0,sp,@@sha1 ;dst ;\      ;
 add  r1,sp,@@struct    ;       ;
 bl   md5sha1_finish    ;/      ;/
;- - -
 add  r0,sp,@@sha1 ;src ;\src=from above SHA1 random collection ;\
 mov  r1,14h       ;len ;/                                      ;
 ldr  r2,=@@key         ;\key=dummy                             ; calc random
 mov  r3,@@keylen       ;/                                      ; (expand SHA1
 mov  r4,r6  ;dst       ;\dst                                   ; to dstlen)
 mov  r5,r7  ;dstlen    ;/                                      ;
 mov  r6,1              ;-numrounds=1                           ;
 bl   wifi_calc_prf     ;---> calc PTK                          ;/
 add  sp,@@alloc
 pop  r4-r7,pc
;---
@@key       db 'Key'
@@keylen    equ $-@@key
;;;@@prefix    db 'Randomizer'
;;;@@prefixlen equ $-@@prefix
.align 4
@@random_seed_list:
 dd rtc_datetime     ,8                               ;-RTC date/time
 dd vblank_count     ,4                               ;-count (per vblank)
 dd random_count     ,4                               ;-count (per get random)
 dd 2FFD7BCh         ,10h                             ;-DSi: eMMC CID
 dd 2FFFC3Ch         ,4                               ;-Boot Frame Counter
 dd 2FFFC80h         ,70h                             ;-User Settings
 dd 2FFFD70h         ,10h                             ;-DSi: Console Barcode
 dd 2FFFDE8h         ,8                               ;-Boot RTC
 dd WifiData_MacAddr ,6                               ;-Wifi FLASH mac addr
 dd WifiData_aplist  ,sgWifiAp_size*WIFI_MAX_AP       ;-Wifi SCAN access points with RSSI's
 dd WifiData_wfc_ap  ,sgWifiWfc_size*NUM_WFC_ENTRIES  ;-Wifi FLASH access points
 ;XXX could get DSi Console ID
 ;XXX could get WMI_GET_STATISTISCS after SCAN
 ;XXX could get wifi event/data/ack RX timings
 ;XXX could get uninit ram, or emmc fat, or even microphone/camera inputs
 dd 0
;------------------
.pool
;------------------
;:----------------- DSi cypto
;------------------
pairwise_prefix    db 'Pairwise key expansion',00h                    ;\constant
pairwise_prefixlen equ $-pairwise_prefix ;22+1 (including ending 00h) ;/
pmkid_prefix       db 'PMK Name'                                      ;\constant
pmkid_prefixlen    equ $-pmkid_prefix    ;8                           ;/
.align 4
;------------------
wifi_calc_prf:          ;in: r0..r6
 push r4-r12,lr
 sub  sp,@@alloc_size
@@tmp_src    equ 00h  ;14h ;
@@tmp_dst    equ 14h  ;14h ;
@@tmp_sum    equ 28h  ;14h ;xor-sum
@@alloc_size equ 3Ch
 mov  r8,r0   ;src         ;\src, eg. "ssid"
 mov  r9,r1   ;srclen      ;/
 mov  r10,r2  ;key         ;\key, eg. "password"
 mov  r11,r3  ;keylen      ;/
 mov  r12,r4  ;dst         ;\dst, eg. PSK (32 bytes)
;mov  r5,r5   ;dstlen      ;/
;mov  r6,r6   ;numrounds   ;-numrounds, eg. 1 or 4096
;- - -
@@dst_lop:
 mov  r0,r8  ;src       ;\src=src       ;\
 mov  r1,r9  ;srclen    ;/              ;
 mov  r2,r10 ;key       ;\key=key       ; calc 1st HMAC
 mov  r3,r11 ;keylen    ;/              ;
 add  r4,sp,@@tmp_src   ;-dst=tmpsrc    ;
 bl   calc_hmac_md5sha1                 ;
 mov  r4,r0  ;10h/14h   ;tmplen         ;/
 add  r0,sp,@@tmp_src                   ;\
 add  r1,sp,@@tmp_sum                   ; copy to tmpsum
 mov  r2,r4  ;10h/14h   ;tmplen         ;
 bl   memcopy_bytewise                  ;/
;- - -
 subs r7,r6,1  ;repeat=numrounds-1
 beq  @@repeat_done
@@repeat_lop:
 add  r0,sp,@@tmp_src   ;\src=tmpsrc    ;\
 mov  r1,r4  ;10h/14h   ;/    tmplen    ; calc further HMAC's
 mov  r2,r10 ;key       ;\key=key       ;   ;XXX repeat's could be made twice as fast by re-using the SHA1-state from "SHA1init+SHA1update(keyXorNN)")
 mov  r3,r11 ;keylen    ;/              ;
 add  r4,sp,@@tmp_dst   ;-dst           ;
 bl   calc_hmac_md5sha1                 ;
 mov  r4,r0  ;10h/14h   ;tmplen         ;/
 mov  r2,r4   ;tmplen                   ;\
 mov  r3,sp   ;sp+index(0)              ;
@@xor_lop:                              ;
 ldr  r0,[r3,@@tmp_dst]                 ; xor tmp_sum by tmp_dst
 ldr  r1,[r3,@@tmp_sum]                 ; and
 str  r0,[r3,@@tmp_src]                 ; copy tmp_dst back to tmp_src
 xor  r0,r1                             ;
 str  r0,[r3,@@tmp_sum]                 ;
 add  r3,4    ;sp+index(N)              ;
 subs r2,4                              ;
 bne  @@xor_lop                         ;/
 subs r7,1                              ;\
 bne  @@repeat_lop                      ;/
@@repeat_done:
;- - -
 add  r3,r8,r9  ;src+srclen             ;\
 ldrb r0,[r3,-1]  ;count.[addr]         ; raise last byte of src
 add  r0,1        ;count.value+1        ;
 strb r0,[r3,-1]  ;count.[addr]         ;/
 add  r0,sp,@@tmp_sum   ;src=tmpsum     ;\
 mov  r1,r12            ;dst=dst        ;
 mov  r2,r5             ;dstlen         ; copy tmpsum to dst
 cmp   r2,r4  ;10h/14h  ;dstlen,tmplen  ;
 movhi r2,r4  ;10h/14h  ;dstlen,tmplen  ;
 bl   memcopy_bytewise                  ;/
 sub  r0,r1,r12 ;len copied dst(new-old)
 add  r12,r0  ;10h/14h  ;dst
 subs r5,r0   ;10h/14h  ;dstlen
 bhi  @@dst_lop
;- - -
 add  sp,@@alloc_size
 pop  r4-r12,pc
;------------------
.if with_gimmicks  ;not needed, because it's already in Wifi-FLASH
  wifi_calc_psk:
   push r4-r12,lr
   sub  sp,20h+4  ;alloc SSID(max32)+4
   mov  r1,sp                   ;dst      ;\
   ldr  r0,=WifiData_ssid7      ;ssid     ;
   ldrb r2,[r0],1  ;byte[0]=len ;ssidlen  ;
   bl   memcopy_bytewise                  ;
   mov  r0,00h                            ; create src (ssid, 00h,00h,00h,01h)
   strb r0,[r1],1                         ;
   strb r0,[r1],1                         ;
   strb r0,[r1],1                         ;
   mov  r0,01h                            ;
   strb r0,[r1],1                         ;/
   mov  r0,sp               ;\src         ;\
   sub  r1,sp  ;=ssidlen+4  ;/            ;
   ldr  r2,xxx password     ;\key         ;
   mov  r3,xxx passwordlen  ;/            ; calc PSK
   ldr  r4,=WifiData_psk7   ;\dst         ;
   mov  r5,20h ;dstlen      ;/            ;
   mov  r6,4096 ;numrounds  ;-            ;    ;<-- this is SLOW
   bl   wifi_calc_prf     ;--->           ;/
   add  sp,20h+4  ;dealloc SSID(max32)+4
   pop  r4-r12,pc
.endif
;------------------
.if with_gimmicks
  wifi_calc_pmkid:
   push r4-r12,lr
   sub  sp,@@alloc_size
  @@tmp_src    equ 00h  ;14h ;8+6+6 (prefix+BSSID+MAC)
  @@tmp_dst    equ 14h  ;14h ;14h (sha1)
  @@alloc_size equ 28h
   add  r1,sp,@@tmp_src         ;-        ;\
   ldr  r0,=pmkid_prefix        ;\        ;
   mov  r2,pmkid_prefixlen      ; prefix  ;
   bl   memcopy_bytewise        ;/        ; create src (prefix+BSSID+MAC)
   ldr  r0,=WifiData_bssid7     ;\BSSID   ;
   bl   arm7_Wifi_CopyMacAddr   ;/        ;
   ldr  r0,=WifiData_MacAddr    ;\MAC     ;
   bl   arm7_Wifi_CopyMacAddr   ;/        ;/
   add  r0,sp,@@tmp_src   ;\src=txt+MAC's ;\
   mov  r1,8+6+6  ;srclen ;/              ;
   ldr  r2,=WifiData_psk7 ;\key=PMKakaPSK ; calc SHA1-HMAC on src
   mov  r3,32  ;psklen    ;/              ; with key=PMK (aka PSK)
   add  r4,sp,@@tmp_dst                   ;
   bl   calc_hmac_md5sha1                 ;/
  ;add  r0,sp,@@tmp_dst                   ;\
  ;add  r1,sp,WifiData_pmkid              ; copy to ...
  ;mov  r2,10h  ;only 1st 10h of 14h      ; (actually not needed anywhere)
  ;bl   memcopy_bytewise                  ;/
   add  sp,@@alloc_size
   pop  r4-r12,pc
.endif
;------------------
wifi_rc4_crypt:    ;in: r0-r5
 push r4-r12,lr
 sub  sp,100h   ;alloc sbox
 mov  r10,r0    ;src
 mov  r11,r1    ;dst
 add  r12,r2,r5 ;len + preskip
;mov  r3,r3     ;key
;mov  r4,r4     ;keylen
;mov  r5,r5     ;preskip
;- - -
 mov  r0,sp             ;sbox           ;\
 ldr  r1,=03020100h     ;i              ;
 ldr  r2,=04040404h     ;step           ;
@@init_lop:                             ; clear sbox
 str  r1,[r0],4         ;sbox[i]        ;
 adds r1,r2             ;i+step         ;
 bcc  @@init_lop                        ;/
;- - -
 mov  r8,00h shl 24     ;i=0            ;\
 mov  r9,00h shl 24     ;j=0            ;
 mov  r2,0              ;k=0            ;
@@shuffle_lop:                          ;
 ldrb r0,[r3,r2]        ;key[k]         ;
 ldrb r1,[sp,r8,lsr 24] ;sbox[i]        ; apply key to sbox
 add  r9,r9,r0,lsl 24   ;j+r0           ;
 add  r9,r9,r1,lsl 24   ;j+r1           ;
 ldrb r0,[sp,r9,lsr 24] ;sbox[j] ;\     ;
 strb r1,[sp,r9,lsr 24] ;sbox[j] ; swap ;
 strb r0,[sp,r8,lsr 24] ;sbox[i] ;/     ;
 add  r2,1              ;\              ;
 cmp  r2,r4  ;keylen    ; k+1           ;
 moveq r2,0             ;/              ;
 adds r8,01h shl 24     ;\i+1           ;
 bcc  @@shuffle_lop     ;/              ;/
;- - -
;mov  r8,00h shl 24     ;i=0            ;\
 mov  r9,00h shl 24     ;j=0            ;
@@crypt_lop:                            ;
 add  r8,01h shl 24     ;i+1            ;
 ldrb r0,[sp,r8,lsr 24] ;sbox[i] ;\     ; crypt
 add  r9,r9,r0,lsl 24   ;j+r0    ;/     ;
 ldrb r1,[sp,r9,lsr 24] ;sbox[j] ;\     ;
 strb r0,[sp,r9,lsr 24] ;sbox[j] ; swap ;
 strb r1,[sp,r8,lsr 24] ;sbox[i] ;/     ;
 add  r0,r1                      ;\     ;
 and  r0,0ffh                    ;      ;
 ldrb r0,[sp,r0]        ;sbox[x] ;/     ;
 subs r5,1   ;preskip                   ;
 ldrmib r1,[r10],1  ;src  ;\            ;
 eormi  r1,r0             ; crypt       ;
 strmib r1,[r11],1  ;dst  ;/            ;
 subs r12,1       ;len                  ;
 bhi  @@crypt_lop                       ;/
;- - -
 add  sp,100h   ;dealloc sbox
 pop  r4-r12,pc
;------------------
sha1_callback_core:   ;in: r0=struct, r1=src, r2=len
 ;this is more compact, but slightly less efficient than the unrolled function
 ;in DSi bios (and MUCH slower than BIOS when executing in Main RAM).
 ;anyways, the advantage is that this is also working on NDS, without DSi bios
 push r0-r12,lr
 mov  r10,r0    ;struct
 mov  r11,r1    ;src
 mov  r12,r2    ;len
 sub  sp,80*4   ;alloc w[80]
;- - -
 ldmia [r10],r0-r4      ;-get curr SHA1 value (a,b,c,d,e)
@@block_lop:
 mov  r6,sp     ;start at w[0]                  ;-
 ldr  r5,=05A827999h                            ;\
 ldr  r9,=00ff00ffh  ;for bswap                 ;
@@lop1a:                                        ;
 ldr  r8,[r11],4 ;src ;r8=aabbccdd ;-src        ;
 and  r7,r9,r8           ;00bb00dd ;\           ; part 1a
 and  r8,r9,r8,ror 24    ;00cc00aa ; bswap      ;
 orr  r8,r8,r7,ror 8     ;ddccbbaa ;/           ;
 eor  r7,r2,r3  ;C xor D           ;\           ;
 and  r7,r1     ;and B             ; mangle     ;
 eor  r7,r3     ;xor D             ;/           ;
 bl   @@subfunc_injump1a           ;-           ;
 cmp  r8,16*4                                   ;
 bne  @@lop1a                                   ;/
;ldr  r5,=05A827999h                            ;\
@@lop1b:                                        ;
 eor  r7,r2,r3  ;C xor D           ;\           ;
 and  r7,r1     ;and B             ; mangle     ; part 1b
 eor  r7,r3     ;xor D             ;/           ;
 bl   @@subfunc_injump1b           ;-           ;
 cmp  r8,20*4                                   ;
 bne  @@lop1b                                   ;/
 ldr  r5,=06ED9EBA1h                            ;\
@@lop2:                                         ;
 bl   @@subfunc                    ;-           ; part 2
 cmp  r8,40*4                                   ;
 bne  @@lop2                                    ;/
 ldr  r5,=08F1BBCDCh                            ;\
@@lop3:                                         ;
 and  r8,r1,r2  ;B and C           ;\           ;
 orr  r7,r1,r2  ;B or C            ; mangle     ; part 3
 and  r7,r3     ;and D             ;            ;
 orr  r7,r8     ;or r8             ;/           ;
 bl   @@subfunc_injump3            ;-           ;
 cmp  r8,60*4                                   ;
 bne  @@lop3                                    ;/
 ldr  r5,=0CA62C1D6h                            ;\
@@lop4:                                         ;
 bl   @@subfunc                    ;-           ; part 4
 cmp  r8,80*4                                   ;
 bne  @@lop4                                    ;/
;- - -
 ldmia [r10],r5-r9 ;old SHA1 value (a,b,c,d,e)  ;\
 add  r0,r5                                     ;
 add  r1,r6                                     ;
 add  r2,r7                                     ; update SHA1 value
 add  r3,r8                                     ;
 add  r4,r9                                     ;
 stmia [r10],r0-r4 ;new SHA1 value (a,b,c,d,e)  ;/
 subs r12,40h                                   ;\next chunk (if any)
 bhi  @@block_lop                               ;/
 add  sp,80*4   ;dealloc w[80]
 pop  r0-r12,lr
 bx   lr        ;<-- ret with THUMB bit (needed when used as callback for DSi BIOS SWI function)
;---
@@subfunc:
 eor  r7,r1,r2  ;B xor C           ;\mangle
 eor  r7,r3     ;xor D             ;/
@@subfunc_injump1b:
@@subfunc_injump3:
 ldr  r8,[r6,-3*4]                      ;\
 ldr  r9,[r6,-8*4]                      ;
 eor  r8,r9                             ;
 ldr  r9,[r6,-14*4]                     ; w[i]=(w[i-3] xor w[i-8] xor w[i-14] xor w[i-16]) rol 1
 eor  r8,r9                             ;
 ldr  r9,[r6,-16*4]                     ;
 eor  r8,r9                             ;
 mov  r8,r8,ror (32-1)                  ;/
@@subfunc_injump1a:
 str  r8,[r6],4                         ;-store w[i]
 add  r7,r8            ;add w[i]        ;\
 add  r7,r4            ;add e           ;
 add  r7,r7,r0,ror 27  ;add (a rol 5)   ;/
 mov  r4,r3        ;new.e = old.d       ;\
 mov  r3,r2        ;new.d = old.c       ;
 mov  r2,r1,ror 2  ;new.c = old.b ror 2 ;
 mov  r1,r0        ;new.b = old.a       ;
 add  r0,r7,r5     ;new.a = tmp+const   ;/
 sub  r8,r6,sp  ;return index (i*4)
 bx   lr
;------------------
md5sha1_init:  ;in: r0=struct
 .if use_dsi_bios
   ldr  r3,=wifi_md5sha1_mode
   ldrb r3,[r3]
   cmp  r3,0
   ldreq r3,=md5_callback_core  ;callback ;\
  ;ldrne r3,=sha1_callback_core ;callback ;
   movne r3,0  ;dsi-bios-sha1   ;callback ;
   str   r3,[r0,60h]    ;struct[60h]      ;/
   swi  swi_sha1_init
   bx   lr
 .else
   push  r4-r8,lr
   ldr   r8,=@@src                      ;\
   ldmia [r8],r1-r7                     ; initial constants and initial
   stmia [r0],r1-r7                     ; length and fragment size
   str   r7,[r0,5ch] ;=0                ;/
   ldr   r3,=wifi_md5sha1_mode          ;\
   ldrb  r3,[r3]                        ;
   cmp   r3,0                           ; callback (MD5 or SHA1)
   ldreq r3,=md5_callback_core          ;
   ldrne r3,=sha1_callback_core         ;
   str   r3,[r0,60h]                    ;/
   pop   r4-r8,pc
  ;---
  @@src:
   dd 067452301h ;\MD5   ;[struct+00h]      ;\
   dd 0EFCDAB89h ; and   ;[struct+04h]      ;
   dd 098BADCFEh ; SHA1  ;[struct+08h]      ; initial SHA1 checksum value
   dd 010325476h ;/      ;[struct+0ch]      ;
   dd 0C3D2E1F0h ;-SHA1  ;[struct+10h]      ;/
   dd 000000000h         ;[struct+14h] ;lsw ;\total len in bits, initially zero
   dd 000000000h         ;[struct+18h] ;msw ;/
   dd 000000000h         ;[struct+5Ch]      ;-incomplete fragment size
   dd md5_callback_core  ;[struct+60h] ;md5 ;\
   dd sha1_callback_core ;[struct+60h] ;sha ;/
 .endif
;------------------
md5sha1_update:  ;in: r0=struct, r1=src, r2=len
 .if use_dsi_bios
   swi  swi_sha1_update
   bx   lr
 .else
   push r4-r7,lr
   mov  r4,r0     ;struct
   mov  r5,r1     ;src
   mov  r6,r2     ;len
   ;- - -
   ldr  r0,[r4,14h]   ;lsw                ;\
   ldr  r1,[r4,18h]   ;msw                ;
   adds r0,r0,r6,lsl 3  ;lsw+len*8        ; raise total len in bits
   adc  r1,r1,r6,lsr 29 ;msw+len/x+cy     ;
   str  r0,[r4,14h]   ;lsw                ;
   str  r1,[r4,18h]   ;msw                ;/
   ;- - - process any OLD incomplete chunk ...
   ldr  r7,[r4,5ch]   ;fract.len          ;\
   cmp  r7,0          ;oldlen             ; check if there is an old
   beq  @@do_not_emit_old_chunk           ; incomplete chunk, and if
   add  r0,r7,r6      ;oldlen+newlen      ; there's enough new data
   cmp  r0,40h  ;check if full chunk      ; to make it a full chunk
   blo  @@do_not_emit_old_chunk           ;/
   mov  r0,r5         ;src                ;\ ;\
   add  r1,r4,1ch     ;chunkbuf           ;  ; append new data to old
   add  r1,r7         ;chunkbuf+oldlen    ;  ; incomplete chunk,
   rsb  r2,r7,40h     ;40h-oldlen         ;  ; making it a full chunk
   add  r5,r2         ;adjust newsrc      ;  ;
   sub  r6,r2         ;adjust newlen      ;  ;
   bl   memcopy_bytewise                  ;  ;/
   mov  r0,r4         ;struct             ;  ;\
   add  r1,r4,1ch+0   ;src=chunkbuf       ;  ; emit that chunk
   mov  r2,40h        ;len=40h            ;  ;
   bl   @@sha1_callback                   ;  ;/
   mov  r7,0          ;fract.len          ;/ ;-mark no incomplete chunk
  @@do_not_emit_old_chunk:
   ;- - - process FULL chunks ...
   cmp  r6,40h                            ;\
   blo  @@do_not_emit_full_chunks         ;
   tst  r5,3          ;src/align          ;
   beq  @@emit_aligned_full_chunks        ;
  @@emit_unaligned_full_chunks_lop:       ; ;\
   mov  r0,r5         ;src                ; ;  ;\
   add  r1,r4,1ch     ;chunkbuf           ; ;  ; copy unaligned data to chunkbuf
   mov  r2,40h        ;len                ; ;  ;
   add  r5,r2         ;adjust newsrc      ; ;  ;
   sub  r6,r2         ;adjust newlen      ; ;  ;
   bl   memcopy_bytewise                  ; ;  ;/
   mov  r0,r4         ;struct             ; ;  ;\
   add  r1,r4,1ch+0   ;src=chunkbuf       ; ;  ; emit that chunk
   mov  r2,40h        ;len=40h            ; ;  ;
   bl   @@sha1_callback                   ; ;  ;/
   cmp  r6,40h                            ; ;
   bhs  @@emit_unaligned_full_chunks_lop  ; ;/
  @@emit_aligned_full_chunks:             ;
   mov  r0,r4         ;struct             ; ;\
   mov  r1,r5         ;src                ; ;
   bics r2,r6,3fh     ;len                ; ; emit aligned full chunk(s)
   add  r5,r2         ;adjust newsrc      ; ;
   sub  r6,r2         ;adjust newlen      ; ;
   blne @@sha1_callback                   ; ;/
  @@do_not_emit_full_chunks:              ;/
   ;- - - memorize remaining INCOMPLETE chunk ...
   mov  r0,r5         ;src                        ;\
   add  r1,r4,1ch     ;chunkbuf                   ;
   add  r1,r7         ;chunkbuf+oldlen            ; append remaining bytes to
   mov  r2,r6         ;len remain (if any)        ; incomplete chunk buffer
   add  r7,r2         ;fract.len+remain           ;
   str  r7,[r4,5ch]   ;fract.len                  ;
   bl   memcopy_bytewise                          ;/
  @@do_not_memorize_incomplete_chunk:
   pop  r4-r7,pc
  ;---
  @@sha1_callback:
   ldr  pc,[r4,60h]   ;callback
 .endif
;------------------
md5sha1_finish:  ;in: r0=dst, r1=struct - out: r0=len
 .if use_dsi_bios
   ldr  r3,=wifi_md5sha1_mode
   ldrb r3,[r3]
   cmp  r3,0
   beq  md5_finish        ;--> md5
   swi  swi_sha1_finish   ;\
   mov  r0,14h  ;len      ; sha1
   bx   lr                ;/
 .else
   b    md5_finish   ;use for both sha1/md5
 .endif
;---
wifi_md5sha1_mode       dd 01   ;XXX
;------------------
sha1_init_update_finish:
md5sha1_init_update_finish:   ;in: r0=dst, r1=src, r2=len
md5_init_update_finish:   ;in: r0=dst, r1=src, r2=len
 push r4-r6,lr
 sub  sp,64h    ;alloc struct
 mov  r4,r0     ;dst
 mov  r5,r1     ;src
 mov  r6,r2     ;len
 mov  r0,sp            ;struct          ;\init
 bl   md5sha1_init                      ;/
 mov  r0,sp            ;struct          ;\
 mov  r1,r5            ;src             ; update
 mov  r2,r6            ;len             ;
 bl   md5sha1_update                    ;/
 mov  r0,r4            ;dst             ;\
 mov  r1,sp            ;struct          ; finish
 bl   md5sha1_finish                    ;/
 add  sp,64h    ;dealloc struct
 pop  r4-r6,pc
;------------------
md5_finish:     ;in: r0=dst, r1=struct
 push r4-r6,lr
 sub  sp,1+3fh+8  ;alloc padding buffer
 mov  r4,r0     ;dst
 mov  r5,r1     ;struct
 ldr  r6,[r5,60h] ;callback             ;\
 ldr  r0,=md5_callback_core             ;
 cmp  r6,r0                             ;
 moveq r6,10h ;MD5/len                  ;
 movne r6,14h ;SHA1/len                 ;/
 ldr  r2,[r5,5ch] ;frag                 ;\
 mov  r1,sp                             ;
 mov  r0,80h ;end-byte                  ; append end byte (80h),
@@pad_lop:                              ; and padding byte(s) (00h),
 strb r0,[r1],1                         ; until fragment size becomes 38h
 mov  r0,00h ;pad-bytes                 ; (so 8byte-len can be appended
 add  r2,1    ;\                        ; at fragment[38h..3Fh])
 and  r2,3fh  ; frag                    ;
 cmp  r2,38h  ;/                        ;
 bne  @@pad_lop                         ;/
 ldr  r2,[r5,14h] ;lsw                  ;\
 ldr  r3,[r5,18h] ;msw                  ;
 mov  r0,64                             ;
@@size_lop:                             ;
 cmp  r6,14h              ;-MD5/SHA1    ; append 64bit length in bits
 moveq  r3,r3,ror 24 ;msw ;\            ; for SHA1 --> in BIG-ENDIAN
 streqb r3,[r1],1    ;msb ; SHA1        ; for MD5 --> in LITTLE-ENDIAN
 biceq  r3,0ffh           ; BIG         ;
 orreq  r3,r3,r2,lsr 24   ; ENDIAN      ;
 moveq  r2,r2,lsl 8  ;lsw ;/            ;
 strneb r2,[r1],1         ;\MD5         ;
 movne  r2,r2,lsr 8  ;lsw ; LITTLE      ;
 orrne  r2,r2,r3,lsl 24   ; ENDIAN      ;
 movne  r3,r3,lsr 8  ;msw ;/            ;
 subs r0,8                              ;
 bne  @@size_lop                        ;/
 sub  r2,r1,sp         ;len             ;\
 mov  r1,sp            ;src             ; md5/sha1 update(end+padding+len)
 mov  r0,r5            ;struct          ;
 bl   md5sha1_update                    ;/
 mov  r2,r6  ;len=10h/14h               ;\
@@fin_lop:                              ;
 ldr  r0,[r5],4  ;struct                ; copy result to dst
 cmp  r6,14h  ;MD5/SHA1                 ; for SHA1 --> five BIG-ENDIAN words
 bleq bswap_r0 ;<-- SHA1                ; for MD5 --> four LITTLE-ENDIAN words
 str  r0,[r4],4  ;dst                   ;
 subs r2,4                              ;
 bne  @@fin_lop                         ;/
 add  sp,1+3fh+8  ;dealloc padding buffer
 mov  r0,r6       ;out: r0=length (10h for MD5, 14h for SHA1)
 pop  r4-r6,pc
;------------------
eapol_raise_and_verify_reply_count:  ;in: r0=EAPOL
 push r4-r7,lr
 mov  r4,r0     ;EAPOL
 ldr  r5,=WifiData_replay7              ;\
 ldr  r0,[r5,0]  ;\                     ;
 bl   htonl      ; msw                  ;
 mov  r6,r0      ;/                     ;
 ldr  r0,[r5,4]  ;\                     ;
 bl   htonl      ; lsw                  ;
 mov  r7,r0      ;/                     ; raise Replay Counter+1
 adds r7,1       ;-lsw+1   ;\raise      ;
 adc  r6,0       ;-msw+cy  ;/           ;
 mov  r0,r6      ;\                     ;
 bl   htonl      ; msw                  ;
 str  r0,[r5,0]  ;/                     ;
 mov  r0,r7      ;\                     ;
 bl   htonl      ; lsw                  ;
 str  r0,[r5,4]  ;/                     ;/
 add  r0,r4,09h  ;Replay Count          ;\
 mov  r1,r5  ;=WifiData_replay7         ; want same ReplayCounter+1
 mov  r2,8                              ;  XXX this fails if WPA handshake3 is resent!?! (eg. on fritzbox when WPA handshake5 didn't arrive at access point)
 bl   memcompare_bytewise ;out: EQ=okay ;/
 pop  r4-r7,pc
;------------------
wpa2_adjust_eapol_mic:  ;in: r0=EAPOL
 push r4-r5,lr
 sub  sp,14h  ;alloc MIC dest (10h-byte needed, but SHA1 outputs 14h-bytes)
 mov  r5,r0     ;EAPOL
 ldrb r0,[r5,05h+1] ;key.info.lsb       ;\
 tst  r0,02h                            ; if Key Info is MD5/RC4,
 ldreq  r1,=wifi_md5sha1_mode           ; force using MD5 instead SHA1 as HMAC
 moveq  r0,0     ;0=MD5                 ;
 streqb r0,[r1]                         ;/
 add  r0,r5,51h                         ;\
 mov  r1,16                             ; EAPOL MIC (initially clear)
 bl   zerofill_bytewise                 ;/
 ldrh r0,[r5,02h] ;len      ;\          ;\
 bl   htons       ;len      ; src       ;
 add  r1,r0,4     ;len+4    ;           ;
 mov  r0,r5       ;src=EAPOL;/          ;
 ldr  r2,=WifiData_ptk7+0   ;\key (KCK) ; calc MIC (aka HMAC)
 mov  r3,16  ;kcklen        ;/          ;
 mov  r4,sp  ;mic_dest                  ;
 bl   calc_hmac_md5sha1                 ;/  ;<-- for WPA2: via SHA1
 mov  r0,sp  ;mic_dest  ;src            ;\
 add  r1,r5,51h         ;dst            ; copy first 16 bytes of HMAC
 mov  r2,16             ;len            ; to EAPOL MIC
 bl   memcopy_bytewise                  ;/
 ldr  r1,=wifi_md5sha1_mode             ;\
 mov  r0,1       ;1=SHA1                ; restore SHA1 mode
 strb r0,[r1]                           ;/
 add  sp,14h  ;dealloc MIC dest
 pop  r4-r5,pc
;------------------
wpa2_verify_eapol_mic:  ;in: r0=EAPOL, out: EQ=okay
 push r4-r5,lr
 sub  sp,10h  ;alloc MIC copy (10h-byte needed)
 mov  r5,r0     ;EAPOL
 add  r0,r5,51h  ;src                   ;\
 mov  r1,sp      ;dst (backup)          ; backup old MIC
 mov  r2,16                             ;
 bl   memcopy_bytewise                  ;/
 mov  r0,r5     ;EAPOL                  ;\create new MIC
 bl   wpa2_adjust_eapol_mic             ;/
 add  r0,r5,51h  ;src (new)             ;\
 mov  r1,sp      ;src (backup)          ; verfiy new vs old MIC
 mov  r2,16                             ;
 bl   memcompare_bytewise      ;out: ZF ;/
 add  sp,10h  ;dealloc MIC copy
 pop  r4-r5,pc                 ;out: ZF (EQ=okay)
;------------------
eapol_decrypt:  ;in: r0=EAPOL, out: EQ=okay
 ldrb r1,[r0,05h+1]       ;key.info.lsb ;\
 and  r1,07h                            ;
 cmp  r1,01h                            ;
 beq  eapol_decrypt_rc4           ;1    ;
 b    eapol_decrypt_aes_keywrap   ;2    ;/
;------------------
eapol_decrypt_rc4:  ;in: r0=EAPOL, out: EQ=okay
 push r4-r6,lr
 mov  r4,r0      ;EAPOL
 ldrb r0,[r4,61h]       ;len.msb        ;\
 ldrb r1,[r4,62h]       ;len.lsb        ; get Key Data length
 orr  r5,r1,r0,lsl 8    ;len            ;/
   ;XXX insist on key.data.len not exceeding packet size
 push r4-r5   ;--->
 sub  sp,20h  ;---> alloc iv+key buf    ;-
 mov  r1,sp                             ;\
 add  r0,r4,31h        ;src (EAPOL IV)  ;
 mov  r2,10h                            ; create RC4 key (EAPOL Key IV + KEK)
 bl   memcopy_bytewise                  ;
 ldr  r0,=WifiData_ptk7+10h ;key (KEK)  ;
 mov  r2,10h                            ;
 bl   memcopy_bytewise                  ;/
 add  r0,r4,63h        ;src (EAPOL+63h) ;\
 add  r1,r4,63h        ;dst (EAPOL+63h) ;
 mov  r2,r5            ;len (src/dst)   ;
 mov  r3,sp            ;key    (IV+KEK) ; decrypt
 mov  r4,10h+10h       ;keylen (IV+KEK) ;
 mov  r5,100h   ;preskip                ;
 bl   wifi_rc4_crypt                    ;/
 add  sp,20h  ;<--- dealloc iv+key buf  ;-
 pop  r4-r5   ;<---
 cmp  r0,r0     ;out: EQ=okay
 pop  r4-r6,pc
;---
@@bad:
 cmp  sp,0      ;out: NE=bad
 pop  r4-r6,pc
;------------------
eapol_decrypt_aes_keywrap:  ;in: r0=EAPOL, out: EQ=okay
 push r4-r6,lr
 mov  r4,r0      ;EAPOL
 ldrb r0,[r4,61h]       ;len.msb        ;\
 ldrb r1,[r4,62h]       ;len.lsb        ; get Key Data length
 orr  r5,r1,r0,lsl 8    ;len            ;/
 tst  r5,7  ;must be N*8 for AES.unwrap ;\
 bne  @@bad                             ; range check Key Data length
 cmp  r5,10h ;must be min IV(8)+DATA(N) ;
 blo  @@bad                             ;/
   ;XXX refuse len>100h or so (usually 38h)
   ;XXX refuse if len doesn't match with packet header length value(s)
;- - -
 sub  sp,r5   ;---> alloc decrypt.buf   ;-
 ldr  r0,=WifiData_ptk7+10h ;key (KEK)  ;\
 add  r1,r4,63h         ;src (EAPOL+63h);
 mov  r2,sp             ;dst,WORDaligned; decrypt Key Data
 mov  r3,r5             ;len            ;
 bl   aes_sw_be_unwrap                  ;/
 ldr  r0,=@@expected_iv                 ;\
 mov  r1,sp                             ; want fixed IV (A6A6A6A6A6A6A6A6)
 mov  r2,8                              ;  (in fritzbox, this does match the EAPOL "Key IV" field)
 bl   memcompare_bytewise               ;  (in o2acc2, there's random stuff in EAPOL "Key IV" field)
 addne sp,r5  ;<--- dealloc decrypt.buf ;  (anyways, the decrypted stuff must be A6A6A6A6A6A6A6A6)
 bne   @@bad                            ;/
 add  r0,sp,8 ;skip IV  ;src,WORDaligned;\
 add  r1,r4,63h         ;dst (EAPOL+63h); copy decrypted data back to EAPOL
 sub  r2,r5,8           ;len-8          ; (excluding IV)
 bl   memcopy_bytewise                  ;/
 add  sp,r5   ;<--- dealloc decrypt.buf ;-
 sub  r5,8              ;len-8          ;\
 mov  r0,r5,lsr 8       ;len.msb        ; exclude IV from length,
 strb r0,[r4,61h]       ;len.msb        ; and writeback adjusted key.data length
 strb r5,[r4,62h]       ;len.lsb        ;/
;- - -
.if 0;1
   bl   wrcrlf                          ;\
   add  r1,r4,63h                       ;
   mov  r2,0                            ;
   mov  r3,r5                           ;
  @@show_lop:                           ;
   ldrb r0,[r1],1                       ;
   bl   wrhex8bit                       ;
   bl   wrspc                           ;
   add  r2,1                            ;
   tst  r2,7                            ;
   bleq wrcrlf                          ;
   subs r3,1                            ;
   bne  @@show_lop                      ;
.endif                                  ;/
 cmp  r0,r0     ;out: EQ=okay
 pop  r4-r6,pc
;---
@@bad:
 cmp  sp,0      ;out: NE=bad
 pop  r4-r6,pc
;---
@@expected_iv db 0A6h,0A6h,0A6h,0A6h,0A6h,0A6h,0A6h,0A6h
;------------------
wpa_apply_gtk:  ;in: r0=EAPOL, out: EQ=okay
 push r4-r6,lr
 mov  r4,r0      ;EAPOL
 ldrb r0,[r4,61h] ;len.msb              ;\
 ldrb r1,[r4,62h] ;len.lsb              ; get Key Data length
 orr  r5,r1,r0,lsl 8    ;len            ;/
 ldr  r1,=WifiData_grp7                 ;\
 ldrb r1,[r1]                           ;
 cmp  r1,KEY_TYPE_TKIP                  ; insist on expected key data length
 moveq r0,20h  ;groupkeylen for TKIP    ; (matching for group key type)
 movne r0,10h  ;groupkeylen for AES     ;
 cmp   r0,r5   ;key.data.len (10h/20h)  ;
 bne  @@bad                             ;/
 add  r0,r4,63h  ;src (EAPOL+63h)       ;\
 ldr  r1,=WifiData_gtk7                 ; apply GTK (after decrypting it)
 mov  r2,r5   ;key.data.len (10h/20h)   ;
 bl   memcopy_bytewise                  ;/
 ldrb r0,[r4,05h+1] ;KeyInfo lsb        ;\
 and  r0,30h                            ;
 mov  r0,r0,lsr 4                       ; apply key index
 ldr  r1,=WifiData_gtk_index7           ;
 strb r0,[r1]                           ;/
 cmp  r0,r0     ;out: EQ=okay
 pop  r4-r6,pc
;---
@@bad:
 cmp  sp,0      ;out: NE=bad
 pop  r4-r6,pc
;------------------
wpa2_apply_gtk:  ;in: r0=EAPOL, out: EQ=okay
 push r4-r6,lr
 mov  r4,r0      ;EAPOL
 ldrb r0,[r4,61h]       ;len.msb        ;\
 ldrb r1,[r4,62h]       ;len.lsb        ; get Key Data length (excluding WPA2.IV, if any)
 orr  r5,r1,r0,lsl 8    ;len            ;/
 ldr  r0,=WifiData_grp7                 ;\
 ldrb r0,[r0]                           ;
 cmp  r0,KEY_TYPE_TKIP     ;len...      ; expected group key size
 moveq r6,20h  ;groupkeylen for TKIP    ;
 movne r6,10h  ;groupkeylen for AES     ;/
;- - -
 add  r1,r4,63h                         ;\
@@search_item_DDh_lop:                  ;
 subs r5,2       ;len/remain            ;
 blo  @@bad                             ; search item DDh
 ldrb r0,[r1],1  ;item.ID               ; (eg. skip bogus item 30h)
 ldrb r2,[r1],1  ;item.len              ; (WPA2 handshake3 has item 30h and DDh)
 subs r5,r2      ;len/remain            ; (WPA2 handshake5 has item DDh only)
 blo  @@bad                             ;
 cmp  r0,0ddh                           ;
 beq  @@found_item_DDh                  ;
 add  r1,r2      ;skip item             ;
 b    @@search_item_DDh_lop             ;
@@found_item_DDh:                       ;/
 add  r0,r6,06h  ;groupkeysize+6
 cmp  r0,r2      ;item.len (16h/26h)
 bne  @@bad                             ;
 ldrb r0,[r1],1         ;\              ;\
 cmp  r0,0              ; OUI[0]        ;
 bne  @@bad             ;/              ;
 ldrb r0,[r1],1         ;\              ; OUI (00 0F AC 01)  ;=GTK KDE
 cmp  r0,0fh            ; OUI[1]        ;
 bne  @@bad             ;/              ;
 ldrb r0,[r1],1         ;\              ;
 cmp  r0,0ach           ; OUI[2]        ;
 bne  @@bad             ;/              ;
 ldrb r0,[r1],1         ;\              ;
 cmp  r0,01h            ; OUI[3]        ;
 bne  @@bad             ;/              ;/
 ldrb r0,[r1],1  ;key.id                ;\
 cmp  r0,0  ;0 is already used for PTK  ;
 beq  @@bad                             ; apply keyIndex for GTK (1..3)
 cmp  r0,3  ;allow only 1..3            ; (toggles between 1 and 2
 bhi  @@bad                             ; every once and then)
 ldr  r3,=WifiData_gtk_index7           ;
 strb r0,[r3]                           ;/
 ldrb r0,[r1],1  ;reserved              ;\
 cmp  r0,0                              ; reserved (00h)
 bne  @@bad                             ;/
 mov  r0,r1                ;src         ;\
 ldr  r1,=WifiData_gtk7    ;dst         ; apply GTK group key
 mov  r2,r6 ;groupkeysize (10h/20h)     ;
 bl   memcopy_bytewise                  ;/
 cmp  r0,r0     ;out: EQ=okay
 pop  r4-r6,pc
;---
@@bad:
 cmp  sp,0      ;out: NE=bad
 pop  r4-r6,pc
;------------------
md5_callback_core:   ;in: r0=struct, r1=src, r2=len
 push r0-r12,lr
 mov  r10,r0  ;struct
 mov  r11,r1  ;src
 mov  r12,r2  ;len
;- - -
 ldmia [r10],r0-r3
@@block_lop:
 ldr  r6,=@@md5_const_list
@@core_lop:
 ldmia [r6]!,r8,r9  ;r8=index*100h+rotate, r9=const
 cmp  r8,8000h      ;or r8=special, r9=new.proc
 bxlo r7   ;@@proc_1..4
;- - -
 moveq r7,r9 ;=new.proc ;\
 beq   @@core_lop       ; special
 b     @@next_block     ;/
;---
@@proc_1:
 and  r4,r1,r2  ;(b AND c)
 bic  r5,r3,r1  ;(d AND not b)
 orr  r4,r5     ;(b AND c) OR (d AND NOT b)
 b    @@proc_back
;---
@@proc_2:
 and  r4,r1,r3  ;(b AND d)
 bic  r5,r2,r3  ;(c AND not d)
 orr  r4,r5     ;(b AND d) OR (c AND NOT d)
 b    @@proc_back
;---
@@proc_3:
 eor  r4,r1,r2  ;(b XOR c)
 eor  r4,r3     ;(b XOR c XOR d)
 b    @@proc_back
;---
@@proc_4:
 mvn  r4,r3     ;(NOT d)
 orr  r4,r1     ;(b OR NOT d)
 eor  r4,r2     ;(b OR NOT d) XOR c
;b    @@proc_back
;- - -
@@proc_back:
 ldr  r5,[r11,r8,lsr 8-2]  ;[src+index*4]
 add  r4,r0  ;tmp+a
 add  r4,r9  ;tmp+const
 add  r4,r5  ;tmp+[src+index]
 mov  r0,r3             ;a=d   ;\
 mov  r3,r2             ;d=c   ; move up
 mov  r2,r1             ;c=b   ;/
 add  r1,r1,r4,ror r8   ;b=b+(tmp ror NN)
 b    @@core_lop
;---
@@next_block:
 ldmia [r10],r4-r7              ;\
 add   r0,r4                    ;
 add   r1,r5                    ;
 add   r2,r6                    ;
 add   r3,r7                    ;
 stmia [r10],r0-r3              ;/
 add  r11,40h   ;src            ;\
 subs r12,40h   ;len            ;
 bne  @@block_lop               ;/
 pop  r0-r12,lr
 bx   lr        ;<-- ret with THUMB bit (needed when used as callback for DSi BIOS SWI function)
;--- --- ---
@@md5_const_list:
 dd 8000h,@@proc_1
 dd 0019h,0D76AA478h, 0114h,0E8C7B756h, 020Fh,0242070DBh, 030Ah,0C1BDCEEEh
 dd 0419h,0F57C0FAFh, 0514h,04787C62Ah, 060Fh,0A8304613h, 070Ah,0FD469501h
 dd 0819h,0698098D8h, 0914h,08B44F7AFh, 0A0Fh,0FFFF5BB1h, 0B0Ah,0895CD7BEh
 dd 0C19h,06B901122h, 0D14h,0FD987193h, 0E0Fh,0A679438Eh, 0F0Ah,049B40821h
 dd 8000h,@@proc_2
 dd 011Bh,0F61E2562h, 0617h,0C040B340h, 0B12h,0265E5A51h, 000Ch,0E9B6C7AAh
 dd 051Bh,0D62F105Dh, 0A17h,002441453h, 0F12h,0D8A1E681h, 040Ch,0E7D3FBC8h
 dd 091Bh,021E1CDE6h, 0E17h,0C33707D6h, 0312h,0F4D50D87h, 080Ch,0455A14EDh
 dd 0D1Bh,0A9E3E905h, 0217h,0FCEFA3F8h, 0712h,0676F02D9h, 0C0Ch,08D2A4C8Ah
 dd 8000h,@@proc_3
 dd 051Ch,0FFFA3942h, 0815h,08771F681h, 0B10h,06D9D6122h, 0E09h,0FDE5380Ch
 dd 011Ch,0A4BEEA44h, 0415h,04BDECFA9h, 0710h,0F6BB4B60h, 0A09h,0BEBFBC70h
 dd 0D1Ch,0289B7EC6h, 0015h,0EAA127FAh, 0310h,0D4EF3085h, 0609h,004881D05h
 dd 091Ch,0D9D4D039h, 0C15h,0E6DB99E5h, 0F10h,01FA27CF8h, 0209h,0C4AC5665h
 dd 8000h,@@proc_4
 dd 001Ah,0F4292244h, 0716h,0432AFF97h, 0E11h,0AB9423A7h, 050Bh,0FC93A039h
 dd 0C1Ah,0655B59C3h, 0316h,08F0CCC92h, 0A11h,0FFEFF47Dh, 010Bh,085845DD1h
 dd 081Ah,06FA87E4Fh, 0F16h,0FE2CE6E0h, 0611h,0A3014314h, 0D0Bh,04E0811A1h
 dd 041Ah,0F7537E82h, 0B16h,0BD3AF235h, 0211h,02AD7D2BBh, 090Bh,0EB86D391h
 dd 0FFFFh,000000000h
;------------------
calc_hmac_md5sha1:   ;in: r0,r1,r2,r3,r4 - out: r0=len
 push r4-r10,lr
@@key_buf     equ 00h   ;40h
@@tmp_buf     equ 40h   ;14h
@@sha1_struct equ 54h   ;64h
@@total_alloc equ 0B8h
 sub  sp,@@total_alloc
;- - -
 mov  r8,r4     ;dst
 mov  r7,r3     ;keylen
 mov  r6,r2     ;key
 mov  r5,r1     ;srclen
 mov  r4,r0     ;src
;- - -
 cmp  r7,40h    ;keylen                 ;\
 bls  @@key_small_enough                ;
 add  r0,sp,@@key_buf   ;dst=keybuf     ; if len(key)>40h then key=SHA1(key) ;convert LONG keys to 14h-bytes length
 mov  r1,r6             ;src=key        ;
 mov  r2,r7             ;len=keylen     ;
 bl   md5sha1_init_update_finish        ;
 mov  r7,r0  ;10h/14h   ;keylen=14h     ;
 add  r6,sp,@@key_buf   ;key=keybuf     ;
@@key_small_enough:                     ;/
 mov  r0,r6             ;src=key        ;\
 add  r1,sp,@@key_buf   ;dst=keybuf     ; copy key to keybuf
 mov  r2,r7             ;len=keylen     ; (might be already there from above)
 bl   memcopy_bytewise                  ;/
 add  r0,sp,@@key_buf   ;dst=keybuf     ;\
 add  r0,r7             ;dst=keybuf+len ; if len(key)<40h then zero-pad key to 40h-bytes length
 rsb  r1,r7,40h         ;len=40h-keylen ;
 bl   zerofill_bytewise                 ;/
;- - -
 mov  r0,36h            ;xor 1st key    ;\
 add  r1,sp,@@tmp_buf   ;dst=tmp        ; tmp = SHA1(KeyXor36h+src)
 bl   @@calc_sha1                       ;/
 mov  r5,r0  ;10h/14h ;srclen = tmp.len ;\
 add  r4,sp,@@tmp_buf ;src    = tmp     ;
 mov  r0,5ch xor 36h    ;xor 2nd key    ; dst = SHA1(KeyXor5Ch+tmp)
 mov  r1,r8             ;dst=dst        ;
 bl   @@calc_sha1                       ;/
 add  sp,@@total_alloc
 pop  r4-r10,pc
;---
@@calc_sha1:  ;in: r0,r1,r4,r5,sp - out: r0=len
 mov  r10,lr  ;save retadr (but keep "sp" unchanged for [sp+@@locals])
 mov  r9,r1     ;dst
 add  r1,sp,@@key_buf                   ;\
 mov  r2,40h                            ;
@@xor_lop:                              ;
 ldrb r3,[r1]                           ; XOR key
 xor  r3,r0                             ;
 strb r3,[r1],1                         ;
 subs r2,1                              ;
 bne  @@xor_lop                         ;/
 mov  r0,0             ;callback        ;\
 str  r0,[sp,@@sha1_struct+60h]         ; sha1 init
 add  r0,sp,@@sha1_struct               ;
 bl   md5sha1_init                      ;/
 add  r0,sp,@@sha1_struct               ;\
 add  r1,sp,@@key_buf  ;src             ; sha1 update(key)
 mov  r2,40h           ;len             ;
 bl   md5sha1_update                    ;/
 add  r0,sp,@@sha1_struct               ;\
 mov  r1,r4            ;src             ; sha1 update(body)
 mov  r2,r5            ;len             ;
 bl   md5sha1_update                    ;/
 mov  r0,r9            ;dst             ;\
 add  r1,sp,@@sha1_struct               ; sha1 finish
 bl   md5sha1_finish                    ;/
 bx   r10     ;to retadr (and keep "sp" unchanged for [sp+@@locals])
;---
.if use_dsi_bios
swi_sha1_init                   equ 24h shl 16
swi_sha1_update                 equ 25h shl 16
swi_sha1_finish                 equ 26h shl 16
swi_sha1_init_update_finish     equ 27h shl 16
.endif
;------------------
.pool
;------------------
.endif ;with_dsi_wifi
;------------------
;:----------------- AES Big-Endian SOFTWARE implementation
;------------------
.data?
.align 40h      ;XXX cache?
 aes_sw_be_pow_table: defs 100h    ;\
 aes_sw_be_log_table: defs 100h    ;
 aes_sw_be_fsb_table: defs 100h    ; Big-Endian AES tables
 aes_sw_be_rsb_table: defs 100h    ;
 .if with_crypto_selftest          ;
  aes_sw_be_ft_table:  defs 4*100h ;
 .endif                            ;
 aes_sw_be_rt_table:  defs 4*100h  ;/           ;<-- this is "RT0" (and "RT1,RT2,RT3" would be same in rotate form)
 aes_sw_be_nr:        dd 0         ;\AES key
 aes_sw_be_rk:        defs 4*40h   ;/
 aes_sw_temp_x0x1x2x3:defs 10h     ;-temp X0,X1,X2,X3
.align 40h      ;XXX cache?
.code
;------------------
.if with_crypto_selftest
  aes_sw_be_encrypt_block:   ;in: r11=src, r12=dst
   push r0-r12,lr
   ldr   r10,=aes_sw_be_rk
   ldmia [r11]!,r0,r1,r2,r3   ;Y0..Y3 = [src+00h,04h,08h,0Ch]     ;\
   bl    @@xor_rk                                                 ;/
   ldr  r8,=aes_sw_temp_x0x1x2x3
   ldr  r9,=aes_sw_be_nr
   ldr  r9,[r9] ;lopcount=(nr)
   sub  r9,1    ;lopcount=(nr-1)
   ldr  r11,=aes_sw_be_ft_table
  @@lop:   ;for i=1 to nr-1
   mov r4,r0 // mov r5,r1 // mov r6,r2 // mov r7,r3 // bl @@p32 // str r7,[r8,00h]
   mov r4,r1 // mov r5,r2 // mov r6,r3 // mov r7,r0 // bl @@p32 // str r7,[r8,04h]
   mov r4,r2 // mov r5,r3 // mov r6,r0 // mov r7,r1 // bl @@p32 // str r7,[r8,08h]
   mov r4,r3 // mov r5,r0 // mov r6,r1 // mov r7,r2 // bl @@p32 // str r7,[r8,0ch]
   ldmia [r8],r0,r1,r2,r3   ;Y0..Y3 = X0..X3
   bl    @@xor_rk
   subs  r9,1
   bne   @@lop
   ldr  r11,=aes_sw_be_fsb_table
   mov r4,r0 // mov r5,r1 // mov r6,r2 // mov r7,r3 // bl @@p8 // str r4,[r12],4
   mov r4,r1 // mov r5,r2 // mov r6,r3 // mov r7,r0 // bl @@p8 // str r4,[r12],4
   mov r4,r2 // mov r5,r3 // mov r6,r0 // mov r7,r1 // bl @@p8 // str r4,[r12],4
   mov r4,r3 // mov r5,r0 // mov r6,r1 // mov r7,r2 // bl @@p8 // str r4,[r12],4
   pop r0-r12,pc
.endif
;--- --- ----------
aes_sw_be_decrypt_block equ $   ;in: r11=src, r12=dst
 push r0-r12,lr
 ldr   r10,=aes_sw_be_rk
 ldmia [r11]!,r0,r1,r2,r3   ;Y0..Y3 = [src+00h,04h,08h,0Ch]     ;\
 bl    @@xor_rk                                                 ;/
 ldr  r8,=aes_sw_temp_x0x1x2x3
 ldr  r9,=aes_sw_be_nr
 ldr  r9,[r9] ;lopcount=(nr)
 sub  r9,1    ;lopcount=(nr-1)
 ldr  r11,=aes_sw_be_rt_table
@@decrypt_lop:   ;for i=1 to nr-1
 mov r4,r0 // mov r5,r3 // mov r6,r2 // mov r7,r1 // bl @@p32 // str r7,[r8,00h]
 mov r4,r1 // mov r5,r0 // mov r6,r3 // mov r7,r2 // bl @@p32 // str r7,[r8,04h]
 mov r4,r2 // mov r5,r1 // mov r6,r0 // mov r7,r3 // bl @@p32 // str r7,[r8,08h]
 mov r4,r3 // mov r5,r2 // mov r6,r1 // mov r7,r0 // bl @@p32 // str r7,[r8,0ch]
 ldmia [r8],r0,r1,r2,r3   ;Y0..Y3 = X0..X3
 bl    @@xor_rk
 subs  r9,1
 bne   @@decrypt_lop
 ldr  r11,=aes_sw_be_rsb_table
 mov r4,r0 // mov r5,r3 // mov r6,r2 // mov r7,r1 // bl @@p8 // str r4,[r12],4
 mov r4,r1 // mov r5,r0 // mov r6,r3 // mov r7,r2 // bl @@p8 // str r4,[r12],4
 mov r4,r2 // mov r5,r1 // mov r6,r0 // mov r7,r3 // bl @@p8 // str r4,[r12],4
 mov r4,r3 // mov r5,r2 // mov r6,r1 // mov r7,r0 // bl @@p8 // str r4,[r12],4
 pop r0-r12,pc
;---
@@xor_rk:
 ldmia [r10]!,r4,r5,r6,r7  ;RK[0,1,2,3 + N*4]      ;rk
 eor   r0,r4               ;Y0 = Y0 xor RK[0+N*4]
 eor   r1,r5               ;Y1 = Y1 xor RK[1+N*4]
 eor   r2,r6               ;Y2 = Y2 xor RK[2+N*4]
 eor   r3,r7               ;Y3 = Y3 xor RK[3+N*4]
 bx    lr
;---
@@p32:
 and  r4,0ffh
 and  r5,0ff00h
 and  r6,0ff0000h
 and  r7,0ff000000h
 ldr  r4,[r11,r4,lsl 0+2]
 ldr  r5,[r11,r5,lsr 8-2]
 ldr  r6,[r11,r6,lsr 16-2]
 ldr  r7,[r11,r7,lsr 24-2]
 eor  r7,r6,r7,ror 24
 eor  r7,r5,r7,ror 24
 eor  r7,r4,r7,ror 24
 bx   lr
;---
@@p8:
 and  r4,0ffh
 and  r5,0ff00h
 and  r6,0ff0000h
 and  r7,0ff000000h
 ldrb r4,[r11,r4,lsr 0]
 ldrb r5,[r11,r5,lsr 8]
 ldrb r6,[r11,r6,lsr 16]
 ldrb r7,[r11,r7,lsr 24]
 eor  r4,r4,r5,lsl 8
 eor  r4,r4,r6,lsl 16
 eor  r4,r4,r7,lsl 24
 ldr  r7,[r10],4        ;rk
 eor  r4,r7
 bx   lr
;------------------
aes_sw_be_set_encrypt_key:     ;in: r0=key, r1=keysize, out: rk, nr
 push  r0-r12,lr
 bl    aes_sw_be_generate_tables   ;<-- unless tables are already initialized
 mov   r5,r0       ;key
 mov   r7,r1,lsr 3 ;keysize in BYTES
 cmp   r7,4*4 ;jj=4  ;in: 128bit aka 16 bytes aka 4 words, out: RK[0..43], nr=10
 cmpne r7,6*4 ;jj=6  ;in: 192bit aka 24 bytes aka 6 words, out: RK[0..51], nr=12
 cmpne r7,8*4 ;jj=8  ;in: 256bit aka 32 bytes aka 8 words, out: RK[0..59], nr=14
 bne   $      ;jj=?  ;oops
 mov   r0,r1,lsr 5  ;keysize/32 (=4,6,8 words)       ;\
 add   r0,6         ;nr         (=10,12,14)          ; apply (nr)
 ldr   r1,=aes_sw_be_nr                              ;
 str   r0,[r1]        ;apply (nr)                    ;/
 ldr   r6,=aes_sw_be_rk                              ;-key dest
 ldr   r10,=aes_sw_be_fsb_table   ;for @@scatter8    ;-scatter table
add r0,1  ;(nr+1)
mov r8,r0,lsl (2+2) ;(nr+1)*4
 mov   r2,0*4         ;i=0                           ;\
 mov   r3,0           ;j=0                           ;
 mov   r4,01000000h   ;rc=01h shl 24                 ;
@@lop:                ;for i=0 to (nr+1)*4-1         ;
 subs  r1,r2,r7       ;i-jj                          ;
 ldrmi r0,[r5,r2]     ;\if i<jj then w=[key+i*4+0..3];
 ldrpl r1,[r6,r1]     ; else w=w xor RK[(i-jj)]      ;
 eorpl r0,r1          ;/                             ;
 str   r0,[r6,r2]     ;RK[i]=w                       ;
 add   r3,1*4         ;j=j+1                         ;
 cmp   r3,r7          ;\if j=jj then                 ;
 bne   @@cont         ;                              ;
 mov   r3,0           ; j=0                          ;
 bl    @@scatter8     ; w=scatter8(FSb,w,w,w,w)      ; make RK[4/6/8..43/53/63]
 mov   r0,r0,ror 8    ; w=w ror 8                    ;
 xor   r0,r0,r4,lsr 24; w=w xor (rc shl 0)           ;
 movs  r4,r4,lsl 1    ; rc=rc*2 (shl 24)             ;
 eorcs r4,1b000000h   ;/if cy: rc=rc xor 1Bh shl 24  ;
@@cont:                                              ;
 cmp   r3,4*4         ;\if j=4                       ;
 cmpeq r7,8*4         ; and jj=8 then                ;
 bleq  @@scatter8     ;/w=scatter8(FSb,w,w,w,w)      ;
 add  r2,1*4          ;i=i+1                         ;
 cmp  r2,r8                                          ;
 bne  @@lop                                          ;/
 pop  r0-r12,pc
;---
@@scatter32:  ;io: r0, in: r11=RT, out: r1,r2=destroyed
 and  r1,r0,0ffh       // ldr  r2,[r11,r1,lsl 0+2]
 and  r1,r0,0ff00h     // ldr  r1,[r11,r1,lsr 8-2]  // eor  r2,r2,r1,ror 24
 and  r1,r0,0ff0000h   // ldr  r1,[r11,r1,lsr 16-2] // eor  r2,r2,r1,ror 16
 and  r1,r0,0ff000000h // ldr  r1,[r11,r1,lsr 24-2] // eor  r0,r2,r1,ror 8
 bx   lr
;---
@@scatter8:   ;io: r0, in: r10=FSb, out: r1=destroyed
 ldrb r1,[r10,r0,lsr 24] // eor  r0,r1,r0,lsl 8
 ldrb r1,[r10,r0,lsr 24] // eor  r0,r1,r0,lsl 8
 ldrb r1,[r10,r0,lsr 24] // eor  r0,r1,r0,lsl 8
 ldrb r1,[r10,r0,lsr 24] // eor  r0,r1,r0,lsl 8
 bx   lr
;--- --- --- ------
aes_sw_be_set_decrypt_key equ $
 push r0-r12,lr
 bl   aes_sw_be_set_encrypt_key         ;-set encrypt key
 ldr  r10,=aes_sw_be_nr                 ;\
 ldr  r10,[r10]        ;=(nr)           ;
 mov  r12,r10,lsl 2    ;=(nr*4)         ;/
 ldr  r8,=aes_sw_be_rk                  ;\
 add  r9,r8,r10,lsl (2+2)               ;
@@swap_lop:  ;for i=0 to nr/2-1         ; swap entries (except middle one)
 ldmia [r8],r0-r3  ;RK[     i*4 + 0..3] ;
 ldmia [r9],r4-r7  ;RK[nr*4-i*4 + 0..3] ;
 stmia [r8],r4-r7  ;RK[     i*4 + 0..3] ;
 stmia [r9],r0-r3  ;RK[nr*4-i*4 + 0..3] ;
 add   r8,10h                           ;
 sub   r9,10h                           ;
 subs  r10,2                            ;
 bne   @@swap_lop                       ;/
 ldr  r10,=aes_sw_be_fsb_table          ;\
 ldr  r11,=aes_sw_be_rt_table           ;
 sub  r12,4            ;=(nr*4)-4       ;
 ldr  r8,=aes_sw_be_rk+(4*4)            ;
@@modify_lop:                           ; modify entries (except RK[0..3] and RK[nr*4+0..3])
 ldr  r0,[r8]     ;w=RK[i]              ;
 bl   @@scatter8  ;w=scatter8(FSb,w,w,w,w)
 bl   @@scatter32 ;w=scatter32(RT,w,w,w,w)
 str  r0,[r8],4   ;RK[i]=w              ;
 subs r12,1                             ;
 bne  @@modify_lop                      ;/
 pop  r0-r12,pc
;------------------
aes_sw_be_generate_tables:
 push  r0-r12,lr
 ldr   r4,=aes_sw_be_pow_table                          ;\
 ldr   r5,=aes_sw_be_log_table                          ;
 ldr   r6,=aes_sw_be_fsb_table                          ;
 ldr   r7,=aes_sw_be_rsb_table                          ;
 .if with_crypto_selftest                               ;
   ldr   r8,=aes_sw_be_ft_table  ;FT                    ;
 .endif                                                 ;
 ldr   r9,=aes_sw_be_rt_table    ;RT                    ;/
 mov   r0,00h      ;i                                   ;\
 mov   r1,01h      ;x                                   ;
 ldr   r2,=11bh    ;11Bh                                ;
@@pow_log_lop:                                          ; compute pow and
 strb  r0,[r5,r1]         ;log[x]=i                     ; log tables...
 strb  r1,[r4,r0]         ;pow[i]=x                     ;
 eor   r1,r1,r1,lsl 1     ;x=x xor x*2                  ;
 tst   r1,100h            ;if x>0FFh then               ;
 eorne r1,r2    ;=11Bh    ;x=x xor 11Bh                 ;
 add   r0,r0,1            ;i=i+1                        ;
 cmp   r0,100h                                          ;
 bne   @@pow_log_lop                                    ;/
 mov   r0,00h      ;i                                   ;\
 mov   r1,63h      ;x                                   ;
@@sbox_lop:                                             ; generate the forward
 strb  r0,[r7,r1]  ;RSb[x]=i                            ; and reverse S-boxes...
 strb  r1,[r6,r0]  ;FSb[i]=x                            ;
 add   r0,r0,1     ;i=i+1                               ;
 ldrb  r2,[r5,r0]  ;x=log[i]                            ;
 rsb   r2,r2,0ffh  ;x=FFh-log[i]                        ;
 ldrb  r2,[r4,r2]  ;x=pow[FFh-log[i]]                   ;
 orr   r2,r2,r2,lsl 24     ;\                           ;
 eor   r1,r2,63h           ; x=63h xor x                ;
 eor   r1,r1,r2,ror (32-1) ;   xor (x rol 1)            ;
 eor   r1,r1,r2,ror (32-2) ;   xor (x rol 2)            ;
 eor   r1,r1,r2,ror (32-3) ;   xor (x rol 3)            ;
 eor   r1,r1,r2,ror (32-4) ;   xor (x rol 4)            ;
 and   r1,0ffh             ;/                           ;
 cmp   r0,100h                                          ;
 bne   @@sbox_lop                                       ;/
 mov   r0,00h             ;i=0                          ;\
@@fwd_rev_lop:                                          ; generate the forward
 .if with_crypto_selftest    ;aes_sw_be_ft_table (FT)   ; and reverse tables...
   ldrb  r1,[r6,r0]          ;w=FSb[i]               ;\ ;
   orr   r1,r1,r1,lsl 8      ;w=w*00000101h          ;  ;
   orr   r1,r1,r1,lsl 16     ;w=w*01010101h          ;  ;
   adds  r1,r1,r1,lsl 24     ;w=w*02010101h          ;  ;
   eorcs r1,1B000000h        ;if cy then xor 1Bh     ;  ;
   mov   r1,r1,ror 24        ;w=w*010101xxh          ;  ;
   eor   r1,r1,r1,lsl 24     ;xor msb by lsb         ;  ;
   str   r1,[r8,r0,lsl 2]    ;FT[i]=w                ;/ ;
 .endif
 mov   r2,0               ;w=00000000h               ;\ ;
 ldrb  r1,[r7,r0]         ;x=RSb[i]                  ;  ;
 cmp   r1,0               ;if x<>00h then            ;  ;
 beq   @@fwd_rev_this     ;   ;ie. not at i=63h      ;  ;
 ldrb  r1,[r5,r1]  ;x=log[x]                         ;  ;
 ldrb  r3,[r5,0bh] ;y=log[0Bh]                       ;  ;
 bl    @@sub       ;w=w*100h+pow[(x+y) mod 00FFh]    ;  ;
 ldrb  r3,[r5,0dh] ;y=log[0Dh]                       ;  ;
 bl    @@sub       ;w=w*100h+pow[(x+y) mod 00FFh]    ;  ;
 ldrb  r3,[r5,09h] ;y=log[09h]                       ;  ;
 bl    @@sub       ;w=w*100h+pow[(x+y) mod 00FFh]    ;  ;
 ldrb  r3,[r5,0eh] ;y=log[0Eh]                       ;  ;
 bl    @@sub       ;w=w*100h+pow[(x+y) mod 00FFh]    ;  ;
@@fwd_rev_this:                                      ;  ;
 str   r2,[r9,r0,lsl 2]   ;RT[i]=w                   ;/ ;
 add   r0,r0,1            ;i=i+1                        ;
 cmp   r0,100h                                          ;
 bne   @@fwd_rev_lop                                    ;/
 pop   r0-r12,pc
;---
@@sub:   ;w=w*100h+pow[(x+y) mod 00FFh]
 add   r3,r1   ;y=y+x
 cmp   r3,0ffh
 subge r3,0ffh  ;sub
 cmp   r3,0ffh
 subge r3,0ffh  ;again (can happen)
 ldrb  r3,[r4,r3]      ;y=pow[y]
 orr   r2,r3,r2,lsl 8  ;w=w*100h+y
 bx   lr
;------------------
.if with_crypto_selftest
aes_sw_be_wrap:  ;in: r0=kek, r1=src/decrypted, r2=dst/crypted, r3=len
 push r4-r12,lr
 sub  sp,10h    ;alloc tmpbuf
;XXX could verify IV at [src+0..7], conventionally A6A6A6A6A6A6A6A6h
 mov  r5,r1   ;src
 mov  r6,r2   ;dst
 mov  r7,r3   ;len
;mov  r0,r0   ;key                      ;\
 mov  r1,128  ;128bit key               ; apply encrypt key
 bl   aes_sw_be_set_encrypt_key         ;/
 mov  r0,r5   ;src                      ;\
 mov  r1,r6   ;dst                      ; copy unencrypted IV+DATA to dst
 mov  r2,r7   ;len                      ;
 bl   memcopy_bytewise                  ;/
 mov  r4,00h                    ;-count=0
 mov  r5,6
@@repeat_six_lop:               ;-for (j = 5; j >= 0; j--) {
 mov   r8,r6     ;start=dst
 sub   r9,r7,8   ;len-8
@@inner_lop:                    ;-for (i = n; i >= 1; i--) {
 add   r4,1  ;count+1
 add   r8,8                     ;-dst+8 (starting from begin)
 ldmia [r6],r0-r1               ;-get IV from dst+0
 ldmia [r8],r2-r3               ;-get DATA from dst+index
 stmia [sp],r0-r3               ;-store IV+DATA in tmpbuf
 mov   r11,sp   ;src            ;\
 mov   r12,sp   ;dst            ; aes_encrypt(tmpbuf)
 bl    aes_sw_be_encrypt_block  ;/
 ldmia [sp],r0-r3               ;-readback IV+DATA from tmpbuf
 eor   r1,r1,r4,lsl 24          ;-adjust byte[7] of IV (xor by count)
 stmia [r6],r0-r1               ;-writeback IV to dst+0
 stmia [r8],r2-r3               ;-writeback DATA to dst+index
 subs r9,8  ;len-8
 bne  @@inner_lop
 subs r5,1
 bne  @@repeat_six_lop
 add  sp,10h    ;dealloc tmpbuf
 pop  r4-r12,pc
.endif ;with_crypto_selftest
;------------------
aes_sw_be_unwrap:  ;in: r0=kek, r1=src/crypted, r2=dst/decrypted, r3=len
 ;note: src contains encrypted IV+DATA
 ;note: dst contains decrypted IV+DATA
 ;the latter one is unconventional (other AES-unwrap implementations do
 ;do usually discard the IV value after decryption, and don't store it
 ;at dst.
 ;- - -
 push r4-r12,lr
 sub  sp,10h    ;alloc tmpbuf
 mov  r5,r1   ;src
 mov  r6,r2   ;dst
 mov  r7,r3   ;len
;mov  r0,r0   ;key                      ;\
 mov  r1,128  ;128bit key               ; apply decrypt key
 bl   aes_sw_be_set_decrypt_key         ;/
 mov  r0,r5   ;src                      ;\
 mov  r1,r6   ;dst                      ; copy crypted IV+DATA to dst
 mov  r2,r7   ;len                      ;
 bl   memcopy_bytewise                  ;/
 sub  r0,r7,8        ;((len-8))                 ;\
 mov  r4,r0,lsr 2    ;((len-8)/8)*2             ; count=((len-8)/8)*6
 add  r4,r4,r0,lsr 1 ;((len-8)/8)*2+(len/8)*4   ;/
@@repeat_six_lop:               ;-for (j = 5; j >= 0; j--) {
 add   r8,r6,r7  ;end=dst+len
 sub   r9,r7,8   ;len-8
@@inner_lop:                    ;-for (i = n; i >= 1; i--) {
 sub   r8,8                     ;-dst-8 (starting from end)
 ldmia [r6],r0-r1               ;-get IV from dst+0
 ldmia [r8],r2-r3               ;-get DATA from dst+index
 eor   r1,r1,r4,lsl 24          ;-adjust byte[7] of IV (xor by count)
 stmia [sp],r0-r3               ;-store IV+DATA in tmpbuf
 mov   r11,sp   ;src            ;\
 mov   r12,sp   ;dst            ; aes_decrypt(tmpbuf)
 bl    aes_sw_be_decrypt_block  ;/
 ldmia [sp],r0-r3               ;-readback IV+DATA from tmpbuf
 stmia [r6],r0-r1               ;-writeback IV to dst+0
 stmia [r8],r2-r3               ;-writeback DATA to dst+index
 sub  r4,1  ;count-1
 subs r9,8  ;len-8
 bne  @@inner_lop
 cmp  r4,0  ;count
 bne  @@repeat_six_lop
;XXX could now verify IV at [dst+0..7], conventionally A6A6A6A6A6A6A6A6h
 add  sp,10h    ;dealloc tmpbuf
 pop  r4-r12,pc
;------------------
.pool
;------------------
;:----------------- DSi cypto selftest
;------------------
.if with_crypto_selftest
;------------------
wifi_selftest_md5:
 push lr
 sub  sp,10h  ;alloc dst
 ldr  r1,=txt_selftest_md5              ;\hello
 bl   wrstr_r1                          ;/
 ldr  r1,=wifi_md5sha1_mode             ;\
 mov  r0,0                              ; use MD5
 strb r0,[r1]                           ;/
 mov  r0,sp           ;dst              ;\
 ldr  r1,=test_data   ;src              ; calc md5
 mov  r2,test_datalen ;srclen           ;
 bl   md5_init_update_finish            ;/
 mov  r0,sp           ;dst              ;\
 ldr  r1,=test_md5                      ; wanted result
 mov  r2,10h          ;len              ;
 bl   memcompare_and_show_ok_bad        ;/
 ldr  r1,=wifi_md5sha1_mode             ;\
 mov  r0,1                              ; resume SHA1
 strb r0,[r1]                           ;/
 add  sp,10h  ;dealloc dst
 pop  pc
;------------------
wifi_selftest_sha1:
 push lr
 sub  sp,14h  ;alloc dst
 ldr  r1,=txt_selftest_sha1             ;\hello
 bl   wrstr_r1                          ;/
 mov  r0,sp           ;dst              ;\
 ldr  r1,=test_data   ;src              ; calc sha1
 mov  r2,test_datalen ;srclen           ;
 bl   sha1_init_update_finish           ;/
 mov  r0,sp           ;dst              ;\
 ldr  r1,=test_sha1                     ; wanted result
 mov  r2,14h          ;len              ;
 bl   memcompare_and_show_ok_bad        ;/
 add  sp,14h  ;dealloc dst
 pop  pc
;------------------
wifi_selftest_md5_hmac:   ;aka EAPOL MIC for WPA
 push lr
 sub  sp,10h  ;alloc dst
 ldr  r1,=txt_selftest_md5_hmac         ;\hello
 bl   wrstr_r1                          ;/
 ldr  r1,=wifi_md5sha1_mode             ;\
 mov  r0,0                              ; use MD5
 strb r0,[r1]                           ;/
 ldr  r0,=test_data             ;\src   ;\
 mov  r1,test_datalen           ;/      ;
 ldr  r2,=test_hmac_key         ;\key   ; calc MIC (aka HMAC)
 mov  r3,test_hmac_keylen       ;/      ;
 mov  r4,sp                     ;-dst   ;
 bl   calc_hmac_md5sha1                 ;/
 mov  r0,sp           ;dst              ;\
 ldr  r1,=test_md5_hmac                 ; wanted result
 mov  r2,10h          ;len              ;
 bl   memcompare_and_show_ok_bad        ;/
 ldr  r1,=wifi_md5sha1_mode             ;\
 mov  r0,1                              ; resume SHA1
 strb r0,[r1]                           ;/
 add  sp,10h  ;dealloc dst
 pop  pc
;------------------
wifi_selftest_sha1_hmac:   ;aka EAPOL MIC for WPA2 (that is, the first 10h bytes of the 14h-byte result are used as MIC)
 push lr
 sub  sp,14h  ;alloc dst
 ldr  r1,=txt_selftest_sha1_hmac        ;\hello
 bl   wrstr_r1                          ;/
 ldr  r0,=test_data             ;\src   ;\
 mov  r1,test_datalen           ;/      ;
 ldr  r2,=test_hmac_key         ;\key   ; calc MIC (aka HMAC)
 mov  r3,test_hmac_keylen       ;/      ;
 mov  r4,sp                     ;-dst   ;
 bl   calc_hmac_md5sha1                 ;/
 mov  r0,sp           ;dst              ;\wanted result
 ldr  r1,=test_sha1_hmac                ; (check all 14h bytes here,
 mov  r2,14h          ;len              ; though WPA2 MIC uses only 10h)
 bl   memcompare_and_show_ok_bad        ;/
 add  sp,14h  ;dealloc dst
 pop  pc
;------------------
wifi_selftest_psk_real_slow:
 push r4-r12,lr
 sub  sp,((test_psklen+test_ssidlen+4)+3) and not 3 ;alloc dst(20h)+src(max20h+4)
 ldr  r1,=txt_selftest_psk_slow         ;\hello
 bl   wrstr_r1                          ;/
 add  r1,sp,test_psklen ;src            ;\
 ldr  r0,=test_ssid                     ;
 mov  r2,test_ssidlen                   ;
 bl   memcopy_bytewise                  ;
 mov  r0,00h                            ; create src (ssid, 00h,00h,00h,01h)
 strb r0,[r1],1                         ;
 strb r0,[r1],1                         ;
 strb r0,[r1],1                         ;
 mov  r0,01h                            ;
 strb r0,[r1],1                         ;/
 add  r0,sp,test_psklen   ;\src         ;\
 mov  r1,test_ssidlen+4   ;/            ;
 ldr  r2,=test_password   ;\key         ;
 mov  r3,test_passwordlen ;/            ; calc PSK
 mov  r4,sp  ;dst         ;\dst         ;
 mov  r5,20h ;dstlen      ;/            ;
 mov  r6,4096 ;numrounds  ;-            ;    ;<-- this is SLOW
 bl   wifi_calc_prf     ;--->           ;/
 mov  r0,sp          ;dst               ;\
 ldr  r1,=test_psk   ;wanted            ; wanted result
 mov  r2,test_psklen ;dstlen            ;
 bl   memcompare_and_show_ok_bad        ;/
 add  sp,((test_psklen+test_ssidlen+4)+3) and not 3 ;dealloc dst(20h)+src(max20h+4)
 pop  r4-r12,pc
;------------------
wifi_selftest_psk_unreal_fast:
 push r4-r12,lr
 sub  sp,((test_psklen+test_ssidlen+4)+3) and not 3 ;alloc dst(20h)+src(max20h+4)
 ldr  r1,=txt_selftest_psk_fast         ;\hello
 bl   wrstr_r1                          ;/
 add  r1,sp,test_psklen ;src            ;\
 ldr  r0,=test_ssid                     ;
 mov  r2,test_ssidlen                   ;
 bl   memcopy_bytewise                  ;
 mov  r0,00h                            ; create src (ssid, 00h,00h,00h,01h)
 strb r0,[r1],1                         ;
 strb r0,[r1],1                         ;
 strb r0,[r1],1                         ;
 mov  r0,01h                            ;
 strb r0,[r1],1                         ;/
 add  r0,sp,test_psklen   ;\src         ;\
 mov  r1,test_ssidlen+4   ;/            ;
 ldr  r2,=test_password   ;\key         ;
 mov  r3,test_passwordlen ;/            ; calc PSK
 mov  r4,sp  ;dst         ;\dst         ;
 mov  r5,20h ;dstlen      ;/            ;
 mov  r6,4    ;numrounds  ;-            ;    ;<-- unreal FAST (doesn't produce a real working PSK, just for quick testing that multiple rounds do work)
 bl   wifi_calc_prf     ;--->           ;/
 mov  r0,sp                 ;dst        ;\
 ldr  r1,=test_psk_unreal   ;wanted     ; wanted result
 mov  r2,test_psklen        ;dstlen     ;
 bl   memcompare_and_show_ok_bad        ;/
 add  sp,((test_psklen+test_ssidlen+4)+3) and not 3 ;dealloc dst(20h)+src(max20h+4)
 pop  r4-r12,pc
;------------------
wifi_selftest_ptk:
 push r4-r12,lr
 sub  sp,100+64  ;=(22+1+6+6+32+32+1)+64   ;alloc nonces(100)+ptk(64)
 ldr  r1,=txt_selftest_ptk              ;\hello
 bl   wrstr_r1                          ;/
 ldr  r6,=test_mac                      ;\
 ldr  r7,=test_bssid                    ;
 mov  r0,r6                             ;
 mov  r1,r7                             ; get MAC's and sort min,max
 mov  r2,6  ;len                        ;
 bl   memcompare_bytewise               ;
 movhi r0,r6  ;\                        ;
 movhi r6,r7  ; swap r6,r7              ;
 movhi r7,r0  ;/                        ;/
 ldr  r8,=test_anonce                   ;\
 ldr  r9,=test_snonce                   ;
 mov  r0,r8                             ;
 mov  r1,r9                             ; get Nonces's and sort min,max
 mov  r2,32 ;len                        ;
 bl   memcompare_bytewise               ;
 movhi r0,r8  ;\                        ;
 movhi r8,r9  ; swap r8,r9              ;
 movhi r9,r0  ;/                        ;/
 mov  r1,sp   ;nonces                   ;-dst for MAC's and Nonce's
 ldr  r0,=pairwise_prefix               ;\
 mov  r2,pairwise_prefixlen             ; append "Pairwise key expansion",00h
 bl   memcopy_bytewise                  ;/
 mov  r0,r6   ;mac.min                  ;\
 mov  r2,6                              ; append smaller mac
 bl   memcopy_bytewise                  ;/
 mov  r0,r7   ;mac.max                  ;\
 mov  r2,6                              ; append bigger mac
 bl   memcopy_bytewise                  ;/
 mov  r0,r8   ;nonce.min                ;\
 mov  r2,32                             ; append smaller nonce
 bl   memcopy_bytewise                  ;/
 mov  r0,r9   ;nonce.max                ;\
 mov  r2,32                             ; append bigger nonce
 bl   memcopy_bytewise                  ;/
 mov  r0,00h                            ;\append 00h (initial count value)
 strb r0,[r1],1                         ;/
 mov  r0,sp  ;nonces    ;\src=prefix+AA+SPA+ANonce+SNonce+00h   ;\
 mov  r1,100 ;nonceslen ;/                                      ;
 ldr  r2,=test_psk      ;\key=PSK (aka PMK)                     ;
 mov  r3,test_psklen    ;/                                      ; calc PTK
 add  r4,sp,100  ;dst   ;\dst=PTK (PTK=64 bytes max)            ;
 mov  r5,64  ;ptklen    ;/                                      ;
 mov  r6,1              ;-numrounds=1                           ;
 bl   wifi_calc_prf     ;---> calc PTK                          ;/
 add  r0,sp,100      ;dst               ;\
 ldr  r1,=test_ptk   ;wanted            ; wanted result
 mov  r2,test_ptklen ;dstlen            ;
 bl   memcompare_and_show_ok_bad        ;/
 add  sp,100+64  ;=(22+1+6+6+32+32+1)+64   ;dealloc nonces(100)+ptk(64)
 pop  r4-r12,pc
;------------------
wifi_selftest_pmkid:   ;PMKID = HMAC-SHA1-128(PMK, "PMK Name" || AA || SPA)
 push r4-r12,lr
 sub  sp,@@alloc_size
@@tmp_src    equ 00h  ;14h ;8+6+6 (prefix+BSSID+MAC)
@@tmp_dst    equ 14h  ;14h ;14h (sha1)
@@alloc_size equ 28h
 ldr  r1,=txt_selftest_pmkid            ;\hello
 bl   wrstr_r1                          ;/
 add  r1,sp,@@tmp_src         ;-        ;\
 ldr  r0,=pmkid_prefix        ;\        ;
 mov  r2,pmkid_prefixlen      ; prefix  ;
 bl   memcopy_bytewise        ;/        ; create src (prefix+BSSID+MAC)
 ldr  r0,=test_bssid          ;\BSSID   ;
 bl   arm7_Wifi_CopyMacAddr   ;/        ;
 ldr  r0,=test_mac            ;\MAC     ;
 bl   arm7_Wifi_CopyMacAddr   ;/        ;/
 add  r0,sp,@@tmp_src   ;\src=txt+MAC's ;\
 mov  r1,8+6+6  ;srclen ;/              ;
 ldr  r2,=test_pmk      ;\key=PMKakaPSK ; calc SHA1-HMAC on src
 mov  r3,32  ;pmklen    ;/              ; with key=PMK (aka PSK)
 add  r4,sp,@@tmp_dst                   ;
 bl   calc_hmac_md5sha1                 ;/
 add  r0,sp,@@tmp_dst                   ;\
 ldr  r1,=test_pmkid   ;wanted          ; wanted result
 mov  r2,test_pmkidlen ;dstlen          ;
 bl   memcompare_and_show_ok_bad        ;/
 add  sp,@@alloc_size
 pop  r4-r12,pc
;------------------
wifi_selftest_eapol_rc4:
 push r4-r12,lr
 sub  sp,20h+20h  ;alloc GTK dest and IV+KEK src
 ldr  r1,=txt_selftest_eapol_rc4        ;\hello
 bl   wrstr_r1                          ;/
 mov  r1,sp                             ;\
 ldr  r0,=test_wpa_eapol_iv  ;src (IV)  ;
 mov  r2,test_wpa_eapol_ivlen           ; create RC4 key (EAPOL Key IV + KEK)
 bl   memcopy_bytewise                  ;
 ldr  r0,=test_kek           ;key (KEK) ;
 mov  r2,test_keklen                    ;
 bl   memcopy_bytewise                  ;/
 ldr  r0,=test_gtk   ;src (GTK raw)     ;\
 add  r1,sp,20h      ;dst (GTK crypted) ;
 mov  r2,test_gtklen ;len (src/dst)     ;
 mov  r3,sp          ;key    (IV+KEK)   ; encrypt
 mov  r4,10h+10h     ;keylen (IV+KEK)   ;
 mov  r5,100h        ;preskip (100h)    ;
 bl   wifi_rc4_crypt                    ;/
 add  r0,sp,20h        ;dst             ;\
 ldr  r1,=test_gtk_rc4_crypted ;wanted  ; wanted result
 mov  r2,test_gtklen   ;dstlen          ;
 bl   memcompare_and_show_ok_bad        ;/
 add  sp,20h+20h  ;dealloc GTK dest and IV+KEK src
 pop  r4-r12,pc
;------------------
wifi_selftest_eapol_aes_wrap:
 push r4-r12,lr
 sub  sp,test_gtk_aes_decryptedlen
 ldr  r1,=txt_selftest_aes_wrap         ;\hello
 bl   wrstr_r1                          ;/
 ldr  r0,=test_kek   ;key (KEK)    ;key ;\
 ldr  r1,=test_gtk_aes_decrypted   ;src ;
 mov  r2,sp                        ;dst ; wrap (encrypt)
 mov  r3,test_gtk_aes_decryptedlen ;len ;
 bl   aes_sw_be_wrap                    ;/
 mov  r0,sp                      ;dst   ;\
 ldr  r1,=test_gtk_aes_encrypted ;wanted; wanted result
 mov  r2,test_gtk_aes_decryptedlen ;len ;
 bl   memcompare_and_show_ok_bad        ;/
 add  sp,test_gtk_aes_decryptedlen
 pop  r4-r12,pc
;------------------
wifi_selftest_eapol_aes_unwrap:
 push r4-r12,lr
 sub  sp,test_gtk_aes_decryptedlen
 ldr  r1,=txt_selftest_aes_unwrap       ;\hello
 bl   wrstr_r1                          ;/
 ldr  r0,=test_kek   ;key (KEK)    ;key ;\
 ldr  r1,=test_gtk_aes_encrypted   ;src ;
 mov  r2,sp                        ;dst ; unwrap (decrypt)
 mov  r3,test_gtk_aes_decryptedlen ;len ;
 bl   aes_sw_be_unwrap                  ;/
 mov  r0,sp                      ;dst   ;\
 ldr  r1,=test_gtk_aes_decrypted ;wanted; wanted result
 mov  r2,test_gtk_aes_decryptedlen ;len ;
 bl   memcompare_and_show_ok_bad        ;/
 add  sp,test_gtk_aes_decryptedlen
 pop  r4-r12,pc
;------------------
memcompare_and_show_ok_bad:  ;in: r0/r1=src, r2=len
 push lr
 bl   memcompare_bytewise
 ldreq r1,=txt_selftest_ok
 ldrne r1,=txt_selftest_bad
 bl   wrstr_r1
 pop  pc
;------------------
test_data         db 'data'
test_datalen      equ $-test_data
;---
test_hmac_key     db 'key'
test_hmac_keylen  equ $-test_hmac_key
;---
test_ssid         db 'connect-here'
test_ssidlen      equ $-test_ssid
;---
test_password     db 'secret-secret'
test_passwordlen  equ $-test_password
;---
.align 4
;---
test_bssid:      .hexdat 0123456789AB   ;MAC from AP
test_mac:        .hexdat 001122334455   ;MAC from console
test_anonce:     .hexdat 8888888899999999AAAAAAAABBBBBBBBCCCCCCCCDDDDDDDDEEEEEEEEFFFFFFFF  ;random nonce from AP
test_snonce:     .hexdat 0000000011111111222222223333333344444444555555556666666677777777  ;random nonce from console
;---
test_md5:        .hexdat 8D777F385D3DFEC8815D20F7496026DC ;for "data"
test_md5_hmac:   .hexdat 9D5C73EF85594D34EC4438B7C97E51D8 ;for "data" and "key"
test_sha1:       .hexdat A17C9AAA61E80A1BF71D0D850AF4E5BAA9800BBD ;for "data"
test_sha1_hmac:  .hexdat 104152C5BFDCA07BC633EEBD46199F0255C9F49D ;for "data" and "key"
;---
test_psk_unreal: .hexdat ED10F99A29A2336765206DDD9AC13E52C2B14AA4B63D73904B7272D1A86FD9CA  ;for "connect-here" and "secret-secret" (with only 4 rounds for fast testing, though not producing an actual/working PSK)
test_psk:        .hexdat F7EAC777C59D1A9B434A4DC3F9CABDD659140317F6ADFAF1E4D515E83002BE7B  ;for "connect-here" and "secret-secret" (with 4096 rounds)
test_psklen      equ $-test_psk  ;=20h
;---
test_pmk         equ test_psk
test_pmklen      equ test_psklen ;=20h
;---
test_ptk:                                                          ;\
 test_kck:       .hexdat 1F99E5FA70E1C06AB51ECCD25F8E96B8          ; based on
 test_kek:       .hexdat 96989E40B9693197B272B242ABBBF186          ; PSK and
 test_tk_key:    .hexdat A49057E09BFC8D43582DE8BDF7FA2940          ; nonces
 test_tk_tx:     .hexdat 94CB629E88EE193D  ;\needed for WPA only   ;
 test_tk_rx:     .hexdat C161F8BA669111B6  ;/(not for WPA2)        ;
test_ptklen      equ $-test_ptk  ;=40h (for WPA)                   ;/
test_kcklen      equ 10h
test_keklen      equ 10h
test_tk_keylen   equ 10h
test_tk_txlen    equ 8h
test_tk_rxlen    equ 8h
;---
test_gtk:                                                          ;\
 test_gtk_key:   .hexdat 33336666333366663333666633336666          ; as whatever
 test_gtk_tx:    .hexdat 4444555511112222  ;\needed for WPA only   ; from AP
 test_gtk_rx:    .hexdat 5555444411113333  ;/(not for WPA2)        ;
test_gtklen      equ $-test_gtk  ;=20h (for WPA)                   ;/
;---
test_pmkid:      .hexdat 419EC83EEB22E476F55910256A37441A  ;for PMK and bssid+mac
test_pmkidlen    equ $-test_pmkid  ;=10h
;---
test_wpa_eapol_iv:    .hexdat 11115555111155551111555511115555
test_wpa_eapol_ivlen  equ $-test_wpa_eapol_iv
;---
test_gtk_rc4_crypted: .hexdat 0835906748D6616AC6B7C23DC22D7BCC4BB5979AF5CF0CC55FC66BC13BDFC102
;---
test_gtk_aes_decrypted:  ;as from Groupkey Handshake (4-way would additionally contain a RSNIE element and padding)
 .hexdat A6A6A6A6A6A6A6A6       ;IV for AES wrap
 .hexdat DD16000FAC010200       ;ElementKDE,OuiGTK,KeyID,Reserved
 .hexdat 33336666333366663333666633336666 ;GTK (as for WPA)
test_gtk_aes_decryptedlen equ $-test_gtk_aes_decrypted
;---
test_gtk_aes_encrypted:
 .hexdat 3C33AA7F212060B6DB9AAF3E9EEA348246EA2B91EBEDA9C699CB373459F15BDC
;------------------
txt_selftest_md5        db 'TEST MD5              :',0
txt_selftest_md5_hmac   db 'TEST MD5 HMAC (WPA)   :',0
txt_selftest_sha1       db 'TEST SHA1             :',0
txt_selftest_sha1_hmac  db 'TEST SHA1 HMAC (WPA2) :',0
txt_selftest_psk_slow   db 'TEST PSK (SLOW/REAL)  :',0
txt_selftest_psk_fast   db 'TEST PSK (FAST/UNREAL):',0
txt_selftest_ptk        db 'TEST PTK (KCK,KEK,TK) :',0
txt_selftest_pmkid      db 'TEST PMKID (BLAH)     :',0
txt_selftest_eapol_rc4  db 'TEST GTK (WPA/RC4)    :',0
txt_selftest_aes_wrap   db 'TEST GTK (WPA2/WRAP)  :',0
txt_selftest_aes_unwrap db 'TEST GTK (WPA2/UNWRAP):',0
txt_selftest_ok         db 'OK',0dh,0
txt_selftest_bad        db 'BAD',0dh,0
.align 4
;------------------
.endif ;with_crypto_selftest
;------------------
;:----------------- dslink arm9-main.c
;------------------
;;;extern char _start[];
;------------------
.data?
sa_tcp:         defs sgSoin_size
sa_udp:         defs sgSoin_size
sa_udp_remote:  defs sgSoin_size
sock_tcp        dd 0    ;\
sock_udp        dd 0    ;
sock_tcp_remote dd 0    ;/
dummy           dd 0
val_gateway     dd 0
val_subnet      dd 0
val_dns1        dd 0
val_dns2        dd 0
val_ip          dd 0
recvbuf_size    equ 256
recvbuf:        defs recvbuf_size
DSLINK_PORT     equ 5344h  ;htons(17491) aka htons(4453h)
cmdline         dd 0
cmdlen          dd 0
response        dd 0
dsi_flag        dd 0
.code
;------------------
.if vram_code
arm9_dupe_vram_code_to_arm7_side:
 push lr
 ldr  r0,=6020000h              ;\
 ldr  r1,=6860000h              ;
 ldr  r2,=20000h                ;
 bl   memcopy_bytewise          ;/
 bl   arm9_cache_FlushAll       ;-flush cache before below vram remapping
 mov  r1,4000000h
 mov  r0,81h       ;vram A, mst=1, ofs=0, enable, BG at 6000000h (for Engine A)
 add  r0,8900h     ;vram B, mst=1, ofs=1, enable, BG at 6020000h (for ARM9 code/data)
 add  r0,840000h   ;vram C, mst=4, ofs=0, enable, BG at 6200000h (for Engine B)
 add  r0,8a000000h ;vram D, mst=2, ofs=1, enable, ARM7 at 6020000h (for ARM7 code/data)
 str  r0,[r1,240h] ;;vramcnt_abcd
 pop  pc
.endif
;------------------
arm9_main:
 ldr  r1,=4000000h+204h ;\
 mov  r0,6000h          ; EXMEMCNT, access rights/prio to ARM9
 strh r0,[r1]           ;/

 bl   arm9_init_cp15                    ;-
;;; bl   arm9_cache_FlushAll  ;and wbuffer ;-uhmmm... this/here had once helped depending on boot time??? shouldn't be needed here though
 ldr  r0,=vardata_start                 ;\
 ldr  r1,=vardata_end-vardata_start     ; zerofill
 bl   zerofill_bytewise                 ;/
 bl   arm9_cache_FlushAll  ;and wbuffer ;-pass zerofill to ARM7 side
 bl   arm9_detect_dsi

 bl   arm9_initDisplay
 bl   arm9_irqInit
 bl   arm9_fifoInit
 bl   arm9_dump_blowfish_key
.if vram_code
 bl   arm9_dupe_vram_code_to_arm7_side  ;after "arm9_dump_blowfish_key", before sync(E)
.endif

 mov  r0,IRQ_IPC_SYNC                           ;\
 bl   arm9_irqEnable                            ;/
;- - - -
 mov  r0,0Eh                                    ;\sync(E) indicate memfill done
 bl   arm9_ipc_sync                             ;/

 ldr  r1,=txt_connecting                ;\
 bl   wrstr_r1                          ;/
 mov  r0,WFC_CONNECT                    ;\
 bl   arm9_Wifi_InitDefault             ;
 cmp  r0,0                              ;
 beq  @@connect_failed                  ;/
;- - -
 ldr  r0,=val_gateway                   ;\
 ldr  r1,=val_subnet                    ;
 ldr  r2,=val_dns1                      ;
 ldr  r3,=val_dns2                      ;
 bl   arm9_Wifi_GetIPInfo               ;
 ldr  r1,=val_ip                        ;
 str  r0,[r1]                           ;/
 ldr  r1,=txt_connected                 ;\
 bl   wrstr_r1                          ;/
;bl   kprintf(inet_ntoa(val_ip))
 bl   sgIP_Hub_GetDefaultInterface      ;\get hardware interface
 mov  r4,r0  ;HubHwi                    ;/
;- - - -
       ;ldr  r1,=REGBASE_SCFG
       ;ldr  r0,[r1,REG_SCFG_EXT9]
       ;bl   wrhex32bit // bl wrcrlf
       ;orr  r0,1 shl 13  ;ext vram access (already on)
       ;bl   wrhex32bit // bl wrcrlf
       ;str  r0,[r1,REG_SCFG_EXT9]

       ;ldr  r1,=REGBASE_SCFG
       ;ldr  r0,[r1,REG_SCFG_CLK9]
       ;bl   wrhex32bit // bl wrcrlf
       ;orr  r0,1 shl 0   ;arm9 cpu clk (notyet on) (XXX change within ITCM)
       ;bl   wrhex32bit // bl wrcrlf
       ;str  r0,[r1,REG_SCFG_CLK9]


 ldr  r1,=txt_ip                        ;\
 bl   wrstr_r1                          ; show console's IP
 ldr  r0,[r4,sgHubHwi_ipaddr]           ;
 bl   wripaddr                          ;/
 bl   wrcrlf
 ldr  r1,=txt_subnet                    ;\
 bl   wrstr_r1                          ; show subnet mask
 ldr  r0,[r4,sgHubHwi_snmask]           ;
 bl   wripaddr                          ;/
 bl   wrcrlf
 ldr  r1,=txt_gateway                   ;\
 bl   wrstr_r1                          ; show gateway
 ldr  r0,[r4,sgHubHwi_gateway]          ;
 bl   wripaddr                          ;/
 bl   wrcrlf
 ldr  r1,=txt_dns                       ;\
 bl   wrstr_r1                          ; show dns
 ldr  r0,[r4,sgHubHwi_dns+0]  ;DNS[0]   ;
 bl   wripaddr                          ;/
 bl   wrcrlf
;- - - -
 mov  r0,PF_INET                        ;\
 mov  r1,SOCK_DGRAM                     ;
 mov  r2,0                              ; UDP socket
 bl   socket                            ;
 ldr  r1,=sock_udp                      ;
 str  r0,[r1]                           ;/
 ldr  r1,=sa_udp                        ;\
 mov  r0,AF_INET                ;\      ;
 strh r0,[r1,sgSoin_sin_family] ;/      ;
 ldr  r0,=DSLINK_PORT           ;\      ; UDP addr
 strh r0,[r1,sgSoin_sin_port]   ;/      ;
 mov  r0,INADDR_ANY             ;\      ;
 str  r0,[r1,sgSoin_sin_addr]   ;/      ;/
 ldr  r0,=sock_udp                      ;\
 ldr  r0,[r0]                           ;
 ldr  r1,=sa_udp                        ;
 mov  r2,sgSoin_size                    ; UDP bind
 bl   bind                              ;
 cmp  r0,-1                             ;
 beq  @@udp_socket_error                ;/
 ldr  r0,=sock_udp                      ;\
 ldr  r0,[r0]                           ;
 mov  r1,FIONBIO                        ; UDP ioctl
 ldr  r2,=const_00000001h               ;
 bl   ioctl                             ;/
;- - - -
@@udp_lop:
 bl   freshen_rssi_display              ;-
 ldr  r0,=sock_udp                      ;\
 ldr  r0,[r0]                           ;
 ldr  r1,=recvbuf                       ;
 mov  r2,recvbuf_size                   ;
 mov  r3,0                              ; UDP recv
 ldr  r4,=sa_udp_remote                 ;
 ldr  r5,=dummy                         ;
 bl   recvfrom                          ;
 cmp  r0,-1                             ;
 beq  @@no_udp_message                  ;/
 ldr  r0,=txt_dsboot                    ;\
 ldr  r1,=recvbuf                       ;
 mov  r2,6  ;len                        ; check ID "dsboot"
 bl   memcompare_bytewise               ;
 cmp  r2,0                              ;
 bne  @@wrong_udp_message               ;/

                 ldr  r0,=sock_tcp                    ;\
                 ldr  r0,[r0]                         ;
                 cmp  r0,0                            ;
                 bleq @@start_tcp                     ;/

 ldr  r1,=sa_udp_remote                 ;\              ;\
 mov  r0,AF_INET                ;\      ;               ;
 strh r0,[r1,sgSoin_sin_family] ;/      ;               ;
 ldr  r0,=DSLINK_PORT           ;\      ; UDP resp addr ;
 strh r0,[r1,sgSoin_sin_port]   ;/      ;               ;
;mov  r0,(kept as from recvfrom);\      ;               ; send UDP reply
;str  r0,[r1,sgSoin_sin_addr]   ;/      ;/              ;
       ;ldr  r0,[r1,sgSoin_sin_addr]
       ;bl wrhex32bit
 ldr  r0,=sock_udp                      ;\              ;
 ldr  r0,[r0]                           ;               ;
 ldr  r1,=txt_bootds                    ;               ;
 mov  r2,6  ;txt.len                    ; UDP send      ;
 mov  r3,0                              ;               ;
 ldr  r4,=sa_udp_remote                 ;               ;
 mov  r5,sgSoin_size                    ;               ;
 bl   sendto                            ;/              ;/

        ;bl wrhex32bit  ;XNAY

@@wrong_udp_message:
@@no_udp_message:
.if with_tcp
 ldr  r0,=sock_tcp                      ;\
 ldr  r0,[r0]                           ;
        cmp r0,0
        beq @@no_tcp_yet
 ldr  r1,=sa_tcp                        ;
 ldr  r2,=dummy                         ; TCP accept
 bl   accept                            ;
 ldr  r1,=sock_tcp_remote               ;
 str  r0,[r1]                           ;
 cmp  r0,-1                             ;
 bne  @@got_tcp_accept     ;---->       ;/
        @@no_tcp_yet:
.endif
 bl   arm9_Halt
 b    @@udp_lop
;- - - -
@@got_tcp_accept:
 ldr  r1,=txt_remote_ip                 ;\
 bl   wrstr_r1                          ;
 ldr  r1,=sa_udp_remote                 ; show remote IP addr
 ldr  r0,[r1,sgSoin_sin_addr]           ;
 bl   wripaddr                          ;/
 bl   wrcrlf

     ldr  r0,=sock_udp                      ;\
     ldr  r0,[r0]                           ;
     bl   closesocket                       ;/

        .if 0 ;XNAY
        mov r0,'!' // bl wrchr_r0
        mov r0,'!' // bl wrchr_r0
        mov r0,'!' // bl wrchr_r0
        mov r0,'!' // bl wrchr_r0
        mov r0,'!' // bl wrchr_r0
        mov r0,'!' // bl wrchr_r0
        mov r0,'!' // bl wrchr_r0
        mov r0,'!' // bl wrchr_r0
        mov r0,'!' // bl wrchr_r0
        ;b $
       .endif

 b    @@loadNDS
;  loadNDS(sock_tcp_remote,sa_tcp.sin_addr.s_addr)
;  closesocket(sock_tcp_remote)   ;BLAH

;------------------
@@loadNDS:  ;(int socket aka sock_tcp_remote, u32 remote aka sa_tcp.sin_addr, out: r0
 ldr  r12,=__NDSHeader          ;-
 ldr  r0,=sock_tcp_remote       ;\
 ldr  r0,[r0]                   ;
 mov  r1,FIONBIO                ; ioctl
 ldr  r2,=const_00000000h       ;
 bl   ioctl                     ;/
 ldr  r0,=sock_tcp_remote       ;\
 ldr  r0,[r0]                   ;
 mov  r1,r12  ;header+0         ;
 mov  r2,200h                   ; recv short NDS header
 mov  r3,0                      ;
 bl   recvall                   ;
 cmp  r0,200h                   ;
 bne  @@recv_header_error       ;/
 mov  r0,r12  ;header+0         ;\
 ldr  r1,=__DSiHeader           ; initially copy/dupe NDS header
 mov  r2,160h                   ; to DSi header, with zeropadding
 bl   memcopy_bytewise          ; (will be overwritten later on below
 ldr  r0,=__DSiHeader+160h      ; if actual DSi header received, if any)
 mov  r1,1000h-160h             ;
 bl   zerofill_bytewise         ;/
 ldr  r1,=__DSiHeader+1AFh      ;\put default WRAMCNT into non-DSi-cart-header
 mov  r0,3                      ; (will be overwritten later on below
 strb r0,[r1]                   ;/if actual DSi header received, if any)

 mov  r1,r12  ;header           ;\
 mov  r2,0ch                    ; show TITLE from header
 bl   wrstr_r1_len_r2           ;
 bl   wrcrlf                    ;/

 ldr  r1,=dsi_flag              ;\
 ldrb r0,[r1]  ;0=nds, 1=dsi    ;
 ldrb r1,[r12,12h] ;unitcode    ; init response 4/2018
 and  r0,r0,r1,lsr 1            ; with bit16=(HeaderIsDSi and ConsoleIsDSi)
 mov  r0,r0,lsl 16    ;bit16    ;
 ldr  r1,=response              ;
 str  r0,[r1]                   ;/

.comment
        if (arm9dest + arm9size > (int)_start) response = 1;
        if (arm7dest >= 0x02000000 && arm7dest < 0x03000000 && arm7dest + arm7size > (int)_start) response = 2;
.comment

.if with_tcp
 ldr  r0,=sock_tcp_remote       ;\
 ldr  r0,[r0]                   ;
 ldr  r1,=response              ; send response
 mov  r2,4  ;len                ;
 mov  r3,0  ;flags              ;
 bl   send                      ;/
.endif

.comment
        if(response) return 1;
.comment
;- - -
 ldr  r1,=response              ;\
 ldr  r0,[r1]                   ;
 tst  r0,1 shl 16               ; DSi version: 4/2018
 beq  @@skip_dsi_header         ;
 ldr  r0,=sock_tcp_remote       ; ;\
 ldr  r0,[r0]                   ; ;
 ldr  r1,=__DSiHeader           ; ;
 mov  r2,1000h                  ; ; recv full DSi header
 mov  r3,0                      ; ;
 bl   recvall                   ; ;
 cmp  r0,1000h                  ; ;
 bne  @@recv_header_error       ; ;/
@@skip_dsi_header:              ;/
;- - -
 bl   progressStart
;- - -
 ldr  r1,=txt_reading_arm7_binary       ;\
 bl   wrstr_r1                          ;/
 ldr  r0,=sock_tcp_remote       ;\
 ldr  r0,[r0]                   ;
 mov  r1,2000000h + 0c00000h    ;
 ldr  r2,[r12,3ch] ;arm7siz     ; recv ARM7 binary
 bl   progressRead              ;
 cmp  r0,0                      ; and
 bne  @@recv_error              ; relocate it to ARM7 side...
 mov  r0,01h                    ;               ;\sync(1) request arm7 memcopy
 bl   arm9_ipc_sync             ;               ;/
 mov  r0,02h                    ;               ;\sync(2) confirm arm7 memcopy
 bl   arm9_ipc_sync             ;/              ;/
;- - -
 ldr  r1,=txt_reading_arm9_binary       ;\
 bl   wrstr_r1                          ;/
 bl   arm9_map_mbk_normal       ;\
 ldr  r0,=sock_tcp_remote       ;
 ldr  r0,[r0]                   ;
 ldr  r1,[r12,28h] ;arm9dst     ; recv ARM9 binary
 ldr  r2,[r12,2ch] ;arm9siz     ;
 bl   progressRead              ;
 cmp  r0,0                      ;
 bne  @@recv_error              ;/
 ldr  r11,=__NDSHeader                  ;\blowfish decrypt secure area (if any)
 bl   secure_area_extra_decryption      ;/
;- - -
 ldr  r1,=response              ;\
 ldr  r0,[r1]                   ;
 tst  r0,1 shl 16               ; DSi version: 4/2018
 beq  @@skip_dsi_areas          ;
 ldr  r1,=txt_reading_arm9i_binary;\
 bl   wrstr_r1                  ; ;/
 bl   arm9_map_mbk_swapped      ; ;\  ;<-- XXX or better relocate it on ARM7 side (that would include support for ARM7 memory at 38xxxxxh)
 ldr  r0,=sock_tcp_remote       ; ;
 ldr  r0,[r0]                   ; ;
 ldr  r1,[r12,1d8h] ;arm7idst   ; ; recv ARM7i binary
 ldr  r2,[r12,1dch] ;arm7isiz   ; ;
 bl   progressRead              ; ;
 cmp  r0,0                      ; ;
 bne  @@recv_error              ; ;/
 ldr  r1,=txt_reading_arm7i_binary;\
 bl   wrstr_r1                  ; ;/

 bl   arm9_map_mbk_normal       ; ;\
 ldr  r0,=sock_tcp_remote       ; ;
 ldr  r0,[r0]                   ; ;
 ldr  r1,[r12,1c8h] ;arm9idst   ; ; recv ARM9i binary
 ldr  r2,[r12,1cch] ;arm9isiz   ; ;
 bl   progressRead              ; ;
 cmp  r0,0                      ; ;
 bne  @@recv_error              ; ;/
@@skip_dsi_areas:               ;/
;- - -
 ldr  r1,=cmdlen                ;\
 mov  r0,0                      ; cmdlen init
 str  r0,[r1]                   ;/
 ldr  r0,=sock_tcp_remote       ;\
 ldr  r0,[r0]                   ;
 ldr  r1,=cmdlen                ;
 mov  r2,4                      ; recv cmdline len
 mov  r3,0                      ;
 bl   recvall                   ;
;cmp  r0,4   ;allow LESS !?!    ;
;bne  @@recv_cmdlen_error       ;/
 ldr  r0,=cmdlen                ;\
 ldr  r0,[r0]                   ;
 cmp  r0,0                      ;
 beq  @@no_cmdline              ;/

 ldr  r0,[r12,28h] ;arm9dst     ;\
 ldr  r1,[r12,2ch] ;arm9siz     ;
 cmp  r1,0                      ;
 ldreq r0,[r12,38h] ;arm7dst    ; cmdline dest
 ldreq r1,[r12,3ch] ;arm7siz    ;
 add  r0,r1  ;dst+siz           ;
 ldr  r1,=cmdline               ;
 str  r0,[r1]                   ;/
 ldr  r0,=sock_tcp_remote       ;\
 ldr  r0,[r0]                   ;
 ldr  r1,=cmdline               ;
 ldr  r1,[r1]                   ;
 ldr  r2,=cmdlen                ; recv cmdline
 ldr  r2,[r2]                   ;
 mov  r3,0                      ;
 bl   recvall                   ;
;mov  len,r0                    ;/
 ldr  r0,=ARGV_MAGIC            ;\
 str  r0,[r12,Argv_argvMagic]   ;/
 ldr  r0,=cmdline               ;\
 ldr  r0,[r0]                   ;
 str  r0,[r12,Argv_commandline] ;/
 ldr  r0,=cmdlen                ;\
 ldr  r0,[r0]                   ;
 str  r0,[r12,Argv_length]      ;/
 ldr  r0,=sa_tcp                ;\
 ldr  r0,[r0,sgSoin_sin_addr]   ; remote ip
 str  r0,[r12,Argv_host]        ;/
@@no_cmdline:
;- - -
 bl   arm9_Wifi_DisableWifi
 bl   arm9_cache_FlushAll       ;-flush cache and write buffer
 mov  r0,03h                                    ;\sync(3) boot
 bl   arm9_ipc_sync                             ;/
 mov  r0,04h                                    ;\sync(4) reboot
 bl   arm9_ipc_sync                             ;/
 b    arm9_boot_loaded_file
;---
@@connect_failed:
 ldr  r1,=txt_failed_to_connect
 bl   wrstr_r1
 b    $
;---
@@udp_socket_error:
 ldr  r1,=txt_udp_socket_error
 bl   wrstr_r1
 b    $
;---
@@recv_header_error:
 ldr  r1,=txt_error_reading_header
 bl   wrstr_r1
;return 1
 b    $
;---
@@recv_error:
 ldr  r1,=txt_receive_error
 bl   wrstr_r1
;return 1;
 b    $

;---
@@start_tcp:
 push lr
 mov  r0,AF_INET                        ;\
 mov  r1,SOCK_STREAM                    ;
 mov  r2,0                              ; TCP socket
 bl   socket                            ;
 ldr  r1,=sock_tcp                      ;
 str  r0,[r1]                           ;/
 ldr  r1,=sa_tcp                        ;\
 mov  r0,AF_INET                ;\      ;
 strh r0,[r1,sgSoin_sin_family] ;/      ;
 ldr  r0,=DSLINK_PORT           ;\      ; TCP addr
 strh r0,[r1,sgSoin_sin_port]   ;/      ;
 mov  r0,INADDR_ANY             ;\      ;
 str  r0,[r1,sgSoin_sin_addr]   ;/      ;/
 ldr  r0,=sock_tcp                      ;\
 ldr  r0,[r0]                           ;
 ldr  r1,=sa_tcp                        ;
 mov  r2,sgSoin_size                    ; TCP bind
 bl   bind                              ;
;cmp  r0,-1                             ;
;beq  @@tcp_socket_error                ;/
 ldr  r0,=sock_tcp                      ;\
 ldr  r0,[r0]                           ;
 mov  r1,FIONBIO                        ; TCP ioctl
 ldr  r2,=const_00000001h               ;
 bl   ioctl                             ;/
.if with_tcp
 ldr  r0,=sock_tcp                      ;\
 ldr  r0,[r0]                           ; TCP listen
 mov  r1,2      ;max_connections        ;
 bl   listen                            ;/
.endif
 pop  pc
;------------------
.pool
;------------------
arm9_boot_loaded_file:
 mov  r4,4000000h               ;-
 bl   arm9_cache_FlushAll       ;-flush cache and write buffer   ;<-- THIS helps on wifiboot+vram_code issues? (else eragon whitescreens after each 3rd upload)
 mov  r0,IRQ_ALL                ;\
 bl   arm9_irqDisable           ;/
 mov  r0,0                      ;\
 str  r0,[r4,REG_IME]           ;/

 mov  r0,4000000h               ;\
 mov  r1,4eh                    ; clear LCD_A's I/O ports
 bl   zerofill_bytewise         ;/
 add  r0,r4,1000h               ;\
 mov  r1,4eh                    ; clear LCD_B's I/O ports
 bl   zerofill_bytewise         ;/
 add  r1,r4,1000h               ;\
 mov  r0,100h                   ;
 str  r0,[r4,20h] ;BG2P'LCD_A   ; default nonzero scaling
 str  r0,[r1,20h] ;BG2P'LDB_B   ; values for LCD A+B
 mov  r0,1000000h               ;
 str  r0,[r4,24h] ;BG3P'LCD_A   ;
 str  r0,[r1,24h] ;BG3P'LDB_B   ;/
 mov  r0,0                      ;\
 strh r0,[r4,0bah] ;DMA0CNT     ;
 strh r0,[r4,0c6h] ;DMA1CNT     ; stop DMA
 strh r0,[r4,0d2h] ;DMA2CNT     ;
 strh r0,[r4,0deh] ;DMA3CNT     ;/
 add  r0,r4,0b0h                ;\
 mov  r1,30h+10h                ; clear DMA
 bl   zerofill_bytewise         ;/
 add  r0,r4,100h                ;\
 mov  r1,10h                    ; clear timers
 bl   zerofill_bytewise         ;/

 .if vram_code=0
   bl   arm9_zerofill_and_disable_all_vram
 .endif

.comment
        dmaFillWords(0, BG_PALETTE, (2*1024))
        VRAM_A_CR = 0x80
        dmaFillWords(0, VRAM, 128*1024)
.comment


   mov  r0,cpsr                   ;\cpu interrupt disable (set i flag)
   orr  r0,r0,80h                 ; done BEFORE "enter_nds_mode" (so ARM7 can
   mov  cpsr,r0                   ;/switch to NDS ROM without SWI/IRQ issues)
 mov  r0,07h                    ;\sync(7)
 bl   arm9_ipc_sync             ;/
 bl   arm9_enter_nds_mode       ;-switch to NDS mode if needed



        mov  r0,1
        str  r0,[r4,298h] ;divdenom
        strb r0,[r4,300h] ;postflg

         ldr  r0,=820fh                 ;\init powcnt
         str  r0,[r4,304h] ;POWCNT1     ;/(must be before palette/oam memclear, 6/2007)

          ldr r0,=0e880h
          mov r1,204h      ;EXMEMCNT
          strh r0,[r4,r1]

        ;;; add  r10,=nds9_memclear_list   ;\
        ;;; bl   memclear_by_list          ;/


;;; mov  r0,00h                    ;\sync(0)
;;; bl   arm9_ipc_sync             ;/
 mov  r0,cpsr                   ;\
 orr  r0,r0,80h                 ; cpu interrupt disable (set i flag)
 mov  cpsr,r0                   ;/
 mov  r0,0                      ;\
 str  r0,[r4,REG_IME]           ; disable ALL irq's
 str  r0,[r4,REG_IE]            ;/
 mov  r0,-1                     ;\acknowledge irq's
 str  r0,[r4,REG_IF]            ;/
 ldr  r0,=0101h                 ;\
 str  r0,[r4,REG_IPC_FIFO_CNT]  ;/


;- - - "itcm_reset_code..."
   @@reloc_dst equ 23FEE00h
    ldr  r0,=@@reloc_src
    ldr  r1,=@@reloc_dst
    ldr  r2,=@@reloc_len
    bl   memcopy_bytewise
    bl   arm9_cache_FlushAll       ;-writeback write-buffer cache
    ldr  r1,=@@reloc_dst
    bx   r1
   ;---
   .pool
   ;---
   @@reloc_src:
   org @@reloc_dst

;- - - -
    mov  r0,0fh                 ;\sync(F) wait till vram_code is no longer used
    bl   @@sync_r0              ;/

.if vram_code
 ; ldr  r1,=2fffc40h                              ;\
 ; ldrh r0,[r1]  ;boot indicator                  ;
 ; cmp  r0,00ffh  ;RELAUNCH                       ;
 ; blne @@arm9_zerofill_and_disable_all_vram      ;/
   bl   @@arm9_zerofill_and_disable_all_vram      ;-
.endif

 ldr  r0,=00012078h             ;\disable PU                    ;\disable
;;;          ldr r0,=00056078h
 mov  p15,0,c1,c0,0,r0          ;/                              ; PU and cache
 mov  r0,0                      ;now FORGET all cache content.. ; and force
 mov  p15,0,c7,c5,0,r0 ;=0 ;Invalidate Entire Instruction Cache ; EMPTY cache
 mov  p15,0,c7,c6,0,r0 ;=0 ;Invalidate Entire Data Cache        ;/

 adr  r12,@@mpu_initial_data    ;\
 ldmia [r12],r0-r11             ;
 mov  p15,0,c2,c0,0,r0          ;
 mov  p15,0,c2,c0,1,r0          ;
 mov  p15,0,c3,c0,0,r1          ;
 mov  p15,0,c5,c0,2,r2          ;
 mov  p15,0,c5,c0,3,r3          ;
 mov  p15,0,c6,c0,0,r4          ;
 mov  p15,0,c6,c1,0,r5          ;
 mov  p15,0,c6,c3,0,r6          ;
 mov  p15,0,c6,c4,0,r7          ;
 mov  p15,0,c6,c6,0,r8          ;
 mov  p15,0,c6,c7,0,r9          ;
 mov  p15,0,c9,c1,0,r10         ;
 mov  p15,0,c9,c1,1,r11         ;/

 mov  r0,0
 mov  p15,0,c6,c2,0,r0   ;PU Protection Unit Data/Unified Region 2
 mov  p15,0,c6,c5,0,r0   ;PU Protection Unit Data/Unified Region 5

 mov  r0,p15,0,c9,c1,0   ;DTCM
 mov  r0,r0,lsr 12       ;base
 mov  r0,r0,lsl 12       ;size
 add  r0,r0,4000h        ;dtcm top

 mov  r1,0
 str  r1,[r0,-4h]      ;[3003FFCh] IRQ Vector
 str  r1,[r0,-8h]      ;[3003FF8h] IRQ Check Bits

 mov  cpsr_c,0d3h       ;\
 add  sp,r0,3fc0h-4000h ; sp_svc = 3003FC0h, lr_svc=0
 mov  lr,0              ;
 mov  spsr,10h          ;/
 mov  cpsr_c,0d2h       ;\
 add  sp,r0,3f80h-4000h ; sp_irq = 3003F80h, lr_irq=0
 mov  lr,0              ;
 mov  spsr,10h          ;/
 mov  cpsr_c,0dfh       ;\sp_sys = 3002F7Ch
 add  sp,r0,2f00h-4000h ;
 add  sp,7ch            ;/


         mov  r0,00000000h              ;\
         mov  r4,4000000h               ;
         str  r0,[r4,240h] ;vramcnt_abcd; disable all VRAM
         str  r0,[r4,248h] ;vramcnt_hi  ; (but with WRAMCNT kept)
         ldr  r0,[r4,244h] ;vramcnt_efgw;
         and  r0,03000000h ;keep WRAMCNT;
         str  r0,[r4,244h] ;vramcnt_efgw;/
         ;---
    mov  r0,00h                 ;\sync(0)
    bl   @@sync_r0              ;/

         ;---
         ldmia [sp],r0-r11


 mov  cpsr_f,80000000h          ;-cpsr_sys flags
 ldr  r12,=2FFFE24h             ;\      __NDSHeader
 ldr  r12,[r12]                 ; ARM9 entrypoint
 mov  r14,r12                   ;
 bx   r12                       ;/
;---
@@sync_r0:
 mov  r1,4000000h               ;\
@@sync_lop:                     ; sync(n)
 ldr  r2,[r1,REG_IPC_SYNC]      ;
 and  r2,0fh                    ;
 cmp  r2,r0                     ;
 bne  @@sync_lop                ;
 mov  r2,r0,lsl 8               ;
 str  r2,[r1,REG_IPC_SYNC]      ;/
 bx   lr
;------------------
.if vram_code
@@arm9_zerofill_and_disable_all_vram:
 .errif vram_code=0   ;<-- in that case instead use function in dsloader.a22
 push lr
 mov  r0,80h // bl @@map_vram_r0                             ;-map vram 6800000h
 mov  r0,5000000h // mov r1,800h    // bl @@zerofill_wordwise  ;-palette
 mov  r0,6800000h // mov r1,0a4000h // bl @@zerofill_wordwise  ;-vram    6ms
 mov  r0,7000000h // mov r1,800h    // bl @@zerofill_wordwise  ;-oam
 mov  r0,00h // bl @@map_vram_r0                             ;-disable vram
 pop  pc
;---
@@zerofill_wordwise:
 push r0-r12,lr
 mov  r2,0
 mov  r3,0
 mov  r4,0
 mov  r5,0
 mov  r6,0
 mov  r7,0
 mov  r8,0
 mov  r9,0
@@zerofill_wordwise_lop:
 stmia [r0]!,r2-r9
 subs r1,8*4
 bne  @@zerofill_wordwise_lop
 pop  r0-r12,pc
;---
@@map_vram_r0:
 mov  r1,4000000h
 strb r0,[r1,240h] ;VRAMCNT_A
 strb r0,[r1,241h] ;VRAMCNT_B
 strb r0,[r1,242h] ;VRAMCNT_C
 strb r0,[r1,243h] ;VRAMCNT_D
 strb r0,[r1,244h] ;VRAMCNT_E
 strb r0,[r1,245h] ;VRAMCNT_F
 strb r0,[r1,246h] ;VRAMCNT_G
 strb r0,[r1,248h] ;VRAMCNT_H
 strb r0,[r1,249h] ;VRAMCNT_I
 bx   lr
.endif
;---
@@mpu_initial_data:
 dd 000000042h  ;p15,0,c2,c0,0..1,r0 ;PU Cachability Bits for Data/Unified+Instruction Protection Region
 dd 000000002h  ;p15,0,c3,c0,0,r1    ;PU Write-Bufferability Bits for Data Protection Regions
 dd 015111011h  ;p15,0,c5,c0,2,r2    ;PU Extended Access Permission Data/Unified Protection Region
 dd 005100011h  ;p15,0,c5,c0,3,r3    ;PU Extended Access Permission Instruction Protection Region
 dd 004000033h  ;p15,0,c6,c0,0,r4    ;PU Protection Unit Data/Unified Region 0
 dd 00200002bh  ;p15,0,c6,c1,0,r5    ;PU Protection Unit Data/Unified Region 1 4MB
 dd 008000035h  ;p15,0,c6,c3,0,r6    ;PU Protection Unit Data/Unified Region 3
 dd 00300001bh  ;p15,0,c6,c4,0,r7    ;PU Protection Unit Data/Unified Region 4
 dd 0ffff001dh  ;p15,0,c6,c6,0,r8    ;PU Protection Unit Data/Unified Region 6
 dd 002fff017h-800000h  ;p15,0,c6,c7,0,r9    ;PU Protection Unit Data/Unified Region 7 4KB
 dd 00300000ah  ;p15,0,c9,c1,0,r10   ;DTCM Virtual Size and Base
 dd 000000020h  ;p15,0,c9,c1,1,r11   ;ITCM Virtual Size
;---
.if 1
   .pool
   .errif $>23FEE00h+200h
   .errif $>@@reloc_dst+200h
   @@reloc_len equ $-@@reloc_dst
   org @@reloc_src+@@reloc_len
.endif
;------------------
freshen_rssi_display:
 push r4-r5,lr
 bl   arm9_disable_ime                  ;\
 mov  r4,r0                             ;/
;- - -
 ldr  r1,=rssi_vram_addr                ;\
 ldr  r0,[r1]                           ;
 cmp  r0,0                              ; change VRAM addr
 beq  @@no_rssi_yet                     ;
 ldr  r1,=vram_addr                     ;
 ldr  r5,[r1]  ;old addr                ;
 str  r0,[r1]  ;new addr                ;/
 ldr  r2,=WifiData_curr_AP              ;\
 ldr  r2,[r2]                           ; get curr beacon
 cmp  r2,0                              ;
 beq  @@no_rssi_yet                     ;/
 ldrh r0,[r2,sgWifiAp_rssi]             ;\
 ldrb r0,[r2,sgWifiAp_rssi_past+0]      ;\
 bl   wrdecimal                         ; display RSSI value
 bl   wrspc                             ;
 bl   wrspc                             ;/
 ldr  r1,=vram_addr                     ;\restore VRAM addr
 str  r5,[r1]  ;old addr                ;/
@@no_rssi_yet:
;- - -
 mov  r0,r4                             ;\
 bl   arm9_restore_ime                  ;/
 pop  r4-r5,pc
;------------------
arm9_dump_blowfish_key:
 ldr  r0,=1FFC894h          ;src/itcm copy (from ARM9 bios)
 ldr  r1,=nds_blowfish_key  ;dst/main ram (for use by ARM7 side)
 ldr  r2,=1048h             ;len (99 D5 20 5F ..)
 b    memcopy_bytewise
;------------------
arm9_detect_dsi: ;must be done at ARM9 side (equivalent ARM7 register is disabled)
 ldr   r0,=REGBASE_SCFG
 ldr   r0,[r0,REG_SCFG_ROM]
 and   r0,03h
 cmp   r0,01h
 movne r0,0  ;nds_mode
 moveq r0,1  ;dsi_mode
 ldr   r1,=dsi_flag
 str   r0,[r1]
 bx    lr
;------------------
arm9_ipc_sync:
 push r4-r5,lr
 mov  r5,r0        ;param
 mov  r4,4000000h  ;iobase
 ldr  r2,[r4,REG_IPC_SYNC]      ;\
 orr  r2,4000h ;sync.irq.enable ; ensure irq source being enabled, 7/2018
 str  r2,[r4,REG_IPC_SYNC]      ;/
 b    @@wait_inj
;---
@@wait_lop:
.if 01
   mov  r2,cpsr                   ;\
   tst  r2,80h                    ;
   bne  @@skip_halt               ;/
   ldr  r2,[r4,REG_IME]           ;\
   tst  r2,1                      ;
   beq  @@skip_halt               ;/
          ;XXX also ensure REG_IE having IRQ_IPC_SYNC enabled
          ;XXX below halt MAY HANG (if SYNC.IRQ occurs shortly before the halt -- unless having another IRQ source enabled, like vblank which could 'escape' from hang)
   swi  06h shl 16        ;halt
  @@skip_halt:
.endif
@@wait_inj:
 ldr  r2,[r4,REG_IPC_SYNC]      ;\
 and  r2,0fh                    ; wait till receiving value same as param
 cmp  r2,r5        ;param       ;
 bne  @@wait_lop                ;/
 mov  r2,r5,lsl 8  ;param       ;\
 orr  r2,6000h     ;with irq    ; output param as response
 str  r2,[r4,REG_IPC_SYNC]      ;/
 pop  r4-r5,pc
;------------------
const_00000000h dd 00000000h
const_00000001h dd 00000001h
txt_dsboot      db 'dsboot'
txt_bootds      db 'bootds'
;------------------
recvall:  ;in: r0=socket, r1=dst, r2=size, r3=flags, out: r0
 push r4-r8,lr
 mov  r4,r0  ;socket [sock_tcp_remote]
 mov  r5,r1  ;dst
 mov  r6,r2  ;len
 mov  r7,r3  ;flags (0)
 mov  r8,r6  ;return value (len)
;bl   getCursor(&row,&column)
@@lop:
 cmp  r6,0   ;len               ;\
 beq  @@done                    ;/
.if with_tcp
 mov  r0,r4  ;socket            ;\
 mov  r1,r5  ;dst               ;
 mov  r2,r6  ;len               ;
 mov  r3,r7  ;flags             ;
 bl   recv                      ;
 cmp  r0,0                      ;
 beq  @@abort_recv_zero         ;
 cmp  r0,-1                     ;
 beq  @@abort_recv_error        ;/
.endif
 sub  r6,r0  ;len
 add  r5,r0  ;dst
 b    @@lop
;---
@@abort_recv_error:
;kprintf("\nrecv -1, errno %d\n",errno)
@@abort_recv_zero:
 mov  r8,0      ;return value (0=failed)
;---
@@done:
;bl   setCursor(row,column)
 mov  r0,r8  ;return value (len, or 0=failed)
 pop  r4-r8,pc
;------------------
progressStart:
 ldr  r1,=vblank_count          ;\
 ldr  r0,[r1]                   ; memorize vblank count
 ldr  r1,=progress_start_time   ;
 str  r0,[r1]                   ;/
 mov  r0,0                      ;\
 ldr  r1,=progress_bytes_done   ; reset num rx bytes
 str  r0,[r1]                   ;/
 bx   lr
;------------------
progressRead:  ;in: r0=socket, r1=dst, r2=len, out: r0
 push r4-r11,lr
 mov  r4,r0  ;socket [sock_tcp_remote]
 mov  r5,r1  ;dst
 mov  r6,r2  ;len
 mov  r8,0   ;index
 mov  r9,r2  ;total
;bl   getCursor(&row,&column)
 mov  r0,r6  ;len               ;\
 mov  r1,100 ;div               ; chunksize
 swi  swi_div                   ;
 mov  r7,r0  ;chunksize         ;
 cmp  r7,1024  ;min chunksize   ;
 movlo r7,1024                  ;/
@@lop:

 ldr  r10,=vram_addr                    ;\
 ldr  r11,[r10]  ;old vram.addr         ;/
 mov  r0,r8  ;index                     ;\
 mov  r1,100                            ;
 mul  r0,r0,r1                          ;
 mov  r1,r9  ;total                     ; show NN%
 swi  swi_div                           ;
 bl   wrdecimal                         ;
 mov  r0,'%'                            ;
 bl   wrchr_r0                          ;/
 bl   wrspc
 ldr  r1,=progress_bytes_done   ;\      ;\
 ldr  r0,[r1]                   ;       ;
 mov  r1,60                     ;       ;
 mul  r0,r0,r1 ;bytes*60        ;/      ;
 ldr  r2,=vblank_count          ;\      ;
 ldr  r2,[r2]                   ;       ; show "bytes*60/vblanks/1024" Kbyte/s, plus space padding
 ldr  r3,=progress_start_time   ;       ;
 ldr  r3,[r3]                   ;       ;    ca. 87K for NDS+eragon
 sub  r1,r2,r3 ;time-start      ;       ;    ca. 140K for DSi+eragon
 add  r1,1     ;round-up        ;/      ;
 swi  swi_div      ;div vblanks ;\      ;
 mov  r0,r0,lsr 10 ;div 1024    ;       ;
 bl   wrdecimal                 ;       ;
 ldr  r1,=txt_kbyte_per_sec     ;       ;
 bl   wrstr_r1                  ;/      ;/
        ;ldr  r0,=vblank_count
        ;ldr  r0,[r0]
        ;bl   wrdecimal
        ;bl   wrdot

 bl   freshen_rssi_display              ;-
 str  r11,[r10]  ;old vram.addr         ;-
;- - -
 cmp  r6,0                      ;\
 beq  @@done                    ;/
;- - -

;        mov  r0,100000h
;        swi  03h shl 16   ;WaitByLoop        ;allow arm9 to enable cache

 mov  r0,r4 ;socket             ;\
 mov  r1,r5 ;dst                ;
 mov  r2,r7 ;chunksize          ;
 cmp  r2,r6 ;len                ;
 movhi r2,r6 ;len (last chunk)  ;
 mov  r3,0  ;flags              ; recv
 bl   recvall                   ;
 cmp  r0,0                      ;
 beq  @@error                   ;
 sub  r6,r0 ;len                ;
 add  r5,r0 ;dst                ;
 add  r8,r0 ;index              ;/
 ldr  r1,=progress_bytes_done   ;\
 ldr  r2,[r1]                   ;
 add  r2,r0 ;bytes              ;
 str  r2,[r1]                   ;/
 b    @@lop
;---
@@error:
;bl   setCursor(row,column)

        mov r0,'-' // bl wrchr_r0
        mov r0,'E' // bl wrchr_r0
        mov r0,'R' // bl wrchr_r0
        mov r0,'R' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0

.comment
        if (sizeleft) {
                kprintf("\nReceive Error\n");
        else {
                kprintf("%%100\n");
.comment

@@done:
 mov  r0,r6     ;out: r0=sizeleft (0=okay)
 pop  r4-r11,pc
;------------------
arm7_irqInit:
 push lr
 ldr  r1,=3FFFFFCh              ;\
 ldr  r0,=arm7_irq_handler      ; NDS7 IRQ Handler
 str  r0,[r1]                   ;/
 mov  r0,IRQ_IPC_RXFIFO         ;\
 bl   arm7_irqEnable            ;/
 mov  r1,4000000h
 mov  r0,1                      ;\cpu interrupt enable (set IME flag)
 str  r0,[r1,REG_IME]           ;/
 mov  r0,cpsr                   ;\
 bic  r0,80h                    ; cpu interrupt enable (clear i flag)
 mov  cpsr,r0                   ;/
 pop  pc
;------------------
arm9_irqInit:
 push lr
 mov  r1,p15,0,c9,c1,0 ;DTCM    ;\
 mov  r1,r1,lsr 12              ;
 mov  r1,r1,lsl 12              ; NDS9 IRQ Handler
 add  r1,r1,3F00h  ;DTCM+3F00h  ;
 ldr  r0,=arm9_irq_handler      ;
 str  r0,[r1,0FCh]              ;/
 mov  r0,IRQ_IPC_RXFIFO         ;\
 bl   arm9_irqEnable            ;/
 mov  r1,4000000h
 mov  r0,1                      ;\cpu interrupt enable (set IME flag)
 str  r0,[r1,REG_IME]           ;/
 mov  r0,cpsr                   ;\
 bic  r0,80h                    ; cpu interrupt enable (clear i flag)
 mov  cpsr,r0                   ;/
 pop  pc
;------------------
arm7_fifoInit:
arm9_fifoInit:
 mov  r1,4000000h
 ldr  r0,=IPC_TXFIFO_RESET+IPC_RXFIFO_NOTEMPTY_IRQ_ENABLE+IPC_FIFO_ENABLE
 str  r0,[r1,REG_IPC_FIFO_CNT]
; mov  r0,4000h   ;IRQ enable            ;\
; str  r0,[r1,REG_IPC_SYNC]              ;/
 bx   lr
;------------------
;:----------------- dslink end
;------------------


;------------------
;:----------------- Video Font
;------------------
symbase8x8:

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

db 
db 
db 
db 
db 
db 
db 
db 

;------------------
;:----------------- Video Code
;------------------
init_bg_mode:  ;initializes video background control registers
 mov  r4,4000000h ;I/O base address
 ldr  r0,=10100h  ;\mode 0, bg0 enable, obj disable, b16=NDS display ON
 str  r0,[r4,0]   ;/dispcnt
 mov  r0,0004h    ;\charbase=4000h, 16 colors, mapbase=0000h, size=0
 strh r0,[r4,08h] ;/bg0cnt
 bx   lr
;------------------
init_tile_memory:
 ;---init text character set...
 ldr  r0,=symbase8x8    ;-charset source address (1bit depth)
 ldr  r1,=6004400h      ;-gba vram dest address (4bit depth)
 mov  r2,40h*8          ;-loop count (40h characters, of 8 lines each)
@@lop:
 ldrb r3,[r0],1         ;-read source byte
 mov  r4,10000000h      ;\
 mov  r5,0              ;
@@pixlop:               ; translate one byte of 1bit color depth
 movs r3,r3,lsr 1       ; into four bytes of 4bit depth, pixel color=1
 addcs r5,r5,r4         ; (one character line of pixels horizontally)
 movs r4,r4,lsr 4       ;
 bne  @@pixlop          ;/
 str  r5,[r1],4         ;-write data to vram
 subs r2,r2,1
 bne  @@lop             ;-loop next
 bx   lr
;------------------
init_colors:
 mov  r1,5000000h       ;-bg palette memory
 ldr  r0,=7fff0000h     ;\palette0, color0/1 = black/white
 str  r0,[r1,00h*2]     ;/
 ldr  r0,=211f0000h     ;\palette1, color0/1 = black/red
 str  r0,[r1,10h*2]     ;/
 ldr  r0,=03e00000h     ;\palette1, color0/1 = black/green
 str  r0,[r1,20h*2]     ;/
 ldr  r0,=7f800000h     ;\palette1, color0/1 = black/blue
 str  r0,[r1,30h*2]     ;/
 bx   lr
;------------------
cls:
 mov  r0,0020h ;space
 mov  r1,6000000h
 ldr  r2,=vram_addr
 str  r1,[r2] ;vram_addr
 mov  r2,32*32
@@lop:
 strh r0,[r1],2
 subs r2,1
 bne  @@lop
;- - - - ----------
locate_home:
 mov  r1,6000000h
 ldr  r2,=vram_addr
 str  r1,[r2] ;vram_addr
 bx   lr
;------------------
wrdot:
 push r0,lr
 mov  r0,'.'
 bl   wrchr_r0
 pop  r0,pc
;------------------
wrchr_r0:
 push lr                        ;\
 bl   check_host_nds7           ;
 pop  lr                        ;
 beq  arm7_tty_wrchr_r0         ;/
chr_call    equ 0bh
 push r0-r3,lr
push r4
mov r4,cpsr
orr r2,r4,80h
mov cpsr,r2
 ldr  r2,=color_attr
 ldr  r3,=vram_addr
 ldr  r1,[r3] ;vram_addr
        bic r1,800h
 cmp  r0,0bh            ;\chr(0Bh) = call ;chr_call ARM9 proc
 beq  @@call            ;/
 cmp  r0,0dh            ;\chr(0Dh) = crlf
 beq  @@crlf            ;/
 cmp  r0,20h            ;\chr(10h..1Fh) = color attr
 blt  @@attr            ;/
 cmp  r0,60h  ;\make upcase
 subhs r0,20h ;/
@@char:
 ldrb r2,[r2] ;color_attr
 orr  r0,r0,r2,lsl 8
 strh r0,[r1],2         ;\write char
 b    @@finish          ;/
@@attr:
 and  r0,0fh
 mov  r0,r0,lsl 4
 strb r0,[r2] ;color_attr
 b    @@finish
@@call:
 ldr  r1,=arm9_call_addr
 ldr  r0,[r1]
 blx  r0
 ldr  r1,=arm9_call_addr
 mov  r0,0
 str  r0,[r1]
 b    @@done
@@crlf:
 mov  r0,20h ;space     ;\
@@pad_lop:              ;
 strh r0,[r1],2         ; space pad till begin of next line
 tst  r1,20h*2-1        ;
 bne  @@pad_lop         ;/
@@finish:
        ldr   r0,=6000000h+32*24*2
        cmp   r1,r0
        movhs r1,6000000h
 str  r1,[r3] ;vram_addr
@@done:
mov cpsr,r4
pop r4
 pop  r0-r3,pc
;------------------
arm7_tty_wrchr_r0:  ;in: r0, out: none
 push r0-r12,lr
 mov  r1,r0  ;char              ;\
 mov  r0,FIFO_CHAR              ;
 bl   arm7_fifoSendValue32      ;/
 pop  r0-r12,pc
;------------------
check_host_nds7:
 push r0-r2,lr
 mov  r1,4000000h
 mov  r0,12h
 ldr  r2,[r1,0e0h] ;backup      ;DMA0FILL
 str  r0,[r1,0e0h] ;set
 ldr  r0,[r1,0e0h] ;readback
 str  r2,[r1,0e0h] ;restore
 cmp  r0,0         ;verify (12h=ARM9, zero=ARM7)
 pop  r0-r2,pc
;---
check_host_nds9:
 push r0-r2,lr
 mov  r1,4000000h
 mov  r0,12h
 ldr  r2,[r1,0e0h] ;backup      ;DMA0FILL
 str  r0,[r1,0e0h] ;set
 ldr  r0,[r1,0e0h] ;readback
 str  r2,[r1,0e0h] ;restore
 cmp  r0,12h       ;verify (12h=ARM9, zero=ARM7)
 pop  r0-r2,pc
;------------------
wrcrlf:
 push r0,lr
 mov  r0,0dh
 bl   wrchr_r0
 pop  r0,pc
;------------------
wrspc:
 push r0,lr
 mov  r0,20h
 bl   wrchr_r0
 pop  r0,pc
;------------------
raw_wrstr_r1:  ;in: r1, out: none
 push r0,lr
@@lop:
 ldrb r0,[r1],1
 cmp  r0,0
 popeq r0,pc
 cmp  r0,20h
 movlo r0,'?'
 cmp  r0,80h
 movhs r0,'?'
 bl   wrchr_r0
 b    @@lop
;------------------
wrstr_r1:
 push r0,lr
@@lop:
 ldrb r0,[r1],1
 cmp  r0,0
 popeq  r0,pc
 bl   wrchr_r0
 b    @@lop
;------------------
wrstr_r1_len_r2:
 push r0,lr
@@show_title_lop:
 ldrb r0,[r1],1
 cmp  r0,20h
 blge wrchr_r0
 subs r2,1
 bne  @@show_title_lop
 pop  r0,pc
;------------------
wrhexdigit:
 push r0,lr
 and  r0,0fh
 cmp  r0,0ah
 addge r0,7
 add  r0,30h
 bl   wrchr_r0
 pop  r0,pc
;------------------
wrhex8bit:
 push lr
 mov  r0,r0,ror 4
 bl   wrhexdigit
 mov  r0,r0,ror 32-4
 bl   wrhexdigit
 pop  pc
;------------------
wrhex16bit:
 push lr
 mov  r0,r0,ror 8
 bl   wrhex8bit
 mov  r0,r0,ror 32-8
 bl   wrhex8bit
 pop  pc
;------------------
wrhex32bit:
 push r1,lr
 mov  r1,8
@@lop:
 mov  r0,r0,ror 28
 bl   wrhexdigit
 subs r1,1
 bne  @@lop
 pop  r1,pc
;------------------
wrdecimal:  ;aka "wrdez:"
 push r0-r7,lr
swi_div equ 09h shl 16  ;div
 mov  r4,r0                     ;\
 ldr  r5,=1000000000 ;=divider  ;
 mov  r2,0    ;=leading zero    ;
@@lop:                          ;
 mov  r0,r4   ;=score/remainder ;
 mov  r1,r5     ;=1000,100,10,1 ;
 swi  swi_div   ;Div r0=r0/r1   ;
 mov  r4,r1     ;=remainder     ;
 orrs r2,r2,r0  ;=leading zero  ;
 tsteq r5,1     ;=or last zero  ;
 orr  r0,r0,30h ;=ascii digit   ;
 blne wrchr_r0  ;write          ;
 mov  r0,r5     ;=1000,100,10,1 ;
 mov  r1,10                     ;
 swi  swi_div   ;Div r0=r0/r1   ;
 movs r5,r0     ;=next divider  ;
 bne  @@lop                     ;/
 pop  r0-r7,pc
;------------------
wrmacaddr_from_r1:
 push r0-r2,lr
 mov  r2,6
@@lop:
 ldrb r0,[r1],1
 bl   wrhex8bit
 cmp  r2,1
 movne r0,':'
 blne  wrchr_r0
 subs r2,1
 bne  @@lop
 pop  r0-r2,pc
;------------------
wripaddr:
 push r0-r2,lr
 mov  r2,4
@@lop:
 push r0
 and  r0,0ffh
 bl   wrdecimal
 cmp  r2,1
 movne r0,'.'
 blne  wrchr_r0
 pop  r0
 mov  r0,r0,ror 8
 subs r2,1
 bne  @@lop
 pop  r0-r2,pc
;------------------
;:----------------- cp15
;------------------
arm9_init_cp15:
 mov  r0,p15,0,c1,c0,0          ;\
 bic  r0,r0,PROTECT_ENABLE      ; Switch off MPU
 mov  p15,0,c1,c0,0,r0          ;/


 adr  r12,@@mpu_initial_data
 ldmia [r12],r0-r11
 mov  p15,0,c2,c0,0,r0
 mov  p15,0,c2,c0,1,r0
 mov  p15,0,c3,c0,0,r1
 mov  p15,0,c5,c0,2,r2
 mov  p15,0,c5,c0,3,r3
 mov  p15,0,c6,c0,0,r4
 mov  p15,0,c6,c1,0,r5
 mov  p15,0,c6,c3,0,r6
 mov  p15,0,c6,c4,0,r7
 mov  p15,0,c6,c6,0,r8
 mov  p15,0,c6,c7,0,r9
 mov  p15,0,c9,c1,0,r10
 mov  p15,0,c9,c1,1,r11

 mov  r0,0
 mov  p15,0,c6,c2,0,r0   ;PU Protection Unit Data/Unified Region 2
 ldr  r0,=0100002Fh  ;itcm to 1000000h-1FFFFFFh
 mov  p15,0,c6,c5,0,r0   ;PU Protection Unit Data/Unified Region 5

        .if vram_code
         ldr  r0,=0600002fh  ;6000000h..6FFFFFFh (cached code in vram, faster for gif_decode etc)
         mov  p15,0,c6,c2,0,r0   ;PU Protection Unit Data/Unified Region 2
        .endif

 mov  r0,p15,0,c9,c1,0   ;DTCM
 mov  r0,r0,lsr 12       ;base
 mov  r0,r0,lsl 12       ;size
 add  r0,r0,4000h        ;dtcm top

 mov  cpsr_c,0d3h       ;\sp_svc = 3003FC0h (nds default)
 add  sp,r0,3fc0h-4000h ;/
 mov  cpsr_c,0d2h       ;\sp_irq = 3003F80h (nds default)
 add  sp,r0,3f80h-4000h ;/
 mov  cpsr_c,0dfh       ;\sp_sys = 3002000h (lower than usually, allow bigger IRQ stack)
 add  sp,r0,2000h-4000h ;/

 mov     r0,0h
 mov     p15,0,c7,c5,0,r0 ;Invalidate Entire Instruction Cache
;DANGER  p15,0,c7,c6,0,r0 ;Invalidate Entire Data Cache          ;DANGER, forgets all written data!
 mov     p15,0,c7,c10,4,r0 ;Drain Write Buffer


 mov  r0,p15,0,c1,c0,0          ;\
 orr  r0,r0,PROTECT_ENABLE      ; Switch MPU back on
orr r0,04h    ;enable data cache
orr r0,1000h  ;enable code cache
orr r0,40000h ;enable itcm
 mov  p15,0,c1,c0,0,r0          ;/
 bx   lr
;---
@@mpu_initial_data:
 dd 000000042h+(4*vram_code)  ;p15,0,c2,c0,0..1,r0 ;PU Cachability Bits for Data/Unified+Instruction Protection Region
 dd 000000002h+(4*vram_code)  ;p15,0,c3,c0,0,r1    ;PU Write-Bufferability Bits for Data Protection Regions
 dd 015111011h+(100h*vram_code)  ;p15,0,c5,c0,2,r2    ;PU Extended Access Permission Data/Unified Protection Region
 dd 005100011h+(100h*vram_code)  ;p15,0,c5,c0,3,r3    ;PU Extended Access Permission Instruction Protection Region
 dd 004000033h  ;p15,0,c6,c0,0,r4    ;PU Protection Unit Data/Unified Region 0
 dd 00200002bh  ;p15,0,c6,c1,0,r5    ;PU Protection Unit Data/Unified Region 1 4MB
 dd 008000035h  ;p15,0,c6,c3,0,r6    ;PU Protection Unit Data/Unified Region 3
 dd 00300001bh  ;p15,0,c6,c4,0,r7    ;PU Protection Unit Data/Unified Region 4
 dd 0ffff001dh  ;p15,0,c6,c6,0,r8    ;PU Protection Unit Data/Unified Region 6
 dd 002c0002bh ;;;17h  ;p15,0,c6,c7,0,r9    ;PU Protection Unit Data/Unified Region 7 4MB ;;;4KB
 dd 00300000ah  ;p15,0,c9,c1,0,r10   ;DTCM Virtual Size and Base
 dd 000000020h  ;p15,0,c9,c1,1,r11   ;ITCM Virtual Size
;------------------
arm9_initDisplay:
 push r4-r12,lr

.if vram_code=0
 mov r1,4000000h
 mov r0,81h   ;vram A, mst=1, ofs=0, enable, BG at 6000000h
 add r0,8200h ;vram B, mst=2, ofs=0, enable, OBJ at 6400000h
 str r0,[r1,240h]   ;vramcnt
.endif

 bl   init_bg_mode              ;\
 bl   init_tile_memory          ; Set up the basic things
 bl   init_colors               ;/
 bl   cls

 bl   locate_home               ;-home
 bl   wrcrlf
 ldr  r1,=txt_hello
 bl   wrstr_r1


 pop  r4-r12,pc
;------------------
txt_hello                db 10h,'nocash wifiboot v2.5',0dh,0
txt_connecting           db 'connecting',0dh,0
txt_connected            db 'connected',0dh,0
txt_failed_to_connect    db 'failed to connect',0dh,0
txt_udp_socket_error     db 'udp socket error',0dh,0
txt_error_reading_header db 'error reading header',0dh,0
txt_receive_error        db 'receive error',0dh,0
txt_reading_arm7_binary  db 'reading arm7 binary',0dh,0
txt_reading_arm9_binary  db 'reading arm9 binary',0dh,0
txt_reading_arm7i_binary db 'reading arm7i binary',0dh,0
txt_reading_arm9i_binary db 'reading arm9i binary',0dh,0
txt_kbyte_per_sec        db ' Kbyte/s    ',0  ;with space-padding
.align 4
;------------------
.pool
;------------------
;:----------------- Include dsloader (blowfish/modcrypt)
;------------------
.include dsloader.a22   ;blowfish/modcrypt
;------------------
;:----------------- End of File
;------------------
.pool                   ;-literal pool
;the literal pool is used as space for data/values from "ldr,Rn,=value" pseudo
;instructions, these instructions are expanded as "ldr Rn,[PC,offset]", in
;bigger programs the relative offset may get out of range, and you may need
;to define several pool areas within your program code.
;------------------
.data?
vram_addr               dd 0
color_attr              dd 0
rssi_vram_addr          dd 0
progress_start_time     dd 0
progress_bytes_done     dd 0
.code
;------------------
.data?
.errif $>23fe000h
vardata_end:
vardata_size equ vardata_end-vardata_start
.code
        ;;; .align 8000h

;------------------
.if vram_code
  .errif $>6040000h
.else
  .errif $>vardata_start
 ;.errif $>23FE000h
.endif
;;;.pack_lz77
arm9_reloc_dst_end:
arm9_reloc_size equ $-arm9_reloc_dst
org arm9_reloc_src+arm9_reloc_size
;---
nds9_size equ $-nds9_dest
org nds9_offset+nds9_size
;------------------
.align 200h
nds7_offset:
org 37f8000h
nds7_dest:
nds7_entry:

 mov  r0,4000000h
 mov  cpsr_c,0d3h               ;\sp_svc = 3FFFFC0h (nds default)
 add  sp,r0,0ffc0h-10000h       ;/
 mov  cpsr_c,0d2h               ;\sp_irq = 3FFFF80h (nds default)
 add  sp,r0,0ff80h-10000h       ;/
 mov  cpsr_c,0dfh               ;\sp_sys = 3FFF000h (must be a good bit below IRQ stack; because IRQ stack is allocating quite some stack data, eg. in "arm7_process_beacon_or_probe_response")
 add  sp,r0,0f000h-10000h       ;/

;aka "arm7_ipc_sync"...
 mov  r4,4000000h
 mov  r0,6e00h                  ;\sync(E) wait for memfill/reloc done
 str  r0,[r4,REG_IPC_SYNC]      ;/
@@wait_lop:                     ;\
   mov  r0,256
   swi  03h shl 16   ;WaitByLoop        ;allow arm9 to enable cache
 ldr  r0,[r4,REG_IPC_SYNC]      ;
 and  r0,0fh                    ; wait(E)  ;XXXX could Halt here
 cmp  r0,0eh                    ;
 bne  @@wait_lop                ;/
 .if vram_code
   ldr  pc,=arm7_main
 .else
   b    arm7_main
 .endif
;---
.pool
        defs 100  ;XNAY (required for HLL dslink, for "1%" transfer units)

nds7_size equ $-nds7_dest
org nds7_offset+nds7_size
;------------------
.if $<8000h     ;\
 .align 8000h   ; ensure icon/title after secure_area
.endif          ;/
.align 200h
icon_offset:
 dw 0001h         ;000h  2    Version  (0001h)
 dw 0 ;(see .fix) ;002h  2    CRC16 across entries 020h..83Fh
 defs 1ch         ;004h  1Ch  Reserved (zero-filled)
defs 220h ;;;.import magicold.icn  ;Icon Tiles + Icon Palette
 @@txt0 dw 'WifiBoot',0ah,'Nocash',0 // defs @@txt0+100h-$
 @@txt1 dw 'WifiBoot',0ah,'Nocash',0 // defs @@txt1+100h-$
 @@txt2 dw 'WifiBoot',0ah,'Nocash',0 // defs @@txt2+100h-$
 @@txt3 dw 'WifiBoot',0ah,'Nocash',0 // defs @@txt3+100h-$
 @@txt4 dw 'WifiBoot',0ah,'Nocash',0 // defs @@txt4+100h-$
 @@txt5 dw 'WifiBoot',0ah,'Nocash',0 // defs @@txt5+100h-$
icon_size equ $-icon_offset
;------------------
.align 8000h
total_used_size equ $           ;-end address
end
;------------------



;get local IP under windows: type "ipconfig" at dos prompt


;XXX general
;  draw icon/title
;  draw progress bar
;  when done: switch off wifi (especially stop LED blink)


;------------------

;XXXX log WPA2 network                  <--------------------------
;XXX  support WPA and WPA2
;XXX  maybe throw heartbeats
;XXX  maybe something about PSTREAMs
;XXXX speedup by ndma-transfers! with sdio DATA32_FIFO  <----------
;XXXX speedup by non-mainram buffer!                    <----------
;XXXX speedup by dma-transfers!
;XXXX speedup by SCFG and ARM cpu clk?
;XXX  speedup by non-mainram code?
;XXX  speedup by non-mainram vars?
;XXX  speedup by bitrate/framerates/fixrates?
;XXX  downloader: show RSSI during download for CURRENT AP (and dhcp and while await download)
;XXXx support/log/test ar6002 wifi board
;XXXx nds: check RSSI range with OLD NDS hardware
;XXX  check old 1.0J wifi firmware
;XX   naming: MSDU = MAC service data unit ?
;XX   naming: sba  = Surplus Bandwidth Allowance ?
;XXX  don't clear NDS-Wifi-RAM in DSi mode

;??   arm9_zerofill_and_disable_all_vram --> hangs when in NDS mode?



Message 1. Authenticator - Supplicant: EAPOL-Key(0,0,1,0,P,0,ANonce,0,0,0)
Message 2. Supplicant - Authenticator: EAPOL-Key(0,1,0,0,P,0,SNonce,MIC,RSNIE,0)
Message 3. Authenticator - Supplicant: EAPOL-Key(1,1,1,1,P,KeyRSC,ANonce,MIC,RSNIE,GTK[N])
Message 4. Supplicant - Authenticator: EAPOL-Key(1,1,0,0,P,0,0,MIC,0,0)


todo:
  ok   stores wpa/wpa2 type and PSK for wifi flash 4/5/6
  ok   throws heartbeats per second
  ok   adjust connect_cmd params
  ok   disable selftests
  ok   don't callback if DATA.ACK OR CMD.ACK are busy (want neither one)
  ok   implement callbacks as PROC.LIST instead PROC
  ok   testwise set 4/5/6 to one of the wpa2 routers
  ok   redirect EAPOL 888E packets
  ok   throw EAPOL 888E replies
  ok   throw ADD_CIPHER and SYNCHRONIZE commands
  ok   prevent dhcp/data until 888E has completed --> WifiData_4way_handshake_busy
  ok   log DSi browser with o2acc2   wifio2a2.txt
  ok   log DSi browser with o2wlan64 wifio2w6.txt
  ok   sdio_send_wmi_cmd ----> _without_poll !!! fixes DHCP
  ok   test wpa2
  ok   test wpa
  ok   handshake3
  ok   handshake4
  ok   cipher's
  ok   need Key RSC in ADD_CIPHER?!
  ok   support dual ack (cmd+data ack) --> @@xtra_ack:
  ok   show connection type crypt: open/wep/wpa/wpa2
  ok   support fritzbox with groupkeyintervall less than 3600 and wpa2 1382h!
  ok   support fritzbox with groupkeyintervall less than 3600 and wpa
  ok   now uses 3808000h, old buf at 3800000h conflicted with carthdr; use 3807E00h or higher
  ok   what version number was in unlaunch... that was v2.3... so now is v2.4
  xxx  arm9_Wifi_FindMatchingAP --> insist matching Open/WEP/WPA/WPA2
  xxx  no$gba/upload: allow CANCEL/ESC during upload (try react more instantly)
  xxx  maybe throw WMI_DISCONNECT_CMD in Deinit (but then need to handle DISCONNECT_EVENT) -- and should also power-down via WMI or SDIO-IO or BPTWL -- and disable wifi-led
  ???  set_bptwl_reg_r1_to_r0 powerbutton isn't set to autoreset (during connecting/scanning)? but sync(E) has ellapsed?!!
  xx.. ath_dummy_data_xx_02_z --> throws dual ack "01 01 02 02" !!! ... maybe the last byte means NUMBER OF ACKs?
 !uhm  o2acc2/wpa2 works, ead/wpa2+wpa works, but o2wlan64/wpa2 ignores wifiboot --> maybe beacon/listen interval or so?
            o2wlan64 TCP accept return FFFFFFFFh ?
            o2wlan64 weird data in message #1 ?
            o2wlan64 weird RSN capabilities SPP A MSDU or 16-PTK-replaycounts?
  uhm  sometimes hangs at connecting (only after powerbutton after WPA !!!) (maybe faulty belief in having warmboot? ignore main ram when bptwl says coldboot; might be needed at unlaunch side) (helps running LAUNCHER once) (still thinks having WPA/WPA2 cipher keys?) (fixed by data-alignment for avoiding cache issues?) (or needed zerofilling Xtra_uncached_mem_start?)
  xx   nds-firmware-gui: allow enter access points (and enable/disable them)
 !xxx  test dlink-open/wep/wpa/wpa2
 !xxx  test o2-acc
!!xxx  try speedup sdio by ndma
            with ndma: drops from 150K/s to 50K/s  : (
            with ndma+waitbyloop: that's actually FASTER! (ie. needs to free arm9 bus; when queue full or so)
            needed Wifi_Start-like WFLAG_ARM7_RUNNING for enabling wifi IRQ!!!
            with WFLAG_ARM7_RUNNING --> now 320Kbyte/s
            with dma_memcopy --> now 390Kbytes/s or once 430KByte/s (ead/wep: only 300Kbyte/s?)
            xxx try vram code

o2acc2: has THESE dummy data's:
 Write Func[1:00F80] = Len:0001x0080 02 01 02 00 00 00 48 02
 Write Func[1:00F80] = Len:0001x0080 02 00 02 00 00 00 12 02
 Write Func[1:00F80] = Len:0001x0080 02 00 02 00 00 00 41 02
 Write Func[1:00F80] = Len:0001x0080 02 00 02 00 00 00 20 02
                        04/04/0d/09 fritzbox
                        48/12/41/20 o2acc
                        that 48/12/41/20 are just CMD.lsb's from earlier writes (same of 04/04/0D/09, which are just one step earlier/later)
                        eg. 48 is from WMIcmd(0048h)

old nds wifi 39 seconds per eragon upload (ead/wep)
new nds wifi 39 seconds per eragon upload, benchmark says about 60Kbyte/s
new dsi wifi 500KBytes/s on o2acc2/wpa2 (night) -- but once had BAD#5 maybe replay count?
new dsi wifi 300KBytes/s on o2acc2/wpa2 (day)
new dsi wifi 400KBytes/s on ead/wep (night)

;------------------







;------------------
apply_crypto:
  select WPA or WPA2
  select pairwise key TKIP or AES (or WEP/open)
  select group key TKIP or AES    (or WEP/open)
 ok  apply to connect cmd ... including auth mode stuff
 ok  apply to eapol handler          replace "wpamode"
 ok  apply to RSNIE in handshake2_data --> adjust wpa+wpa2 RSNIE's per grp/pair keys
 ok  apply to cipher cmd's

 ok   nocash dlink  wep                128bit
 ok   nocash dlink  wpa-psk            tkip
 ok   nocash dlink  wpa-psk            aes             uses 008Ah alike wpa2 !!! (see "handshake_crypt")
 ok   nocash dlink  wpa/wpa2-personal  (use:tkip)      uses 0089h alike wpa !!!
 ok   nocash dlink  wpa/wpa2-personal  (tkip+aes)
 bad  nocash dlink  wpa2-personal(aes) (aes)           throws disconnect ??? (no handshake step occurs at all) (also doesn't work in dsi-sys-settings, nor in android-tablet)

xed32 ..\stuff\wificore.a22


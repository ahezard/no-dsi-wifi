;:----------------- dswifi ASM port
;------------------
;dswifi ASM port 2016 by nocash - based on dswifi-src-0.3.17
; 24 Sep 2016 - started working on ASM port
; 01 Nov 2016 - finished porting everything to ASM (but still untested)
; 02 Dec 2016 - working dswifi binary, plus dslink-clone, plus dsi-dumping tool
;------------------
.arm      ;use 32bit arm code
.nocash   ;assemble with a22i assembler (in no$gba utility menu)
.strict
;------------------
        show_arp_info   equ 0;1
        show_tx_info    equ 0
        show_rx_info    equ 0
        with_listen_log equ 0;1   ;XNAY

with_nds_wifi   equ 01
with_dsi_wifi   equ 01  ;xor with_nds_wifi
with_dns        equ 0;1
with_gimmicks   equ 0;1
with_tcp        equ 01
with_soft_wep   equ 0    ;;;;1    ;5/2018 experimental only
with_blowfish   equ 1
;------------------
;  latest RELEASED source package:
;  https://sourceforge.net/projects/devkitpro/files/dswifi/0.3.17/
;  later WORK-IN-PROGRESS revisions (see "commits"):
;  https://github.com/devkitPro/dswifi
;------------------
;TAG's for notes on original code (eg. search for "BUGGED" to find all bugs):
;  BUGGED  bugged/unstable code
;  CHAOS   messy code
;  BLAH    unused/useless code
;  uh      code with unclear purpose (maybe bugged, or maybe intended as is)
;  ;:----  begin/end of original source files (or sub-sections thereof)
;  XNAY    my own experimental debug stuff (can be removed when all working)
;------------------
;glossary (uh, that kind of info is completely missing in original code)
;  IP   = Internet Protocol
;  ARP  = Address Resolution Protocol
;  UDP  = User Datagram Protocol
;  TCP  = Transmission Control Protocol
;  DNS  = Domain Name System
;  ICMP = Internet Control Message Protocol
;  DHCP = Dynamic Host Configuration Protocol
;  Hub  = ???   ;hardware interface or so
;  MAC  = Media Access Control  ;uh, "MAC" is used as pseudonym for "WifiRAM"?
;------------------
 WIFIWAITCNT equ 206h  ;+4000000h
;------------------
SGIP_TX_RETRIES equ 7  ;default=7
;------------------
;uh, original code does access most wifi ports via numeric addresses, in this
;form: WIFI_REG(0xN), WIFI_REG(0xNN), WIFI_REG(0xNNN), or WIFI_REG(0x8NNN)
;- - - -
;uh, original code does ALSO access WifiRAM like ports, via WIFI_REG(0x4NNN).
;------------------
;Wifi Registers & RAM cannot be written to by STRB opcodes (ignored).
;Registers - NDS7 - 4808000h..4808FFFh
;---              Address  ;Dir   r/w  [Init] Description
.if with_nds_wifi
 W_ID             equ 000h ;R     ---- [1440] Chip ID (1440h=DS, C340h=DS-Lite)
 W_MODE_RST       equ 004h ;R/W   9fff [0000] Mode/Reset
 W_MODE_WEP       equ 006h ;R/W   --7f [0000] Mode/Wep modes
 W_TXSTATCNT      equ 008h ;R/W   ffff [0000] Beacon Status Request
 W_X_00Ah         equ 00Ah ;R/W   ffff [0000] [bit7 - ingore rx duplicates]
 W_IF             equ 010h ;R/W   ackk [0000] Wifi Interrupt Request Flags
 W_IE             equ 012h ;R/W   ffff [0000] Wifi Interrupt Enable
 W_MACADDR        equ 018h ;R/W   ffff [0000] Hardware MAC Address, 1st 2 bytes
 W_MACADDR_1      equ 01Ah ;R/W   ffff [0000] Hardware MAC Address, next 2 bytes
 W_MACADDR_2      equ 01Ch ;R/W   ffff [0000] Hardware MAC Address, last 2 bytes
 W_BSSID          equ 020h ;R/W   ffff [0000] BSSID (first 2 bytes)
 W_BSSID_1        equ 022h ;R/W   ffff [0000] BSSID (next 2 bytes)
 W_BSSID_2        equ 024h ;R/W   ffff [0000] BSSID (last 2 bytes)
 W_AID_LOW        equ 028h ;R/W   ---f [0000] usually as lower 4bit of AID value
 W_AID_FULL       equ 02Ah ;R/W   -7ff [0000] AID value assigned by a BSS.
 W_TX_RETRYLIMIT  equ 02Ch ;R/W   ffff [0707] Tx Retry Limit (set from 00h-FFh)
;W_INTERNAL       equ 02Eh ;R/W   ---1 [0000]
 W_RXCNT          equ 030h ;R/W   ff0e [0000] Receive control
 W_WEP_CNT        equ 032h ;R/W   ffff [0000] WEP engine enable
;W_INTERNAL       equ 034h ;R?    0000 [0000] bit0,1 (see ports 004h,040h,1A0h)
;---Power-Down Registers (and Random Generator)
 W_POWER_US       equ 036h ;R/W   ---3 [0001]
 W_POWER_TX       equ 038h ;R/W   ---7 [0003]
 W_POWERSTATE     equ 03Ch ;R/W   -r-2 [0200]
 W_POWERFORCE     equ 040h ;R/W   8--1 [0000]
 W_RANDOM         equ 044h ;R     0xxx [0xxx]
 W_POWER_OR_SO    equ 048h ;R/W   ---3 [0000]
;---WLAN Memory Ports
 W_RXBUF_BEGIN    equ 050h ;R/W   ffff [4000]
 W_RXBUF_END      equ 052h ;R/W   ffff [4800]
 W_RXBUF_WRCSR    equ 054h ;R     0rrr [0000]
 W_RXBUF_WR_ADDR  equ 056h ;R/W   -fff [0000]
 W_RXBUF_RD_ADDR  equ 058h ;R/W   1ffe [0000]
 W_RXBUF_READCSR  equ 05Ah ;R/W   -fff [0000]
 W_RXBUF_COUNT    equ 05Ch ;R/W   -fff [0000]
 W_RXBUF_RD_DATA  equ 060h ;R     rrrr [xxxx]
 W_RXBUF_GAP      equ 062h ;R/W   1ffe [0000]
 W_RXBUF_GAPDISP  equ 064h ;R/W   -fff [0000]
 W_TXBUF_WR_ADDR  equ 068h ;R/W   1ffe [0000]
 W_TXBUF_COUNT    equ 06Ch ;R/W   -fff [0000]
 W_TXBUF_WR_DATA  equ 070h ;W     xxxx [xxxx]
 W_TXBUF_GAP      equ 074h ;R/W   1ffe [0000]
 W_TXBUF_GAPDISP  equ 076h ;R/W   0fff [0000]
;---xxx
;W_INTERNAL       equ 078h ;W     mirr [mirr] Read: Mirror of 068h
 W_TXBUF_BEACON   equ 080h ;R/W   ffff [0000] Beacon Transmit Location
 W_TXBUF_TIM      equ 084h ;R/W   --ff [0000] Beacon TIM Index in Frame Body
 W_LISTENCOUNT    equ 088h ;R/W   --ff [0000] Listen Count
 W_BEACONINT      equ 08Ch ;R/W   -3ff [0064] Beacon Interval
 W_LISTENINT      equ 08Eh ;R/W   --ff [0000] Listen Interval
 W_TXBUF_CMD      equ 090h ;R/W   ffff [0000]    (used by firmware part4)
 W_TXBUF_REPLY1   equ 094h ;R/W   ffff [0000]    (used by firmware part4)
 W_TXBUF_REPLY2   equ 098h ;R     0000 [0000]    (used by firmware part4)
;W_INTERNAL       equ 09Ch ;R/W   ffff [0050] value 4x00h --> preamble+x*12h us?
 W_TXBUF_LOC1     equ 0A0h ;R/W   ffff [0000]
 W_TXBUF_LOC2     equ 0A4h ;R/W   ffff [0000]
 W_TXBUF_LOC3     equ 0A8h ;R/W   ffff [0000]
 W_TXREQ_RESET    equ 0ACh ;W     fixx [0050]
 W_TXREQ_SET      equ 0AEh ;W     fixx [0050]
 W_TXREQ_READ     equ 0B0h ;R     --1f [0010]
 W_TXBUF_RESET    equ 0B4h ;W     0000 [0000]    (used by firmware part4)
 W_TXBUSY         equ 0B6h ;R     0000 [0000]    (used by firmware part4)
 W_TXSTAT         equ 0B8h ;R     0000 [0000]
;W_INTERNAL       equ 0BAh ;?     0000 [0000]
 W_PREAMBLE       equ 0BCh ;R/W   ---3 [0001]
 W_CMD_TOTALTIME  equ 0C0h ;R/W x ffff [0000]    (used by firmware part4)
 W_CMD_REPLYTIME  equ 0C4h ;R/W x ffff [0000]    (used by firmware part4)
;W_INTERNAL       equ 0C8h ;?     0000 [0000]
 W_RXFILTER       equ 0D0h ;R/W   1fff [0401]
 W_CONFIG_0D4h    equ 0D4h ;R/W   ---3 [0001]
 W_CONFIG_0D8h    equ 0D8h ;R/W   -fff [0004]
 W_RX_LEN_CROP    equ 0DAh ;R/W   ffff [0602]
 W_RXFILTER2      equ 0E0h ;R/W   ---f [0008]
;---Wifi Timers
 W_US_COUNTCNT    equ 0E8h ;R/W   ---1 [0000] Microsecond counter enable
 W_US_COMPARECNT  equ 0EAh ;R/W   ---1 [0000] Microsecond compare enable
 W_CONFIG_0ECh    equ 0ECh ;R/W   3f1f [3F03]
 W_CMD_COUNTCNT   equ 0EEh ;R/W   ---1 [0001]
 W_US_COMPARE0    equ 0F0h ;R/W   fc-- [FC00] Microsecond compare, bits 0-15
 W_US_COMPARE1    equ 0F2h ;R/W   ffff [FFFF] Microsecond compare, bits 16-31
 W_US_COMPARE2    equ 0F4h ;R/W   ffff [FFFF] Microsecond compare, bits 32-47
 W_US_COMPARE3    equ 0F6h ;R/W   ffff [FFFF] Microsecond compare, bits 48-63
 W_US_COUNT0      equ 0F8h ;R/W   ffff [0000] Microsecond counter, bits 0-15
 W_US_COUNT1      equ 0FAh ;R/W   ffff [0000] Microsecond counter, bits 16-31
 W_US_COUNT2      equ 0FCh ;R/W   ffff [0000] Microsecond counter, bits 32-47
 W_US_COUNT3      equ 0FEh ;R/W   ffff [0000] Microsecond counter, bits 48-63
;W_INTERNAL       equ 100h ;?     0000 [0000]
;W_INTERNAL       equ 102h ;?     0000 [0000]
;W_INTERNAL       equ 104h ;?     0000 [0000]
;W_INTERNAL       equ 106h ;?     0000 [0000]
 W_CONTENTFREE    equ 10Ch ;R/W   ffff [0000] ...
 W_PRE_BEACON     equ 110h ;R/W   ffff [0000]
 W_CMD_COUNT      equ 118h ;R/W   ffff [0000]
 W_BEACONCOUNT1   equ 11Ch ;R/W   ffff [0000] reloaded with W_BEACONINT
;---Configuration Ports (and some other Registers)
 W_CONFIG_120h    equ 120h ;R/W   81ff [0048] init from firmware[04Ch]
 W_CONFIG_122h    equ 122h ;R/W   ffff [4840] init from firmware[04Eh]
 W_CONFIG_124h    equ 124h ;R/W   ffff [0000] init from firmware[05Eh], or 00C8h
;W_INTERNAL       equ 126h ;?     fixx [ 0080]
 W_CONFIG_128h    equ 128h ;R/W   ffff [0000] init from firmware[060h], or 07D0h
;W_INTERNAL       equ 12Ah ;?     fixx [1000] lower 12bit same as W_CONFIG_128h
 W_CONFIG_130h    equ 130h ;R/W   -fff [0142] init from firmware[054h]
 W_CONFIG_132h    equ 132h ;R/W   8fff [8064] init from firmware[056h]
 W_BEACONCOUNT2   equ 134h ;R/W   ffff [FFFF] ...
 W_CONFIG_140h    equ 140h ;R/W   ffff [0000] init from firmware[058h], or xx
 W_CONFIG_142h    equ 142h ;R/W   ffff [2443] init from firmware[05Ah]
 W_CONFIG_144h    equ 144h ;R/W   --ff [0042] init from firmware[052h]
 W_CONFIG_146h    equ 146h ;R/W   --ff [0016] init from firmware[044h]
 W_CONFIG_148h    equ 148h ;R/W   --ff [0016] init from firmware[046h]
 W_CONFIG_14Ah    equ 14Ah ;R/W   --ff [0016] init from firmware[048h]
 W_CONFIG_14Ch    equ 14Ch ;R/W   ffff [162C] init from firmware[04Ah]
 W_CONFIG_150h    equ 150h ;R/W   ff3f [0204] init from firmware[062h], or 202h
 W_CONFIG_154h    equ 154h ;R/W   7a7f [0058] init from firmware[050h]
;---Baseband Chip Ports
 W_BB_CNT         equ 158h ;W     mirr [00B5] BB Access Start/Direction/Index
 W_BB_WRITE       equ 15Ah ;W     ???? [0000] BB Access data byte to write
 W_BB_READ        equ 15Ch ;R     00rr [00B5] BB Access data byte read
 W_BB_BUSY        equ 15Eh ;R     000r [0000] BB Access Busy flag
 W_BB_MODE        equ 160h ;R/W   41-- [0100] BB Access Mode
 W_BB_POWER       equ 168h ;R/W   8--f [800D] BB Access Powerdown
;---Internal Stuff
;W_INTERNAL       equ 16Ah ;?     0000 [0001] (or 0000h?)
;W_INTERNAL       equ 170h ;?     0000 [0000]
;W_INTERNAL       equ 172h ;?     0000 [0000]
;W_INTERNAL       equ 174h ;?     0000 [0000]
;W_INTERNAL       equ 176h ;?     0000 [0000]
;W_INTERNAL       equ 178h ;W     fixx [0800] Read: mirror of 17Ch
;---RF Chip Ports
 W_RF_DATA2       equ 17Ch ;R/W   ffff [0800]
 W_RF_DATA1       equ 17Eh ;R/W   ffff [C008]
 W_RF_BUSY        equ 180h ;R     000r [0000]
 W_RF_CNT         equ 184h ;R/W   413f [0018]
;---xxx
;W_INTERNAL       equ 190h ;R/W   ffff [0000]
 W_TX_HDR_CNT     equ 194h ;R/W   ---7 [0000] used by firmware part4 (0 or 6)
;W_INTERNAL       equ 198h ;R/W   ---f [0000]
 W_RF_PINS        equ 19Ch ;R     fixx [0004]
 W_X_1A0h         equ 1A0h ;R/W   -933 [0000] used by firmware part4 (0 or 823h)
 W_X_1A2h         equ 1A2h ;R/W   ---3 [0001] used by firmware part4
 W_X_1A4h         equ 1A4h ;R/W   ffff [0000] "Rate used when signal test..."
;---Wifi Statistics
 W_RXSTAT_INC_IF  equ 1A8h ;R     rrrr [0000] Stats Increment Flags
 W_RXSTAT_INC_IE  equ 1AAh ;R/W   ffff [0000] Stats Increment IRQ Enable
 W_RXSTAT_OVF_IF  equ 1ACh ;R     rrrr [0000] Stats Half-Overflow Flags
 W_RXSTAT_OVF_IE  equ 1AEh ;R/W   ffff [0000] Stats Half-Overflow IRQ Enable
 W_RXSTAT_1B0     equ 1B0h ;R/W   --ff [0000]
 W_RXSTAT_1B2     equ 1B2h ;R/W   ffff [0000] RX_LengthRateErrorCount
 W_RXSTAT_1B4     equ 1B4h ;R/W   rrff [0000] ... firmware uses also MSB ... ?
 W_RXSTAT_1B6     equ 1B6h ;R/W   ffff [0000]
 W_RXSTAT_1B8     equ 1B8h ;R/W   --ff [0000]
 W_RXSTAT_1BA     equ 1BAh ;R/W   --ff [0000]
 W_RXSTAT_1BC     equ 1BCh ;R/W   ffff [0000]
 W_RXSTAT_1BE     equ 1BEh ;R/W   ffff [0000]
 W_TX_ERR_COUNT   equ 1C0h ;R/W   --ff [0000] TransmitErrorCount
 W_RX_COUNT       equ 1C4h ;R     fixx [0000]
;---[1D0 - 1DE are 15 entries related to multiplayer response errors]
 W_CMD_STAT_1D0   equ 1D0h ;R/W   ff-- [0000]
 W_CMD_STAT_1D2   equ 1D2h ;R/W   ffff [0000]
 W_CMD_STAT_1D4   equ 1D4h ;R/W   ffff [0000]
 W_CMD_STAT_1D6   equ 1D6h ;R/W   ffff [0000]
 W_CMD_STAT_1D8   equ 1D8h ;R/W   ffff [0000]
 W_CMD_STAT_1DA   equ 1DAh ;R/W   ffff [0000]
 W_CMD_STAT_1DC   equ 1DCh ;R/W   ffff [0000]
 W_CMD_STAT_1DE   equ 1DEh ;R/W   ffff [0000]
;---Internal Diagnostics Registers (usually not used for anything)
;W_INTERNAL       equ 1F0h ;R/W   ---3 [0000]
;W_INTERNAL       equ 204h ;?     fixx [0000]
;W_INTERNAL       equ 208h ;?     fixx [0000]
;W_INTERNAL       equ 20Ch ;W     fixx [0050]
 W_TX_SEQNO       equ 210h ;R     fixx [0000]
 W_RF_STATUS      equ 214h ;R     xxxx [0009] ;(used by firmware part4)
 W_IF_SET         equ 21Ch ;W     fbff [0000] ;Force Interrupt (set bits in W_IF)
;W_INTERNAL       equ 220h ;R/W   ffff [0000] ;Bit0-1: Enable/Disable WifiRAM (locks memory at 4000h-5FFFh)
;W_INTERNAL       equ 224h ;R/W   ---3 [0003]
 W_X_228h         equ 228h ;W     fixx [0000]    (used by firmware part4) (bit3)
;W_INTERNAL       equ 230h ;R/W   --ff [0047]
;W_INTERNAL       equ 234h ;R/W   -eff [0EFF]
;W_INTERNAL       equ 238h ;R/W   ffff [0000] ;rx_seq_no-60h+/-x  ;why that?  ;other day: fixed value, not seq_no related?
;W_INTERNAL       equ 23Ch ;?     fixx [0000] like W_TXSTAT... ONLY for beacons?
 W_X_244h         equ 244h ;R/W   ffff [0000]    (used by firmware part4)
;W_INTERNAL       equ 248h ;R/W   ffff [0000]
;W_INTERNAL       equ 24Ch ;R     fixx [0000] ;rx_mac_addr_0
;W_INTERNAL       equ 24Eh ;R     fixx [0000] ;rx_mac_addr_1
;W_INTERNAL       equ 250h ;R     fixx [0000] ;rx_mac_addr_2
 W_CONFIG_254h    equ 254h ;?     fixx [0000] (read: FFFFh=DS, EEEEh=DS-Lite)
;W_INTERNAL       equ 258h ;?     fixx [0000]
;W_INTERNAL       equ 25Ch ;?     fixx [0000]
;W_INTERNAL       equ 260h ;?     fixx [ 0FEF]
;W_INTERNAL       equ 264h ;R     fixx [0000] ;rx_addr_1 (usually "rxtx_addr-x")
 W_RXTX_ADDR      equ 268h ;R     fixx [0005] ;rxtx_addr
;W_INTERNAL       equ 270h ;R     fixx [0000] ;rx_addr_2 (usually "rx_addr_1-1")
;W_INTERNAL       equ 274h ;?     fixx [ 0001]
;W_INTERNAL       equ 278h ;R/W   ffff [000F]
;W_INTERNAL       equ 27Ch ;?     fixx [ 000A]
 W_X_290h         equ 290h ;(R/W) fixx [FFFF] bit 0 = ?  (used by firmware part4)
;W_INTERNAL       equ 298h ;W     fixx [0000]
;W_INTERNAL       equ 2A0h ;R/W   ffff [0000]
;W_INTERNAL       equ 2A2h ;R     xxxx [7fff] 15bit shift reg (used during tx?)
;W_INTERNAL       equ 2A4h ;R     fixx [0000] ;rx_rate_1 not ALWAYS same as 2C4h
;W_INTERNAL       equ 2A8h ;W     fixx [0000]
;W_INTERNAL       equ 2ACh ;?     fixx [ 0038]
;W_INTERNAL       equ 2B0h ;W     fixx [0000]
;W_INTERNAL       equ 2B4h ;R/W   -1-3 [0000]
;W_INTERNAL       equ 2B8h ;?     fixx [0000]
;W_INTERNAL       equ 2C0h ;R/W   ---1 [0000]
;W_INTERNAL       equ 2C4h ;R     fixx [000A] ;rx_rate_2 (0Ah,14h = 1,2 Mbit/s)
;W_INTERNAL       equ 2C8h ;R     fixx [0000] ;rx_duration/length/rate (or so?)
;W_INTERNAL       equ 2CCh ;R     fixx [0000] ;rx_framecontrol; from ieee header
;W_INTERNAL       equ 2D0h ;DIS               ;"W_POWERACK" (internal garbage), normally DISABLED (unless FORCE)
;W_INTERNAL       equ 2F0h ;R/W   ffff [0000]
;W_INTERNAL       equ 2F2h ;R/W   ffff [0000]
;W_INTERNAL       equ 2F4h ;R/W   ffff [0000]
;W_INTERNAL       equ 2F6h ;R/W   ffff [0000]
.endif ;with_nds_wifi
;---
;All other ports in range 4808000h..4808FFFh are unused.
;All registers marked as "W_INTERNAL" aren't used by Firmware part4, and are
;probably unimportant, except for whatever special diagnostics purposes.
;Reading from write-only ports (W) often mirrors to data from other ports.
;---
;Additionally, there are 69h Baseband Chip Registers (BB), and 0Fh RF Chip
;Registers (see BB and RF chapters).
;---
;For Wifi Power Managment (POWCNT2), for Wifi Waitstates (WIFIWAITCNT), and for
;the Power LED Blink Feature (conventionally used to indicate Wifi activity)
;see DS Power Management.
;---
;Wifi RAM - NDS7 - Memory (4804000h..4805FFFh)
;  4804000h W_MACMEM RX/TX Buffers (2000h bytes) (excluding below specials)
;  4805F60h Used for something, not included in the rx circular buffer.
;  4805F80h W_WEPKEY_0 (32 bytes)
;  4805FA0h W_WEPKEY_1 (32 bytes)
;  4805FC0h W_WEPKEY_2 (32 bytes)
;  4805FE0h W_WEPKEY_3 (32 bytes)
;Unlike all other NDS memory, Wifi RAM is left uninitialized after boot.
;---
;5F80h - W_WEPKEY_0 thru W_WEPKEY_3 - Wifi WEP keys (R/W)
;These WEP key slots store the WEP keys that are used for encryption for 802.11
;keys IDs 0-3.
;------------------
;missing unimplemented functions... (libnds stuff that's used by dswifi)...
;------------------
memfill_bytewise:  ;in: r0=fillbyte, r1=dst, r2=len
 cmp  r2,0
 bxeq lr
@@lop:
 strb r0,[r1],1
 subs r2,1
 bne  @@lop
 bx   lr
;------------------
zerofill_bytewise:  ;in: r0=dst, r1=len
 cmp  r1,0                      ;\exit if len=0
 bxeq lr                        ;/
 mov  r3,0                      ;-fillvalue
 tst    r0,1                    ;\                                      ;\lead
 strneb r3,[r0],1               ; if dst AND 1 --> fill one byte        ; 8bit
 subne  r1,1                    ;/                                      ;/
 cmp    r1,2                    ;\if len<2 --> fill ALL bytewise        ;\
 blo    @@fill_8bit             ;/                                      ;/
 tst    r0,2                    ;\                                      ;\lead
 strneh r3,[r0],2               ; if dst AND 2 --> fill one halfword    ; 16bit
 subne  r1,2                    ;/                                      ;/
 cmp     r1,40                  ;\if len<40 --> fill remaining
 blo     @@fill_32bit           ;/
 push    r4-r12  ;-->           ;\
 mov     r4,r3                  ;
 mov     r5,r3                  ;
 mov     r6,r3                  ;
 mov     r7,r3                  ;
 mov     r8,r3                  ; fill 320bit units (40 bytes, aka 28h bytes)
 mov     r9,r3                  ;
 mov     r10,r3                 ;
 mov     r11,r3                 ;
 mov     r12,r3                 ;
@@fill_320bit_lop:              ;
 subs    r1,40                  ;
 stmhsia [r0]!,r3-r12           ;
 bhs     @@fill_320bit_lop      ;
 add     r1,40 ;undo last sub   ;
 pop     r4-r12  ;<--           ;/
@@fill_32bit:
@@fill_32bit_lop:               ;\
 subs   r1,4                    ;
 strhs  r3,[r0],4               ; fill 32bit units (4 bytes)
 bhs    @@fill_32bit_lop        ;
 add    r1,4  ;undo last sub    ;/
@@fill_16bit:
@@fill_16bit_lop:               ;\
 subs   r1,2                    ;
 strhsh r3,[r0],2               ; fill 16bit units (2 bytes)
 bhs    @@fill_16bit_lop        ;
 add    r1,2  ;undo last sub    ;/
@@fill_8bit:
@@fill_8bit_lop:                ;\
 subs   r1,1                    ;
 strhsb r3,[r0],1               ; fill 8bit units (1 bytes)
 bhs    @@fill_8bit_lop         ;
 add    r1,1  ;undo last sub    ;/
 bx     lr
;------------------
memcopy_bytewise: memcopy_bytewise_halfwords:  ;in: r0=src, r1=dst, r2=len, out: r0/r1=increased
 cmp  r2,0                      ;\exit if len=0
 bxeq lr                        ;/
 tst  r0,1                      ;\                                      ;\
 beq  @@skip_lead_8bit_copy     ;                                       ;
 ldrb r3,[r0],1                 ;                                       ; lead
 strb r3,[r1],1                 ; if src AND 1 --> copy one byte        ; 8bit
 subs r2,1                      ;                                       ;
 bxeq lr                        ;                                       ;
@@skip_lead_8bit_copy:          ;/                                      ;
 tst  r1,1                      ;\if dst AND 1 --> copy ALL bytewise    ;
 bne  @@copy_8bit               ;/                                      ;/
 cmp  r2,2                      ;\if len<2 --> copy ALL bytewise        ;\
 blo  @@copy_8bit               ;/                                      ;/
 tst  r0,2                      ;\                                      ;\
 beq  @@skip_lead_16bit_copy    ;                                       ;
 ldrh r3,[r0],2                 ;                                       ; lead
 strh r3,[r1],2                 ; if src AND 2 --> copy one halfword    ; 16bit
 subs r2,2                      ;                                       ;
 bxeq lr                        ;                                       ;
@@skip_lead_16bit_copy:         ;/                                      ;
 tst  r1,2                      ;\if dst AND 2 --> copy ALL halfwords   ;
 bne  @@copy_16bit              ;/                                      ;/
 cmp  r2,40                     ;\if len<40 --> copy remaining
 blo  @@copy_32bit              ;/
 push    r4-r12  ;-->           ;\
@@copy_320bit_lop:              ;
 subs    r2,40                  ;
 ldmhsia [r0]!,r3-r12           ; copy 320bit units (40 bytes, aka 28h bytes)
 stmhsia [r1]!,r3-r12           ;
 bhs     @@copy_320bit_lop      ;
 add     r2,40 ;undo last sub   ;
 pop     r4-r12  ;<--           ;/
@@copy_32bit:
@@copy_32bit_lop:               ;\
 subs   r2,4                    ;
 ldrhs  r3,[r0],4               ; copy 32bit units (4 bytes)
 strhs  r3,[r1],4               ;
 bhs    @@copy_32bit_lop        ;
 add    r2,4  ;undo last sub    ;/
@@copy_16bit:

        dma_memcopy equ 01  ;XXX this was NOT GOOD don't use...  NO WORKS!
        .if dma_memcopy   ;for half-word-aligned blocks (with src/dst having different word-alignment)
         push r4          ;uhm, but it's MUCH SLOWER than ldrh/strh copy?
         mov  r4,4000000h     ;other option would be LDR (or even LDMIA) and ROTATE/MERGE halfwords manually
         mov  r3,55h          ;XXX disable IRQs while messing with DMA regs!!!
         str  r3,[r4,REG_DMA3_FILL] ;DMA3FILL
         ldr  r3,[r4,REG_DMA3_FILL] ;DMA3FILL
         cmp  r3,55h
         beq  @@skip_dma  ;not on ARM9 (avoid CACHE issues)
        @@dma_16bit_lop:
         cmp  r2,10h
         blo  @@skip_dma
         mov  r3,r2,lsr 1  ;halfword count
         cmp  r3,4000h  ;limit for NDS7 dma0/1/2 is 4000h units
         movhi r3,4000h
         orr  r3,80000000h ;start, 16bit
         str  r0,[r4,REG_DMA3_SAD] ;SAD
         str  r1,[r4,REG_DMA3_DAD] ;DAD
         str  r3,[r4,REG_DMA3_CNT] ;CNT
         add  r0,r0,r3,lsl 1
         add  r1,r1,r3,lsl 1
         sub  r2,r2,r3,lsl 1
         b    @@dma_16bit_lop
        @@skip_dma:
         pop  r4
        .endif


@@copy_16bit_lop:               ;\
 subs   r2,2                    ;
 ldrhsh r3,[r0],2               ; copy 16bit units (2 bytes)
 strhsh r3,[r1],2               ;
 bhs    @@copy_16bit_lop        ;
 add    r2,2  ;undo last sub    ;/
@@copy_8bit:
@@copy_8bit_lop:                ;\
 subs   r2,1                    ;
 ldrhsb r3,[r0],1               ; copy 8bit units (1 bytes)
 strhsb r3,[r1],1               ;
 bhs    @@copy_8bit_lop         ;
 add    r2,1  ;undo last sub    ;/
 bx     lr
;------------------
ldr_32bit_r0_from_r1:  ;in: r1=src, out: r0=data, r1=increased, other=same
 push r3,lr
 ldrb r0,[r1],1         ;-bit0-7
 ldrb r3,[r1],1         ;\bit8-15
 orr  r0,r0,r3,lsl 8    ;/
 ldrb r3,[r1],1         ;\bit16-23
 orr  r0,r0,r3,lsl 16   ;/
 ldrb r3,[r1],1         ;\bit24-31
 orr  r0,r0,r3,lsl 24   ;/
 pop  r3,pc
;------------------
ldr_24bit_r0_from_r1:  ;in: r1=src, out: r0=data, r1=increased, other=same
 push r3,lr
 ldrb r0,[r1],1         ;-bit0-7
 ldrb r3,[r1],1         ;\bit8-15
 orr  r0,r0,r3,lsl 8    ;/
 ldrb r3,[r1],1         ;\bit16-23
 orr  r0,r0,r3,lsl 16   ;/
 pop  r3,pc
;------------------
ldrh_16bit_r0_from_r1:  ;in: r1=src, out: r0=data, r1=increased, other=same
 push r3,lr
 ldrb r0,[r1],1         ;-bit0-7
 ldrb r3,[r1],1         ;\bit8-15
 orr  r0,r0,r3,lsl 8    ;/
 pop  r3,pc
;------------------
str_32bit_r0_to_r1:
 strb r0,[r1],1         ;-bit0-7
 mov  r0,r0,ror 8
 strb r0,[r1],1         ;-bit8-15
 mov  r0,r0,ror 8
 strb r0,[r1],1         ;-bit16-23
 mov  r0,r0,ror 8
 strb r0,[r1],1         ;-bit24-31
 mov  r0,r0,ror 8       ;-rotate back to original location
 bx   lr
;------------------
strh_16bit_r0_to_r1:
 strb r0,[r1],1         ;-bit0-7
 mov  r0,r0,ror 8
 strb r0,[r1],1         ;-bit8-15
 mov  r0,r0,ror 24      ;-rotate back to original location
 bx   lr
;------------------
arm7_bx_r0:
 bx   r0
;------------------
bx_r3:
 bx   r3
;------------------
arm7_Halt:
arm9_Halt:
 swi  06h shl 16        ;halt
 bx   lr
;------------------
;wait_VBlank:    ;XNAY
;       BX lr
;@@lop1:
; mov  r0,4000000h
; ldr  r0,[r0,REG_DISPSTAT]
; tst  r0,1
; bne  @@lop1
;@@lop2:
; mov  r0,4000000h
; ldr  r0,[r0,REG_DISPSTAT]
; tst  r0,1
; beq  @@lop2
; bx   lr
;------------------
powerman_get_send:      ;XXX duplicated: see also "arm7_PowerChip_ReadWrite"
 push  r3-r4,lr
 ldr   r3,=8002h    ;ctrl powerman, 1MHz
 b     spi_get_send_inj
touchscr_get_send:
 push  r3-r4,lr
 ldr   r3,=8201h    ;ctrl touchscr, 2MHz
 b     spi_get_send_inj
firmware_get_send:  ;in: r2=len=1=last, io: r0=data
 push  r3-r4,lr
 mov   r3,8100h     ;ctrl firmware, 4MHz
spi_get_send_inj:
 mov   r4,4000000h  ;iobase     ;-I/O Base
 strb  r4,[r4,REG_IME] ;IME=0   ;-ensure no IRQs during SPI access (*)
 cmp   r2,1         ;len=1=last ;\
 orrne r3,0800h     ;want more  ; SPI Control and Data Out
 orr   r0,r3,r0,lsl 16          ;
 str   r0,[r4,REG_SPI_CNT_DATA] ;/
@@wait:                         ;\
 ldrb  r0,[r4,REG_SPI_CNT]      ; Wait Busy
 tst   r0,80h       ;busy       ;
 bne   @@wait                   ;/
 cmp   r2,1         ;len=1=last ;\
 moveq r0,3    ;WaitByLoop      ; Extra Delay after last byte
 swieq 03h shl 16 ;wait_by_loop ;/ <-- crashes only r0
 ldrb  r0,[r4,REG_SPI_DATA]     ;-Data in
 cmp   r2,1         ;len=1=last ;\
 streqb r2,[r4,REG_IME] ;IME=1  ;/ <-- resurrect IRQs after SPI access (*)
 subs  r2,1         ;len        ;-Decrease data (out: z=last)
 pop   r3-r4,pc     ;out: zf
 ;---
 ;(*) IRQs are disable for TWO reasons:
 ;first, touchscreen ADC becomes unreliable if interrupted by delays,
 ;second, the backlight-powerman-timer-interrupt obviously may not
 ;access SPI bus while the SPI bus is in use for other purposes.
;------------------
;powerman_set_ctrl0_r1_masked:  ;in: r1
; push r0-r7,lr
; ldr   r0,=23fee00h                             ;\
; ldrb  r0,[r0,xset_backlit]  ;level 00..FF      ; mask-off backlights
; cmp   r0,0   ;0=off                            ; if disabled
; biceq r1,0ch ;disable any backlight bits       ;/
; b    powerman_set_ctrl0_r1_inj
;- - - - - --------
powerman_set_ctrl0_r1:  ;in: r1
 push r0-r7,lr
;powerman_set_ctrl0_r1_inj:
 mov  r2,2   ;len (1=last)                      ;\
 mov  r0,00h ;index=0, write                    ; Power Managment Device
 bl   powerman_get_send                         ; (enable backlights and
 mov  r0,r1  ;new state                         ; sound circuit)
 bl   powerman_get_send                         ;/
 pop  r0-r7,pc
;------------------
firmware_send_cmd_and_adr:  ;in: r2=len, r3=cmd/addr
 push r0-r7,lr
 add  r2,4  ;dta+cmdlen ;\
 mov  r6,24 ;bitpos     ;
@@send_lop:             ; send command-byte and 3-byte-address
 mov  r0,r3,lsr r6      ;
 bl   firmware_get_send ;
 subs r6,8 ;bitpos      ;
 bpl  @@send_lop        ;/
 pop  r0-r7,pc
;------------------
arm7_readFirmware:  ;in: r0=src, r1=dst, r2=len
 push r0-r12,lr
 bic  r0,0ff000000h             ;-truncate 32bit to 24bit address
 orr  r3,r0,03h shl 24          ;-read command & source address
 bl   firmware_send_cmd_and_adr ;-send command/address
@@read_lop:                     ;\
 bl   firmware_get_send         ; read block
 strb r0,[r1],1                 ;
 bne  @@read_lop                ;/
 pop  r0-r12,pc
;------------------
;firmware_write_block:  ;in: r0=src, r1=dst, r2=len
; push r0-r12,lr
; cmp  r1,200h                   ;\prevent writes to firmware header [0..1FFh]
; bcc  $                         ;/(in case accidently done --> lockup)
; push r0-r2  ;-->               ;\
; mov  r0,06h ;command wren      ;
; mov  r2,1   ;len               ; send write enable command
; bl   firmware_get_send         ;
; pop  r0-r2  ;<--               ;/
; orr  r3,r1,0ah shl 24          ;-write command & dest address
; bl   firmware_send_cmd_and_adr ;-send command/address
; mov  r1,r0  ;src               ;\
;@@write_lop:                    ;
; ldrb r0,[r1],1                 ; write block
; bl   firmware_get_send         ;
; bne  @@write_lop               ;/
; mov  r0,05h ;command rdsr      ;\
; mov  r2,-1  ;len               ;
; bl   firmware_get_send         ;
;@@busy_lop:                     ;
; mov  r2,-1  ;len               ; wait busy
; bl   firmware_get_send         ;
; tst  r0,01h ;busy bit          ;
; bne  @@busy_lop                ;
; mov  r2,1   ;len (1=last)      ;
; bl   firmware_get_send         ;/
; pop  r0-r12,pc
;------------------
get_strlen:  ;in: r0=src, out: r0=len
 mov   r2,0   ;len
@@lop:
 ldrb  r1,[r0],1
 cmp   r1,00h
 addne r2,1   ;len
 bne   @@lop
 mov   r0,r2  ;len
 bx    lr
;------------------
copy_asciz:  ;in: r0=src, r1=dst
@@lop:
 ldrb  r3,[r0],1
 strb  r3,[r1],1
 cmp   r3,00h
 bne   @@lop
 bx    lr
;------------------
copy_asciz_with_len_limit:  ;in: r0=src, r1=dst, r2=len
@@copy_lop:             ;\
 subs  r2,1             ;
 blo   @@done           ;
 ldrb  r3,[r0],1        ;
 strb  r3,[r1],1        ;
 cmp   r3,00h           ;
 bne   @@copy_lop       ;/
@@pad_lop:              ;\
 subs  r2,1             ;
 strhsb r3,[r1],1 ;=00h ;
 bhi   @@pad_lop        ;/
@@done:
 bx    lr
;------------------
memcompare_bytewise:  ;in: r0=src1, r1=src2, r2=len, out: r2=0=match, EQ/HI/LO
 cmp  r2,0      ;\exit if len=0
 bxeq lr        ;/
 push r4,lr
@@lop:
 ldrb r3,[r0],1
 ldrb r4,[r1],1
 cmp  r3,r4
 bne  @@diff
 subs r2,1
 bne  @@lop
@@diff:         ;out: r2=remaining len (or 0=match)
 pop  r4,pc     ;out: EQ=match, or NE/HI/LO=diff
;------------------
;arm7_enable_ime:  ;in: none, out: r0=none
; mov  r2,1
; mov  r1,4000000h
; str  r2,[r1,REG_IME]
; bx   lr
;------------------
arm7_disable_ime:  ;in: none, out: r0=old
arm9_disable_ime:  ;in: none, out: r0=old
enterCriticalSection:
 mov  r2,0
 mov  r1,4000000h
 ldr  r0,[r1,REG_IME] ;old
 str  r2,[r1,REG_IME] ;new
 bx   lr
;------------------
arm9_sgIP_IntrWaitEvent:  ;in/out: none
 ;uh, original code contains an OUTCOMMENTED "swi 06h shl 16",
 ;and a HARDCODED and very wasteful delay loop (looping 20000 times).
 ;that's both not really optimal, a better solution might be:
 ;  check if an IRQ is pending (BEFORE enabling IRQs)
 ;  if yes --> enable IRQs and wait only a HANDFUL of clock cycles
 ;  if not --> enable IRQs and use the SWI to wait for interrupt
 ;anyways, for now, behave like original code, but looping only a FEW times...
 ;- - -
 mov  r0,4      ;\
@@lop:          ; short delay, should be more than enough to allow IRQs to fire
 subs r0,1      ;
 bne  @@lop     ;/
 bx   lr
;------------------
arm7_restore_ime:  ;in: r0, out: ?
arm9_restore_ime:  ;in: r0, out: ?
leaveCriticalSection:
 mov  r1,4000000h
 str  r0,[r1,REG_IME]
 bx   lr
;------------------
arm7_irqEnable:    ;in: r0=IRQ_xxx mask
arm9_irqEnable:
 mov  r1,4000000h
 ldr  r2,[r1,REG_IE] ;old
 orr  r2,r0
 str  r2,[r1,REG_IE] ;new
 bx   lr
;---
arm7_irqDisable:   ;in: r0=IRQ_xxx mask
arm9_irqDisable:
 mov  r1,4000000h
 ldr  r2,[r1,REG_IE] ;old
 bic  r2,r0
 str  r2,[r1,REG_IE] ;new
 bx   lr
;------------------
.if with_dsi_wifi
arm7_irqEnable2:    ;in: r0=IRQ2_xxx mask
 mov  r1,4000000h
 ldr  r2,[r1,REG_IE2] ;old
 orr  r2,r0
 str  r2,[r1,REG_IE2] ;new
 bx   lr
;---
arm7_irqDisable2:   ;in: r0=IRQ2_xxx mask
 mov  r1,4000000h
 ldr  r2,[r1,REG_IE2] ;old
 bic  r2,r0
 str  r2,[r1,REG_IE2] ;new
 bx   lr
.endif
;------------------
arm9_cache_FlushAll:
 mov  r0,0h                                             ;\
@@lop1:                                                 ; clean all data lines
@@lop2:                                                 ; (needed for PU areas
 mov  p15,0,c7,c10,2,r0    ;S/I Clean Data Cache Line   ; that have cache write-
 add  r0,r0,20h                                         ; bufferability set,
 tst  r0,400h                                           ; ie. write cached data
 beq  @@lop2                                            ; before invalidating
 bic  r0,400h                                           ; it below, else data
 adds r0,r0,40000000h                                   ; gets lost!)
 bcc  @@lop1                                            ;/
;- - -
 mov  r0,0
 mov  p15,0,c7,c10,4,r0 ;=000000000h ;Drain Write Buffer
 mov  p15,0,c7,c5,0,r0  ;=000000000h ;Invalidate Entire Instruction Cache
 mov  p15,0,c7,c6,0,r0  ;=000000000h ;Invalidate Entire Data Cache
 bx   lr
;------------------
arm7_detect_wifiValue32Handler:  ;in/out: r0/r1=same
.if with_nds_wifi AND with_dsi_wifi
   ldr  r3,=REGBASE_SDIO                        ;\
   str  r3,[r3,REG_SDIO_CMD_PARAM] ;try write   ; detect if DSi wifi/sdio is
   ldr  r2,[r3,REG_SDIO_CMD_PARAM] ;try readback; present (and enabled in SCFG)
   cmp  r2,r3                                   ;
   beq  @@dsi                                   ;/
   b    @@nds
.endif
;---
.if with_nds_wifi
  @@nds:
   ldr  r3,=dsi_wifi_flag                         ;\
   mov  r2,0     ;0=NDS                           ; store nds/dsi flag
   strb r2,[r3]                                   ;/
   ldr  r3,=arm7_current_wifiValue32Handler       ;\
   ldr  r2,=arm7_wifiValue32Handler               ; apply handler
   str  r2,[r3]                                   ;/
   b    arm7_wifiValue32Handler  ;in: r0,r1       ;-and execute right away
.endif
;---
.if with_dsi_wifi
  @@dsi:
   ldr  r3,=dsi_wifi_flag                         ;\
   mov  r2,1     ;1=DSi                           ; store nds/dsi flag
   strb r2,[r3]                                   ;/
   ldr  r3,=arm7_current_wifiValue32Handler       ;\
   ldr  r2,=dsi7_wifiValue32Handler               ; apply handler
   str  r2,[r3]                                   ;/
   b    dsi7_wifiValue32Handler  ;in: r0,r1       ;-and execute right away
.endif
;------------------
arm7_installWifiFIFO:  ;in/out: none
 push lr
 .if with_nds_wifi AND with_dsi_wifi
;;   ldr  r1,=REGBASE_SDIO                        ;\
;;   str  r1,[r1,REG_SDIO_CMD_PARAM] ;try write   ; detect if DSi wifi/sdio is
;;   ldr  r0,[r1,REG_SDIO_CMD_PARAM] ;try readback; present (and enabled in SCFG)
;;   cmp  r0,r1                                   ;
;;   beq  @@dsi                                   ;/
;;   b    @@nds
 .endif
 .if with_nds_wifi
   @@nds:
;;    ldr  r1,=dsi_wifi_flag              ;\
;;    mov  r0,0     ;0=NDS                ;
;;    strb r0,[r1]                        ;/
   ;mov  r0,IRQ_WIFI                       ;\
   ;ldr  r1,=arm7_Wifi_Interrupt           ; set up wifi interrupt
   ;bl   arm7_irqSet                       ;/   ;XXX <-- libnds ?
   ;ldr  r0,=arm7_synctoarm9               ;\allow wifi lib to notify arm9
   ;bl   arm7_Wifi_SetSyncHandler          ;/
   ;mov  r0,FIFO_DSWIFI                    ;\
   ;ldr  r1,=arm7_wifiValue32Handler       ;
   ;mov  r2,0                              ;
   ;bl   arm7_fifoSetValue32Handler        ;/
   ;mov  r0,FIFO_DSWIFI                    ;\
   ;ldr  r1,=arm7_Wifi_Init                ;
   ;mov  r2,0                              ;
   ;bl   arm7_fifoSetAddressHandler        ;/   ;XXX <-- libnds ?
    b    @@done
 .endif
 .if with_dsi_wifi
   @@dsi:
;;    ldr  r1,=dsi_wifi_flag              ;\
;;    mov  r0,1     ;1=DSi                ;
;;    strb r0,[r1]                        ;/
   ;mov  r0,IRQ2_DSI_WIFI                  ;\
   ;ldr  r1,=dsi7_Wifi_Interrupt           ; set up wifi interrupt
   ;bl   arm7_irqSet2                      ;/   ;XXX <-- libnds ?
   ;ldr  r0,=arm7_synctoarm9               ;\allow wifi lib to notify arm9
   ;bl   arm7_Wifi_SetSyncHandler          ;/
   ;mov  r0,FIFO_DSWIFI                    ;\
   ;ldr  r1,=dsi7_wifiValue32Handler       ;
   ;mov  r2,0                              ;
   ;bl   arm7_fifoSetValue32Handler        ;/
   ;mov  r0,FIFO_DSWIFI                    ;\
   ;ldr  r1,=dsi7_Wifi_Init                ;
   ;mov  r2,0                              ;
   ;bl   arm7_fifoSetAddressHandler        ;/   ;XXX <-- libnds ?
    b    @@done
 .endif
@@done:
 pop  pc
;------------------
arm7_fifoSendValue32:  ;in: r0=channel, r1=value32, out: r0=bool?
arm9_fifoSendValue32:
 push r4,lr
 orr  r4,r1,r0,lsl 28
 bl   wait_ipc_fifo_full
 mov  r1,4000000h
 str  r4,[r1,REG_IPC_TXFIFO]
 pop  r4,pc
;---
REG_IPC_FIFO_CNT                equ 184h
REG_IPC_TXFIFO                  equ 188h
ADDR_IPC_RXFIFO                 equ 4100000h
IPC_TXFIFO_FULL                 equ 0002h
IPC_TXFIFO_RESET                equ 0008h
IPC_RXFIFO_EMPTY                equ 0100h
IPC_RXFIFO_NOTEMPTY_IRQ_ENABLE  equ 0400h
IPC_FIFO_ENABLE                 equ 8000h
;---
wait_ipc_fifo_full:
 mov  r1,4000000h
@@wait_lop:
 ldr  r0,[r1,REG_IPC_FIFO_CNT]
 tst  r0,IPC_TXFIFO_FULL
 bne  @@wait_lop
 bx   lr
;------------------
arm7_synctoarm9:  ;in/out: none  ;"static"
 ;callback to allow wifi library to notify arm9
 mov  r0,FIFO_DSWIFI            ;\
 mov  r1,WIFI_SYNC              ;
 b    arm7_fifoSendValue32      ;/
;------------------
arm7_fifo_update:
@@try_more:
 mov  r1,4000000h               ;-
 mov  r0,IRQ_IPC_RXFIFO         ;\ack
 str  r0,[r1,REG_IF]            ;/
 ldr  r0,[r1,REG_IPC_FIFO_CNT]  ;\
 tst  r0,IPC_RXFIFO_EMPTY       ; exit if empty
 bxne lr                        ;/
;- - -
 push lr  ;-->
 mov  r0,ADDR_IPC_RXFIFO        ;\read fifo
 ldr  r0,[r0]                   ;/
 mov  r1,r0,lsr 28
 bic  r0,0fh shl 28
 cmp  r1,FIFO_DSWIFI
 bne  $  ;oops
;mov  r0,r0
;mov  r1,...
 ldr  r2,=arm7_current_wifiValue32Handler
 ldr  r2,[r2]
 bl   @@to_r2     ;in: r0,r1
;;; bl   arm7_wifiValue32Handler  ;in: r0=value, r1=data/optional
 pop  lr  ;<--
         mov  r1,4000000h               ;\
         ldr  r0,[r1,REG_IF]            ; XXXXXXXXX
         tst  r0,IRQ_IPC_RXFIFO         ;
         bxne lr      ;NEW irq --> don't process yet (instead check for VBLANK irq if any)
 b    @@try_more
;---
@@to_r2:
 bx   r2
;---
arm7_current_wifiValue32Handler  dd arm7_detect_wifiValue32Handler ;<-- initially this for nds/dsi detection
;------------------
arm9_fifo_update:
@@try_more:
 mov  r1,4000000h               ;-
 mov  r0,IRQ_IPC_RXFIFO         ;\ack
 str  r0,[r1,REG_IF]            ;/
 ldr  r0,[r1,REG_IPC_FIFO_CNT]  ;\
 tst  r0,IPC_RXFIFO_EMPTY       ; exit if empty
 bxne lr                        ;/
;- - -
 push lr  ;-->
 mov  r0,ADDR_IPC_RXFIFO
 ldr  r0,[r0]
 mov  r1,r0,lsr 28
 bic  r0,0fh shl 28
 cmp  r1,FIFO_CHAR      ;\
 bne  @@not_char        ;
 bl   wrchr_r0          ;
 b    @@done            ;
@@not_char:             ;/
 cmp  r1,FIFO_DSWIFI
 bne  $  ;oops
;mov  r0,r0
;mov  r1,...
 bl   arm9_wifiValue32Handler  ;in: r0=value, r1=data/optional
@@done:
 pop  lr  ;<--
 b    @@try_more
;------------------
arm7_irq_handler:   ;called by BIOS with "r0-r3,r12" pushed
 mov  r2,4000000h               ;-
 .if with_dsi_wifi
   ldr  r0,[r2,REG_IF2]         ;\
   ldr  r1,[r2,REG_IE2]         ;
   and  r0,r1                   ;/
   tst  r0,IRQ2_DSI_WIFI        ;\wifi (dsi)
   bne  dsi7_Wifi_Interrupt     ;/
   str  r0,[r2,REG_IF2]         ;-else just ACK anything else
 .endif
 ldr  r0,[r2,REG_IF]            ;\
 ldr  r1,[r2,REG_IE]            ;
 and  r0,r1                     ;/
 tst  r0,IRQ_VBLANK             ;\vblank   <--- uh, original code does NOT ack IRQ_VBLANK (unlike IRQ_WIFI)
 bne  arm7_VblankHandler        ;/
 .if with_nds_wifi
   tst  r0,IRQ_WIFI             ;\wifi (nds)
   bne  arm7_Wifi_Interrupt     ;/
 .endif
 tst  r0,IRQ_IPC_RXFIFO         ;\ipc rxfifo
 bne  arm7_fifo_update          ;/
 str  r0,[r2,REG_IF]            ;-else just ACK anything else (eg. IRQ_IPC_SYNC)
 bx   lr
;------------------
arm9_irq_handler:   ;called by BIOS with "r0-r3,r12" pushed
 mov  r2,4000000h               ;\
 ldr  r0,[r2,REG_IF]            ;/
 ldr  r1,[r2,REG_IE]            ;\
 and  r0,r1                     ;/
 tst  r0,IRQ_TIMER3             ;\wifi timer3   <--- uh, original code does NOT ack IRQ_TIMER3 (unlike IRQ_WIFI)
 bne  arm9_Timer_50ms           ;/
 tst  r0,IRQ_IPC_RXFIFO         ;\ipc rxfifo
 bne  arm9_fifo_update          ;/
 str  r0,[r2,REG_IF]            ;-else just ACK anything else (eg. IRQ_IPC_SYNC)
 bx   lr
;------------------
arm9_malloc:
 ldr  r0,=big_buffer
 bx   lr
;---
.data?
big_buffer: defs 128*1024   ;XXXX
.code
;------------------
;arm7_fifoSetValue32Handler:  ;in: r0=channel, r1=newhandler, r2=userdata, out: r0=bool?
;arm9_fifoSetValue32Handler:
;arm7_fifoSetAddressHandler:
;arm9_fifoSendAddress:  ;in: r0=channel, r1=address, out: r0=bool?
;arm7_irqSet:       ;in: r0=IRQ_xxx mask, r1=handler
;arm9_irqSet:
;---
UnCachedBase    equ 0c00000h ;XXX program Cache/PU as so!
;---
FIFO_DSWIFI     equ 4           ;-from libnds "include/nds/fifocommon.h"
FIFO_CHAR       equ 5           ;-custom
WIFI_ENABLE     equ 0           ;\
WIFI_DISABLE    equ 1           ; from libnds "include/nds/fifocommon.h"
WIFI_SYNC       equ 2           ;
WIFI_STARTUP    equ 3 ;BLAH     ;/  <-- not used by libnds (but USED by ASM code, instead of SendAddress)
;---
FD_SETSIZE      equ 32  ;see SGIP_SOCKET_MAXSOCKETS
false           equ 0   ;\
true            equ 1   ;/
;---
;windows.inc
;SOCKET TYPEDEF DWORD                   ;\
;FD_SETSIZE  equ 64                     ;
;fd_set STRUCT                          ; from "windows.inc"
;  fd_count  DWORD      ?               ; (unlike as "fdbits" in dswifi)
;  fd_array  SOCKET FD_SETSIZE dup(?)   ;
;fd_set ENDS                            ;/
;---
sgFdset_fdbits    equ 0   ;XXX
;---
;struct timeval:                        ;\
 sgTimeval_tv_sec  equ 00h ;4  ;DWORD   ; from "windows.inc"
 sgTimeval_tv_usec equ 04h ;4  ;DWORD   ;
 sgTimeval_size    equ 08h ;total       ;/
;---
REG_SPI_CNT_DATA    equ 1C0h  ;(1C0h=cnt, and 1C2h=data)
REG_SPI_CNT         equ 1C0h
REG_SPI_DATA        equ 1C2h
REG_IME         equ 208h
REG_IE          equ 210h
REG_IF          equ 214h
REG_IE2         equ 218h  ;\dsi7
REG_IF2         equ 21Ch  ;/
TIMER3CNT       equ 10Ch
REG_RTC_CNT     equ 138h
IRQ_ALL         equ 0ffffffffh
IRQ_VBLANK      equ (1 shl 0)
IRQ_TIMER3      equ (1 shl 6)
IRQ_IPC_SYNC    equ (1 shl 16)
IRQ_IPC_RXFIFO  equ (1 shl 18)
.if with_nds_wifi
  IRQ_WIFI      equ (1 shl 24)
.endif
;---
.if with_dsi_wifi
  IRQ2_DSI_SDIO equ (1 shl 10)  ;SDIO Controller     ;\Atheros Wifi Unit
  IRQ2_DSI_WIFI equ (1 shl 11)  ;SDIO Data1 pin      ;/(via IE2/IF2)
  IRQ2_ALL      equ 0ffffffffh
.endif
;---
.data?
errno dd 0
.code
;------------------
EINVAL          equ 01h         ;\
EWOULDBLOCK     equ 02h         ;
EFAULT          equ 03h         ; these aren't defined in dswifi,
ENOMEM          equ 04h         ; they are probably defined in libnds,
ESHUTDOWN       equ 05h         ; possibly same as in windows.inc
ECONNRESET      equ 06h         ; (which uses values in range 10000..10099,
EMSGSIZE        equ 07h         ; but that values won't work well as
ECONNABORTED    equ 08h         ; shifted 8bit ARM immediates, so let's
ETIMEDOUT       equ 09h         ; use some other/smaller values)
EBADF           equ 0ah         ;
ENOTCONN        equ 0bh         ;
EINPROGRESS     equ 0ch         ;
EOPNOTSUPP      equ 0dh         ;/
;---
sgIP_error_inval:      mov r0,EINVAL      // b sgIP_error_r0
sgIP_error_badf:       mov r0,EBADF       // b sgIP_error_r0
sgIP_error_nomem:      mov r0,ENOMEM      // b sgIP_error_r0
sgIP_error_inprogress: mov r0,EINPROGRESS // b sgIP_error_r0
sgIP_error_opnotsupp:  mov r0,EOPNOTSUPP  // b sgIP_error_r0
sgIP_error_fault:      mov r0,EFAULT      // b sgIP_error_r0
sgIP_error_notconn:    mov r0,ENOTCONN    // b sgIP_error_r0
sgIP_error_shutdown:   mov r0,ESHUTDOWN   // b sgIP_error_r0
sgIP_error_wouldblock: mov r0,EWOULDBLOCK // b sgIP_error_r0
sgIP_error_msgsize:    mov r0,EMSGSIZE    // b sgIP_error_r0
;---
sgIP_error_r0:
 push r1,lr
 ldr  r1,=errno ;\apply errno
 str  r0,[r1]   ;/
 mov  r0,-1     ;-return -1
 pop  r1,pc
;------------------
const_FFFFFFFFFFFFh     db 0ffh,0ffh,0ffh,0ffh,0ffh,0ffh
const_000000000000h     db 000h,000h,000h,000h,000h,000h
;------------------
;:----------------- dswifi-src-0.3.17.tar\
;------------------
;DSWifi Project - sgIP Internet Protocol Stack Implementation
;Copyright (C) 2005-2006 Stephen Stair - sgstair@akkit.org - http://www.akkit.org
;******************************************************************************
;DSWifi Lib and test materials are licenced under the MIT open source licence:
;Copyright (c) 2005-2006 Stephen Stair
;
;Permission is hereby granted, free of charge, to any person obtaining a copy of
;this software and associated documentation files (the "Software"), to deal in
;the Software without restriction, including without limitation the rights to
;use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
;of the Software, and to permit persons to whom the Software is furnished to do
;so, subject to the following conditions:
;
;The above copyright notice and this permission notice shall be included in all
;copies or substantial portions of the Software.
;
;THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;SOFTWARE.
;******************************************************************************/
;------------------
;note: original source code consists of several .c and .h files, merging all
;those files together results in about 9300 lines of code (or around 7800 lines
;when removing unneccessary stuff like extern/include stuff, cplusplus stuff,
;and duplicated copyright/warranty stuff)
;------------------
;CHAOS:
;below are DUPE function names (exist on ARM7 and ARM9):
;  wifiValue32Handler
;  Wifi_SetSyncHandler
;  Wifi_Sync
;  Wifi_SetChannel
;  Wifi_Init
;  Wifi_Update
;  erasemem         (same on ARM9 and ARM7, though UNUSED on ARM7)
;  Wifi_CmpMacAddr  (same on ARM9 and ARM7)
;  Wifi_CopyMacAddr (same on ARM9 and ARM7)
;  Spinlock_Acquire (same on ARM9 and ARM7, except different SPINLOCK_VALUE)
;  Spinlock_Release (same on ARM9 and ARM7, except different SPINLOCK_VALUE)
;  Spinlock_Check   (same on ARM9 and ARM7, though UNUSED)
;below are DUPE variable names (exist on ARM7 and ARM9):
;  synchandler
;  WifiData         (once when initialized: same on ARM9 and ARM7)
;would be better to prefix all names in "wifi_arm9.c" and "wifi_arm7.c"
;by "arm9_" and "arm7_" to clarify things (the difficult part would be
;to ALSO update the comments/names in the various .h files accordingly)
;------------------
;:----------------- dswifi-src-0.3.17.tar\common\dsregs.h
;------------------
;mostly BLAH, aside from the three ARM7 registers:
;  POWERCNT7, SPI_CR, SPI_DATA
;uh, original code's "dsregs.h" lacks Stephen's email (unlike all other files)
;------------------
;ARM7 specific registers
POWERCNT7  equ 0304h ;+4000000h    ;(*((u16 volatile *) 0x04000304))
;------------------
;BLAH: everything below is UNUSED (wifi doesn't need video/joypad stuff)
;(and some registers that ARE used are apparently defined elsewhere, eg. REG_IE)
;(and WIFIWAITCNT should be declared other than "0x04000206) = 0x30; // ???")
;------------------
;ARM9 specific registers
;#define         POWERCNT        (*((u16 volatile *) 0x04000308))
;------------------
;General registers...
;---general memory range defines
;#define         PAL             ((u16 *) 0x05000000)
;#define         VRAM1           ((u16 *) 0x06000000)
;#define         VRAM2           ((u16 *) 0x06200000)
;//#define       OAM             ((u16 *) 0x07000000)
;#define         CART            ((u16 *) 0x08000000)
;---video registers
;#define         DISPCNT         (*((u32 volatile *) 0x04000000))
;#define         DISPSTAT        (*((u16 volatile *) 0x04000004))
;#define         VCOUNT          (*((u16 volatile *) 0x04000006))
;#define         BG0CNT          (*((u16 volatile *) 0x04000008))
;#define         BG1CNT          (*((u16 volatile *) 0x0400000A))
;#define         BG2CNT          (*((u16 volatile *) 0x0400000C))
;#define         BG3CNT          (*((u16 volatile *) 0x0400000E))
;#define         BG0HOFS         (*((u16 volatile *) 0x04000010))
;#define         BG0VOFS         (*((u16 volatile *) 0x04000012))
;#define         BG1HOFS         (*((u16 volatile *) 0x04000014))
;#define         BG1VOFS         (*((u16 volatile *) 0x04000016))
;#define         BG2HOFS         (*((u16 volatile *) 0x04000018))
;#define         BG2VOFS         (*((u16 volatile *) 0x0400001A))
;#define         BG3HOFS         (*((u16 volatile *) 0x0400001C))
;#define         BG3VOFS         (*((u16 volatile *) 0x0400001E))
;#define         BG2PA           (*((u16 volatile *) 0x04000020))
;#define         BG2PB           (*((u16 volatile *) 0x04000022))
;#define         BG2PC           (*((u16 volatile *) 0x04000024))
;#define         BG2PD           (*((u16 volatile *) 0x04000026))
;#define         BG2X            (*((u32 volatile *) 0x04000028))
;#define         BG2Y            (*((u32 volatile *) 0x0400002C))
;#define         BG3PA           (*((u16 volatile *) 0x04000030))
;#define         BG3PB           (*((u16 volatile *) 0x04000032))
;#define         BG3PC           (*((u16 volatile *) 0x04000034))
;#define         BG3PD           (*((u16 volatile *) 0x04000036))
;#define         BG3X            (*((u32 volatile *) 0x04000038))
;#define         BG3Y            (*((u32 volatile *) 0x0400003C))
;#define         WIN0H           (*((u16 volatile *) 0x04000040))
;#define         WIN1H           (*((u16 volatile *) 0x04000042))
;#define         WIN0V           (*((u16 volatile *) 0x04000044))
;#define         WIN1V           (*((u16 volatile *) 0x04000046))
;#define         WININ           (*((u16 volatile *) 0x04000048))
;#define         WINOUT          (*((u16 volatile *) 0x0400004A))
;#define         MOSAIC          (*((u16 volatile *) 0x0400004C))
;#define         BLDCNT          (*((u16 volatile *) 0x04000050))
;#define         BLDALPHA        (*((u16 volatile *) 0x04000052))
;#define         BLDY            (*((u16 volatile *) 0x04000054))
;---
;#define         DISPCNT2        (*((u32 volatile *) 0x04001000))
;#define         DISPSTAT2       (*((u16 volatile *) 0x04001004))
;#define         VCOUNT2         (*((u16 volatile *) 0x04001006))
;#define         BG0CNT2         (*((u16 volatile *) 0x04001008))
;#define         BG1CNT2         (*((u16 volatile *) 0x0400100A))
;#define         BG2CNT2         (*((u16 volatile *) 0x0400100C))
;#define         BG3CNT2         (*((u16 volatile *) 0x0400100E))
;#define         BG0HOFS2        (*((u16 volatile *) 0x04001010))
;#define         BG0VOFS2        (*((u16 volatile *) 0x04001012))
;#define         BG1HOFS2        (*((u16 volatile *) 0x04001014))
;#define         BG1VOFS2        (*((u16 volatile *) 0x04001016))
;#define         BG2HOFS2        (*((u16 volatile *) 0x04001018))
;#define         BG2VOFS2        (*((u16 volatile *) 0x0400101A))
;#define         BG3HOFS2        (*((u16 volatile *) 0x0400101C))
;#define         BG3VOFS2        (*((u16 volatile *) 0x0400101E))
;#define         BG2PA2          (*((u16 volatile *) 0x04001020))
;#define         BG2PB2          (*((u16 volatile *) 0x04001022))
;#define         BG2PC2          (*((u16 volatile *) 0x04001024))
;#define         BG2PD2          (*((u16 volatile *) 0x04001026))
;#define         BG2X2           (*((u32 volatile *) 0x04001028))
;#define         BG2Y2           (*((u32 volatile *) 0x0400102C))
;#define         BG3PA2          (*((u16 volatile *) 0x04001030))
;#define         BG3PB2          (*((u16 volatile *) 0x04001032))
;#define         BG3PC2          (*((u16 volatile *) 0x04001034))
;#define         BG3PD2          (*((u16 volatile *) 0x04001036))
;#define         BG3X2           (*((u32 volatile *) 0x04001038))
;#define         BG3Y2           (*((u32 volatile *) 0x0400103C))
;#define         WIN0H2          (*((u16 volatile *) 0x04001040))
;#define         WIN1H2          (*((u16 volatile *) 0x04001042))
;#define         WIN0V2          (*((u16 volatile *) 0x04001044))
;#define         WIN1V2          (*((u16 volatile *) 0x04001046))
;#define         WININ2          (*((u16 volatile *) 0x04001048))
;#define         WINOUT2         (*((u16 volatile *) 0x0400104A))
;#define         MOSAIC2         (*((u16 volatile *) 0x0400104C))
;#define         BLDCNT2         (*((u16 volatile *) 0x04001050))
;#define         BLDALPHA2       (*((u16 volatile *) 0x04001052))
;#define         BLDY2           (*((u16 volatile *) 0x04001054))
;---video memory defines
;#define         PAL_BG1         ((u16 *) 0x05000000)
;#define         PAL_FG1         ((u16 *) 0x05000200)
;#define         PAL_BG2         ((u16 *) 0x05000400)
;#define         PAL_FG2         ((u16 *) 0x05000600)
;---other video defines
;#define         VRAMBANKCNT     (((u16 volatile *) 0x04000240))
;#define         RGB(r,g,b)      ( ((r)&31) | (((g)&31)<<5) | (((b)&31)<<10) )
;#define         VRAM_SETBANK(bank, set) \
;                  if((bank)&1) { VRAMBANKCNT[(bank)>>1] = (VRAMBANKCNT[(bank)>>1]&0x00ff) | (((set)&0xff)<<8); } \
;                  else         { VRAMBANKCNT[(bank)>>1] = (VRAMBANKCNT[(bank)>>1]&0xff00) | ((set)&0xff); }
;---joypad input
;#define         KEYINPUT        (*((u16 volatile *) 0x04000130))
;#define         KEYCNT          (*((u16 volatile *) 0x04000132))
;---System registers
;#define         WAITCNT         (*((u16 volatile *) 0x04000204))
;//#define       IME             (*((u16 volatile *) 0x04000208))
;//#define       IE              (*((u32 volatile *) 0x04000210))
;//#define       IF              (*((u32 volatile *) 0x04000214))
;#define         HALTCNT         (*((u16 volatile *) 0x04000300))
;------------------
;:----------------- dswifi-src-0.3.17.tar\common\spinlock.h
;------------------
;BLAH: this is same as "spinlock.s" (and, this is outcommented via /* ... */
;      so, apparently "spinlock.s" is meant to be used instead of "spinlock.h"
;------------------
;/*
;__asm (
;".GLOBL SLasm_Acquire, SLasm_Release            \n"
;".ARM                                           \n"
;"SLasm_Acquire:                                 \n"
;"   ldr r2,[r0]                                 \n"
;"   cmp r2,#0                                   \n"
;"   movne r0,#1                                 \n"
;"   bxne lr                                     \n"
;"   mov r2,r1                                   \n"
;"   swp r2,r2,[r0]                              \n"
;"   cmp r2,#0                                   \n"
;"   cmpne r2,r1                                 \n"
;"   moveq r0,#0                                 \n"
;"   bxeq lr                                     \n"
;"   swp r2,r2,[r0]                              \n"
;"   mov r0,#1                                   \n"
;"   bx lr                                       \n"
;"                                               \n\n"
;"SLasm_Release:                                 \n"
;"   ldr r2,[r0]                                 \n"
;"   cmp r2,r1                                   \n"
;"   movne r0,#2                                 \n"
;"   bxne lr                                     \n"
;"   mov r2,#0                                   \n"
;"   swp r2,r2,[r0]                              \n"
;"   cmp r2,r1                                   \n"
;"   moveq r0,#0                                 \n"
;"   movne r0,#2                                 \n"
;"   bx lr                                       \n"
;);
;*/
;------------------
;:----------------- dswifi-src-0.3.17.tar\common\spinlock.s
;------------------
;.arch   armv5te        ;\BUGGED: that would be okay for ARM9, but the
;.cpu    arm946e-s      ;/spinlock functions are ALSO used on ARM7
;------------------
;uh, below two functions should use the "SPINLOCK_xxx" constants instead of
;hardcoded 0,1,2 values for NOBODY, OK, INUSE, ERROR
;------------------
SLasm_Acquire:   ;in: r0=sgWifiAp, r1=SPINLOCK_VALUE, out: r0
 ldr   r2,[r0]
 cmp   r2,0     ;aka SPINLOCK_NOBODY
 movne r0,1     ;aka SPINLOCK_INUSE
 bxne  lr
 mov   r2,r1    ;incoming SPINLOCK_ARMx
 swp   r2,r2,[r0]
 cmp   r2,0     ;aka SPINLOCK_NOBODY
 cmpne r2,r1    ;incoming SPINLOCK_ARMx
 moveq r0,0     ;aka SPINLOCK_OK
 bxeq  lr
 swp   r2,r2,[r0]
 mov   r0,1     ;aka SPINLOCK_INUSE
 bx    lr
;------------------
SLasm_Release:   ;in: r0=ptr+sgWifiAp_spinlock, r1=SPINLOCK_VALUE, out: r0
 ldr   r2,[r0]
 cmp   r2,r1    ;incoming SPINLOCK_ARMx
 movne r0,2     ;aka SPINLOCK_ERROR
 bxne  lr
 mov   r2,0     ;aka SPINLOCK_NOBODY
 swp   r2,r2,[r0]
 cmp   r2,r1    ;incoming SPINLOCK_ARMx
 moveq r0,0     ;aka SPINLOCK_OK
 movne r0,2     ;aka SPINLOCK_ERROR
 bx    lr
;------------------
;:----------------- dswifi-src-0.3.17.tar\common\wifi_shared.h
;------------------
WIFIINIT_OPTION_USELED         equ 0002h   ;uh, this is meant to MUST be same as "WFLAG_ARM9_USELED"
;------------------
;on spinlock contention, the side unsuccessfully attempting the lock reverts
;the lock.
;if the unlocking side sees the lock incorrectly set, the unlocking side will
;delay until it has reverted to the correct value, then continue unlocking.
;there should be a delay of at least about 10-20 cycles between a lock and
;unlock, to prevent contention.
;---
SPINLOCK_NOBODY  equ 0000h
SPINLOCK_ARM7    equ 0001h
SPINLOCK_ARM9    equ 0002h
;---
SPINLOCK_OK      equ 0000h
SPINLOCK_INUSE   equ 0001h
SPINLOCK_ERROR   equ 0002h
;---
;#ifdef ARM7
;  #define SPINLOCK_VALUE SPINLOCK_ARM7
;#endif
;#ifdef ARM9
;  #define SPINLOCK_VALUE SPINLOCK_ARM9
;#endif
;------------------
arm7_Spinlock_Acquire:  ;in: r0=sgWifiAp, out: r0
 add  r0,sgWifiAp_spinlock
 mov  r1,SPINLOCK_ARM7
 b    SLasm_Acquire
;---
arm9_Spinlock_Acquire:  ;in: r0=sgWifiAp, out: r0
 add  r0,sgWifiAp_spinlock
 mov  r1,SPINLOCK_ARM9
 b    SLasm_Acquire
;------------------
arm7_Spinlock_Release:  ;in: r0=sgWifiAp, out: r0
 add  r0,sgWifiAp_spinlock
 mov  r1,SPINLOCK_ARM7
 b    SLasm_Release
;---
arm9_Spinlock_Release:  ;in: r0=sgWifiAp, out: r0
 add  r0,sgWifiAp_spinlock
 mov  r1,SPINLOCK_ARM9
 b    SLasm_Release
;------------------
arm7_Spinlock_Check:  ;in: r0=sgWifiAp, out: r0
 ldr  r0,[r0,sgWifiAp_spinlock]
 cmp  r0,SPINLOCK_NOBODY
 movne r0,1
 moveq r0,0
 bx   lr
;------------------
;If for whatever reason you want to ditch SGIP and use your own stack,
;comment out the following line.
WIFI_USE_TCP_SGIP               equ 1
;------------------

       ; WIFI_RXBUFFER_SIZE              equ (1024*2)   ;XNAY
       ; WIFI_TXBUFFER_SIZE              equ (1024*2)   ;XNAY

WIFI_RXBUFFER_SIZE              equ (1024*12)  ;\buffers in Main RAM
WIFI_TXBUFFER_SIZE              equ (1024*24)  ;/
WIFI_MAX_AP                     equ 32
WIFI_MAX_ASSOC_RETRY            equ 30
WIFI_PS_POLL_CONST              equ 2
WIFI_MAX_PROBE                  equ 4
WIFI_AP_TIMEOUT                 equ 3  ;old=40 (old=40 was for N channels, new=3 from 2018 is for ALL channels N times, ie. expire after scanning 3x14 channels)
;------------------
WFLAG_PACKET_DATA               equ 0001h
WFLAG_PACKET_MGT                equ 0002h
WFLAG_PACKET_BEACON             equ 0004h
WFLAG_PACKET_CTRL               equ 0008h
WFLAG_PACKET_ALL                equ 0FFFFh
;------------------
WFLAG_ARM7_ACTIVE               equ 0001h
WFLAG_ARM7_RUNNING              equ 0002h
;------------------
WFLAG_ARM9_ACTIVE               equ 0001h
WFLAG_ARM9_USELED               equ 0002h  ;aka WIFIINIT_OPTION_USELED
WFLAG_ARM9_ARM7READY            equ 0004h
WFLAG_ARM9_NETUP                equ 0008h
WFLAG_ARM9_NETREADY             equ 0010h
;------------------
WFLAG_ARM9_INITFLAGMASK         equ 0002h  ;aka WIFIINIT_OPTION_USELED
;------------------
WFLAG_IP_GOTDHCP                equ 0001h
;------------------
;request - request flags
WFLAG_REQ_APCONNECT             equ 0001h
WFLAG_REQ_APCOPYVALUES          equ 0002h
WFLAG_REQ_APADHOC               equ 0008h  ;-uh, there's no situation ever SETTING this bit?
WFLAG_REQ_PROMISC               equ 0010h
WFLAG_REQ_USEWEP                equ 0020h  ;-BLAH/UNUSED
;------------------
;request - informational flags
WFLAG_REQ_APCONNECTED           equ 8000h
;------------------
WFLAG_APDATA_ADHOC              equ 0001h
WFLAG_APDATA_WEP                equ 0002h
WFLAG_APDATA_WPA                equ 0004h
WFLAG_APDATA_COMPATIBLE         equ 0008h  ;\uh, somehow set depending on supported rates, but NOT actually USED elsewhere
WFLAG_APDATA_EXTCOMPATIBLE      equ 0010h  ;/
WFLAG_APDATA_SHORTPREAMBLE      equ 0020h  ;-BLAH/UNUSED
WFLAG_APDATA_ACTIVE             equ 8000h
;------------------
RSNIE_NULL                      equ 0000h
RSNIE_GRP_WEP40                 equ 0001h
RSNIE_GRP_WEP104                equ 0002h
RSNIE_GRP_TKIP                  equ 0004h
RSNIE_GRP_AES                   equ 0008h
RSNIE_PAIR_WEPNONE              equ 0010h
RSNIE_PAIR_TKIP                 equ 0020h
RSNIE_PAIR_AES                  equ 0040h
;---
EAPOL_TYPE_NONE         equ 0
EAPOL_TYPE_WPA          equ 1
EAPOL_TYPE_WPA2         equ 2
EAPOL_TYPE_ERROR        equ 3
;---
KEY_TYPE_ERROR          equ 0   ;-oops, no matching key
KEY_TYPE_NONE           equ 1   ;\
KEY_TYPE_WEP            equ 2   ; these are SAME values as for dsi/atheros
KEY_TYPE_TKIP           equ 3   ; (for use in CONNECT and ADD_CIPHER commands)
KEY_TYPE_AES            equ 4   ;/
;------------------
WIFI_RETURN_OK          equ 0   ;everything went ok
WIFI_RETURN_LOCKFAILED  equ 1   ;the spinlock attempt failed (it wasn't retried cause that could lock both cpus- retry again after a delay.
WIFI_RETURN_ERROR       equ 2   ;there was an error in attempting to complete the requested task.
WIFI_RETURN_PARAMERROR  equ 3   ;there was an error in the parameters passed to the function.
;------------------
;software stats enum's...
WSTAT_RXQUEUEDPACKETS   equ 00h ;number of packets queued into the rx fifo
WSTAT_TXQUEUEDPACKETS   equ 01h ;number of packets queued into the tx fifo
WSTAT_RXQUEUEDBYTES     equ 02h ;number of bytes queued into the rx fifo
WSTAT_TXQUEUEDBYTES     equ 03h ;number of bytes queued into the tx fifo
WSTAT_RXQUEUEDLOST      equ 04h ;number of packets lost due to space limitations in queuing
WSTAT_TXQUEUEDREJECTED  equ 05h ;number of packets rejected due to space limitations in queuing
WSTAT_RXPACKETS         equ 06h
WSTAT_RXBYTES           equ 07h
WSTAT_RXDATABYTES       equ 08h
WSTAT_TXPACKETS         equ 09h
WSTAT_TXBYTES           equ 0Ah
WSTAT_TXDATABYTES       equ 0Bh
WSTAT_ARM7_UPDATES      equ 0Ch
WSTAT_DEBUG             equ 0Dh
;- - - harware stats enum's (function mostly unknown.)
WSTAT_HW_1B0            equ 0Eh  ;\
WSTAT_HW_1B1            equ 0Fh  ;
WSTAT_HW_1B2            equ 10h  ;
WSTAT_HW_1B3            equ 11h  ;
WSTAT_HW_1B4            equ 12h  ;
WSTAT_HW_1B5            equ 13h  ;
WSTAT_HW_1B6            equ 14h  ;
WSTAT_HW_1B7            equ 15h  ;
WSTAT_HW_1B8            equ 16h  ;
WSTAT_HW_1B9            equ 17h  ;
WSTAT_HW_1BA            equ 18h  ;
WSTAT_HW_1BB            equ 19h  ;
WSTAT_HW_1BC            equ 1Ah  ;
WSTAT_HW_1BD            equ 1Bh  ;
WSTAT_HW_1BE            equ 1Ch  ;
WSTAT_HW_1BF            equ 1Dh  ;/
WSTAT_HW_1C0            equ 1Eh  ;\
WSTAT_HW_1C1            equ 1Fh  ;/
WSTAT_HW_1C4            equ 20h  ;\
WSTAT_HW_1C5            equ 21h  ;/
WSTAT_HW_1D0            equ 22h  ;\
WSTAT_HW_1D1            equ 23h  ;
WSTAT_HW_1D2            equ 24h  ;
WSTAT_HW_1D3            equ 25h  ;
WSTAT_HW_1D4            equ 26h  ;
WSTAT_HW_1D5            equ 27h  ;
WSTAT_HW_1D6            equ 28h  ;
WSTAT_HW_1D7            equ 29h  ;
WSTAT_HW_1D8            equ 2Ah  ;
WSTAT_HW_1D9            equ 2Bh  ;
WSTAT_HW_1DA            equ 2Ch  ;
WSTAT_HW_1DB            equ 2Dh  ;
WSTAT_HW_1DC            equ 2Eh  ;
WSTAT_HW_1DD            equ 2Fh  ;
WSTAT_HW_1DE            equ 30h  ;
WSTAT_HW_1DF            equ 31h  ;/
;- - - num stat entries:
NUM_WIFI_STATS          equ 32h
;------------------
;user code should NEVER have to use the WIFI_MODE or WIFI_AUTHLEVEL enums...
WIFIMODE_DISABLED            equ 00h
WIFIMODE_NORMAL              equ 01h
WIFIMODE_SCAN                equ 02h
WIFIMODE_ASSOCIATE           equ 03h
WIFIMODE_ASSOCIATED          equ 04h
WIFIMODE_DISASSOCIATE        equ 05h
WIFIMODE_CANNOTASSOCIATE     equ 06h
;---
WIFI_AUTHLEVEL_DISCONNECTED  equ 00h
WIFI_AUTHLEVEL_AUTHENTICATED equ 01h
WIFI_AUTHLEVEL_ASSOCIATED    equ 02h
WIFI_AUTHLEVEL_DEASSOCIATED  equ 03h    ;uh, original code does NEVER set authlevel to this value (even when receiving a Disassoc message)
;------------------
WEPMODE_NONE   equ 0    ;\
WEPMODE_40BIT  equ 1    ; enum's
WEPMODE_128BIT equ 2    ;/
;------------------
;ASSOCSTATUS enum's returned by arm9_Wifi_AssocStatus() after calling arm9_Wifi_ConnectAPk
;uh, that should be probably "Wifi_ConnectAP" not "Wifi_ConnectAPk" (TYPO: "k")
ASSOCSTATUS_DISCONNECTED   equ 0 ;not *trying* to connect
ASSOCSTATUS_SEARCHING      equ 1 ;data given does not completely specify an AP, looking for AP that matches the data.
ASSOCSTATUS_AUTHENTICATING equ 2 ;connecting...
ASSOCSTATUS_ASSOCIATING    equ 3 ;connecting...
ASSOCSTATUS_ACQUIRINGDHCP  equ 4 ;connected to AP, but getting IP data from DHCP
ASSOCSTATUS_ASSOCIATED     equ 5 ;Connected! (COMPLETE if arm9_Wifi_ConnectAP was called to start)
ASSOCSTATUS_CANNOTCONNECT  equ 6 ;error in connecting... (COMPLETE if arm9_Wifi_ConnectAP was called to start)
;------------------
;most user code will never need to know about the WIFI_TXHEADER or WIFI_RXHEADER
;struct Wifi_TxHeader:
 sgTxHdr_enable_flags equ 00h ;2  ;u16 enable_flags  ;uh, actually: status
 sgTxHdr_unknown      equ 02h ;2  ;u16 unknown       ;maybe multiplayer related?
 sgTxHdr_countup      equ 04h ;2  ;u16 countup       ;uh, W_TX_SEQNO related
 sgTxHdr_beaconfreq   equ 06h ;2  ;u16 beaconfreq    ;uh, what?
 sgTxHdr_tx_rate      equ 08h ;2  ;u16 tx_rate
 sgTxHdr_tx_length    equ 0Ah ;2  ;u16 tx_length
 sgTxHdr_size         equ 0Ch ;total
;---
;struct Wifi_RxHeader:
 sgRxHdr_a            equ 00h ;2  ;u16 a            ;uh, actually flags/type
 sgRxHdr_b            equ 02h ;2  ;u16 b            ;unknown (usually 0040h)
 sgRxHdr_c            equ 04h ;2  ;u16 c            ;uh, actually time since last packet
 sgRxHdr_d            equ 06h ;2  ;u16 d            ;uh, actually rate
 sgRxHdr_byteLength   equ 08h ;2  ;u16 byteLength
 sgRxHdr_rssi_        equ 0Ah ;2  ;u16 rssi_        ;max,min RSSI "Recieved Signal Strength Indicator"
 sgRxHdr_size         equ 0Ch ;total
;------------------
;WIFI_ACCESSPOINT is an important structure in that it defines how to connect
;to an access point.
;listed inline are information about the members and their function
;if a field is not necessary for arm9_Wifi_ConnectAP it will be marked as such
;*only* 4 fields are absolutely required to be filled in correctly for the
;connection to work, they are:  ssid, ssid_len, bssid, and channel
;all others can be ignored (though flags should be set to 0)
;---
;struct Wifi_AccessPoint:
 sgWifiAp_ssid       equ 00h ;21h ;char ssid[33]       ;the AP's SSID - zero terminated is not necessary.. if ssid[0] is zero, the ssid will be ignored in trying to find an AP to connect to. [REQUIRED]  ;(0..32 bytes, plus ending zero)
 sgWifiAp_ssid_len   equ 21h ;1   ;char ssid_len       ;number of valid bytes in the ssid field (0-32) [REQUIRED]
 sgWifiAp_bssid      equ 22h ;6   ;u8   bssid[6]       ;BSSID is the AP's SSID - setting it to all 00's indicates this is not known and it will be ignored [REQUIRED]
 sgWifiAp_macaddr    equ 28h ;6   ;u8   macaddr[6]     ;mac address of the "AP" is only necessary in ad-hoc mode. [generally not required to connect]
 sgWifiAp_maxrate    equ 2Eh ;2   ;u16  maxrate        ;max rate is measured in steps of 1/2Mbit - 5.5Mbit will be represented as 11, or 0x0B [not required to connect]
 sgWifiAp_timectr    equ 30h ;4   ;u32  timectr        ;internal information about how recently a beacon has been received [not required to connect]
 sgWifiAp_rssi       equ 34h ;2   ;u16  rssi           ;running average of the recent RSSI values for this AP, will be set to 0 after not receiving beacons for a while. [not required to connect]
 sgWifiAp_flags      equ 36h ;2   ;u16  flags          ;flags indicating various parameters for the AP [not required, but the WFLAG_APDATA_ADHOC flag will be used]
 sgWifiAp_spinlock   equ 38h ;4   ;u32  spinlock       ;internal data word used to lock the record to guarantee data coherence [not required to connect]
 sgWifiAp_channel    equ 3Ch ;1   ;u8   channel        ;valid channels are 1-13, setting the channel to 0 will indicate the system should search. [REQUIRED]
 sgWifiAp_reserved   equ 3Dh ;(3) ;alignment padding ;uh, insert padding here (so else below byte-arrays aren't aligned, and WORSE, sgWifiAp_size wouldn't be aligned, so access-point arrays would have misaligned array entries)
 sgWifiAp_rssi_past  equ 40h ;8   ;u8   rssi_past[8]   ;rssi_past indicates the RSSI values for the last 8 beacons received ([7] is the most recent) [not required to connect]
 sgWifiAp_base_rates equ 48h ;10h ;u8   base_rates[16] ;list of the base rates "required" by the AP (same format as maxrate) - zero-terminated list [not required to connect]
 sgWifiAp_rsnie_wpa  equ 58h ;4
 sgWifiAp_rsnie_wpa2 equ 5Ch ;4
 sgWifiAp_size       equ 60h ;total
;------------------
;struct sgBeacon:  ;info from beacon's header
;(new structure invented for "with_dsi_wifi", for passing some info)
 sgBeacon_sa         equ 00h  ;6
 sgBeacon_bssid      equ 06h  ;6
 sgBeacon_strength   equ 0Ch  ;1
 sgBeacon_reserved   equ 0Dh  ;3
 sgBeacon_size       equ 10h  ;total
;------------------
;struct sgWifiWfc:
 ;this structure combines the "sgWifiAp" structure (in first some bytes),
 ;plus extra WFC data (WEP key and other stuff from wifi flash memory)
 ;- - -
 ;this structure doesn't exist in that form in original code (instead it used
 ;several separate arrays (wfc_ap[3], wfc_enable[4], wfc_config[3][5], and
 ;wfc_wepkey[3][16]) instead of a single structure
 ;BUGGED: the comment for the "wfc_config[3][5]" array claims snmask to be 2nd
 ;entry, and gateway to be 3rd entry (but actual code uses it vice-versa)
 ;- - -
 sgWifiWfc_ap       equ 00h  ;sgWifiAp_xx ;..  ;-public WifiAp data (as for beacons)
 sgWifiWfc_wepkey   equ 00h+sgWifiAp_size ;10h ;\
 sgWifiWfc_ip       equ 10h+sgWifiAp_size ;4   ;
 sgWifiWfc_gateway  equ 14h+sgWifiAp_size ;4   ; secret data (WEP key,
 sgWifiWfc_1st_dns  equ 18h+sgWifiAp_size ;4   ; and user-specified Non-DHCP
 sgWifiWfc_2nd_dns  equ 1ch+sgWifiAp_size ;4   ; settings)
 sgWifiWfc_subnet   equ 20h+sgWifiAp_size ;4   ;
 sgWifiWfc_enable   equ 24h+sgWifiAp_size ;1   ;
 sgWifiWfc_wepmode  equ 25h+sgWifiAp_size ;1   ;
 .if with_dsi_wifi                             ;
  sgWifiWfc_wpamode equ 26h+sgWifiAp_size ;1   ;
  sgWifiWfc_eapol   equ 27h+sgWifiAp_size ;1   ; ;-eapol type (none/wpa/wpa2/none/error) ;\these are not FLASH settings,
  sgWifiWfc_grp     equ 28h+sgWifiAp_size ;1   ; ;-group key type    (none/wep/tkip/aes) ;/(but, MATCHED to supported FLASH/CONSOLE capabilities)
  sgWifiWfc_pair    equ 29h+sgWifiAp_size ;1   ; ;-pairwise key type (none/wep/tkip/aes) ; but rather detected ACCESS POINT capabilities from BEACON
  sgWifiWfc_padding equ 2Ah+sgWifiAp_size ;2   ;
  sgWifiWfc_psk     equ 2Ch+sgWifiAp_size ;20h ;
  sgWifiWfc_size    equ 4Ch+sgWifiAp_size      ;
 .else                                         ;
  sgWifiWfc_padding equ 26h+sgWifiAp_size ;2   ;
  sgWifiWfc_size    equ 28h+sgWifiAp_size      ;/
 .endif
;------------------
.if with_dsi_wifi
  NUM_WFC_ENTRIES equ 6   ;with three new entries for 4/5/6 with wpa/wpa2
.else
  NUM_WFC_ENTRIES equ 3   ;this was hardcoded in original code (ie. using "3" instead of the "NUM_WFC_ENTRIES" symbol)
.endif
;------------------
;struct Wifi_MainStruct: -- aka global variables, shared for ARM7 and ARM9
;- - - -
;below WifiData_xxx are essentially global variables, although original code
;does have them defined as "structure" instead of normal global variables,
;the reason is probably that the compiler couldn't define global variables
;that could he used on both ARM7 and ARM9 (whilst structures in .h files
;can be used on both processors, so the original code used that structure,
;combined with a base pointer to the structure, and with that pointer being
;passed from arm9_Wifi_init to arm7_Wifi_Init).
;anyways, when having all ARM7/ARM9 code and data in a single file, it's
;easier to define the variables as such (instead of as structure).
;- - - -
;below WifiData_xxx should be in UNCACHED Main RAM, so both ARM7 and ARM9
;can access them without cache-issues, ie. they should be located somewhere
;at 2FFFxxxh or so (which would be a mirror on NDS, or separare mem on DSi),
;and that memory area should be defined as accessible/uncached via PU.
;- - - -
.data?
 org ($ or UnCachedBase)  ;<-- uncached area (eg. 2FFxxxxh instead 23Fxxxxh)
.align 100h  ;XXXX maybe needed to ensure no cache-line boundary?
Wifi_Data_Struct_start:
 WifiData_dummy1:        defs 20h; 00h ;20h  unsigned long dummy1[8]
 ;---wifi status
 WifiData_curChannel     dw 0    ; 20h ;2    u16  curChannel
 WifiData_reqChannel     dw 0    ; 22h ;2    u16  reqChannel
 WifiData_curMode        dw 0    ; 24h ;2    u16  curMode
 WifiData_reqMode        dw 0    ; 26h ;2    u16  reqMode
 WifiData_authlevel      dw 0    ; 28h ;2    u16  authlevel
 WifiData_authctr        dw 0    ; 2Ah ;2    u16  authctr
 WifiData_flags9         dd 0    ; 2Ch ;4    vu32 flags9
 WifiData_flags7         dd 0    ; 30h ;4    vu32 flags7
 WifiData_reqPacketFlags dd 0    ; 34h ;4    u32  reqPacketFlags
 WifiData_curReqFlags    dw 0    ; 38h ;2    u16  curReqFlags
 WifiData_reqReqFlags    dw 0    ; 3Ah ;2    u16  reqReqFlags
 WifiData_counter7       dd 0    ; 3Ch ;4    u32  counter7
 WifiData_bootcounter7   dd 0    ; 40h ;4    u32  bootcounter7
 WifiData_MacAddr:       defs 6  ; 44h ;6    u16  MacAddr[3]
 WifiData_authtype       dw 0    ; 4Ah ;2    u16  authtype   ;BLAH/UNUSED
 WifiData_iptype         dw 0    ; 4Ch ;2    u16  iptype     ;BLAH/UNUSED
 WifiData_ipflags        dw 0    ; 4Eh ;2    u16  ipflags    ;BLAH/UNUSED
 WifiData_ip             dd 0    ; 50h ;4    u32  ip         ;BLAH/UNUSED
 WifiData_snmask         dd 0    ; 54h ;4    u32  snmask     ;BLAH/UNUSED
 cifiData_gateway        dd 0    ; 58h ;4    u32  gateway    ;BLAH/UNUSED
 ;---current AP data
 WifiData_ssid7:         defs 34 ; 5Ch ;22h  char ssid7[34]  ;byte[0]=len, byte[1..N]=SSID
 WifiData_ssid9:         defs 34 ; 7Eh ;22h  char ssid9[34]  ;byte[0]=len, byte[1..N]=SSID
 WifiData_bssid7:        defs 6  ; A0h ;6    u16  bssid7[3]
 WifiData_bssid9:        defs 6  ; A6h ;6    u16  bssid9[3]
 WifiData_apmac7:        defs 6  ; ACh ;6    u8   apmac7[6]
 WifiData_apmac9:        defs 6  ; B2h ;6    u8   apmac9[6]
 WifiData_wepmode7       db 0    ; B8h ;1    char wepmode7
 WifiData_wepmode9       db 0    ; B9h ;1    char wepmode9
 WifiData_wepkeyid7      db 0    ; BAh ;1    char wepkeyid7
 WifiData_wepkeyid9      db 0    ; BBh ;1    char wepkeyid9
 WifiData_wepkey7:       defs 20 ; BCh ;14h  u8   wepkey7[20]
 WifiData_wepkey9:       defs 20 ; D0h ;14h  u8   wepkey9[20]
 WifiData_baserates7:    defs 16 ; E4h ;10h  u8   baserates7[16]
 WifiData_baserates9:    defs 16 ; F4h ;10h  u8   baserates9[16]
 WifiData_apchannel7     db 0    ;104h ;1    u8   apchannel7
 WifiData_apchannel9     db 0    ;105h ;1    u8   apchannel9
 WifiData_maxrate7       db 0    ;106h ;1    u8   maxrate7
 .if with_dsi_wifi                              ;\
 ;WifiData_wpamode7       db 0    ; ..h ;1    char wpamode7
 ;WifiData_wpamode9       db 0    ; ..h ;1    char wpamode9
  WifiData_eapol7         db 0
  WifiData_eapol9         db 0
  WifiData_grp7           db 0
  WifiData_grp9           db 0
  WifiData_pair7          db 0
  WifiData_pair9          db 0
  WifiData_gtk_index7     db 0
  WifiData_4way_handshake_busy  db 0
  WifiData_expected_handshake   db 0
  WifiData_handshake_crypt db 0   ;1=WPA-TKIP or WPA2-TKIP, 2=WPA-AES or WPA2-AES or WPA2-AES+TKIP
  .align 4
  WifiData_rsnie7_wpa     dd 0
  WifiData_rsnie9_wpa     dd 0
  WifiData_rsnie7_wpa2    dd 0
  WifiData_rsnie9_wpa2    dd 0
  WifiData_psk7:          defs 32 ; ..h ;14h  u8   psk7[32]
  WifiData_psk9:          defs 32 ; ..h ;14h  u8   psk9[32]
  WifiData_anonce7:       defs 32
  WifiData_snonce7:       defs 32
  WifiData_ptk7:          defs 64
  WifiData_gtk7:          defs 32
  WifiData_rsc7:          defs 8
  WifiData_replay7:       defs 8
  WifiData_reg_domain     dd 0
  WifiData_reg_channels   dd 0
 .endif
   .align 4 ;uh, really NEED alignment (right here)!
 WifiData_curr_AP        dd 0
 WifiData_ap_rssi        dw 0    ;   h ;2    u16  ap_rssi
 WifiData_pspoll_period  dw 0    ;   h ;2    u16  pspoll_period
 ;---AP data
 WifiData_aplist:        defs sgWifiAp_size*WIFI_MAX_AP  ;     ;..   Wifi_AccessPoint aplist[WIFI_MAX_AP]
 ;---probe stuff
 WifiData_probe9_numprobe db 0                           ;     ;1    u8   probe9_numprobe
   .align 4 ;uh, really NEED alignment (here, or after the below ssid strings)!
 WifiData_probe9_ssidlen: defs WIFI_MAX_PROBE            ;     ;..   u8   probe9_ssidlen[WIFI_MAX_PROBE]
 WifiData_probe9_ssid:    defs WIFI_MAX_PROBE*32         ;     ;..   char probe9_ssid[WIFI_MAX_PROBE][32]
 ;---WFC data
 WifiData_wfc_ap:    defs sgWifiWfc_size*NUM_WFC_ENTRIES ;     ;<-- original code didn't have this in a single structure, see "sgWifiWfc" for details (instead it used FOUR arrays: wfc_enable[4], wfc_ap[3], wfc_config[3][5]m, wfc_wepkey[3][16])
 ;---wifi data
 WifiData_rxbufIn      dd 0                     ;     ;4    u32  rxbufIn   ;\bufIn/bufOut have 2-byte granularity
 WifiData_rxbufOut     dd 0                     ;     ;4    u32  rxbufOut  ;/
 WifiData_rxbufData:   defs WIFI_RXBUFFER_SIZE  ;     ;..   u16  rxbufData[WIFI_RXBUFFER_SIZE/2]  ;send raw 802.11 data through! rxbuffer is for rx'd data, arm7->arm9 transfer
 WifiData_txbufIn      dd 0                     ;     ;4    u32  txbufIn
 WifiData_txbufOut     dd 0                     ;     ;4    u32  txbufOut
 WifiData_txbufData:   defs WIFI_TXBUFFER_SIZE  ;     ;..   u16  txbufData[WIFI_TXBUFFER_SIZE/2]  ;tx buffer is for data to tx, arm9->arm7 transfer
 ;---stats data
 WifiData_stats:       defs NUM_WIFI_STATS*4    ;     ;..   u32  stats[NUM_WIFI_STATS]
 WifiData_debug:       defs 3Ch                 ;     ;3Ch  u16  debug[30]  ;bytes: 60 decimal
 WifiData_random       dd 0                     ;     ;4    u32  random // semirandom number updated at the convenience of the arm7. use for initial seeds & such.
 WifiData_dummy2:      defs 20h                 ;     ;20h  unsigned long dummy2[8]
 ;---
 .if with_soft_wep
   wep_key:     defs 20h
   wep_keylen:  dd 0
   crc32_table: defs 400h  ;100h dwords (1K)
 .endif
 ;---
Wifi_Data_Struct_end:
        Xtra_uncached_mem_start:
 arm9_call_addr dd 0
 nds_wifi_chip_id    dw 0 ;\
 nds_wifi_bb_rf_type dw 0 ;/
 sdio_chip_id        dd 0
 .if with_blowfish
   keyinfo:
    keyname: dd 0  ;gamecode/idcode
    keymode: dd 0  ;00h=none, 08h=gamecart, 0Ch=firmware (upper bits always zero)
    keylevel:dd 0  ;apply_level (1..3 = once,twice,thrice)
    keydsi:  dd 0  ;nds/dsi key
    keycode: defs 0ch
    keybuf:  defs 1048h
   nds_blowfish_key: defs 1048h
 .endif
.align 100h  ;XXXX maybe needed to ensure no cache-line boundary?
 vblank_count           dd 0
 random_count           dd 0
 rtc_datetime:          defs 8
 recent_heartbeat       dd 0
 curr_wpa_tx_callback_list_ptr dd 0
 dsi_wifi_flag          db 0
 .align 4
        Xtra_uncached_mem_end:
.align 100h  ;XXXX maybe needed to ensure no cache-line boundary?
 org ($-UnCachedBase)  ;<-- back to cached area (eg. 23Fxxxxh instead 2FFxxxxh)
.code
;------------------
;:----------------- dswifi-src-0.3.17.tar\include\dswifi7.h
;------------------
;(doesn't contain anything important... aside from some comments/documentation)
;------------------
;CALLBACK (*WifiSyncHandler)();
;  Wifi Sync Handler function: Callback function that is called when the arm9
;  needs to be told to synchronize with new fifo data.
;  If this callback is used (see arm7_Wifi_SetSyncHandler()), it should send a
;  message via the fifo to the arm9, which will call arm9_Wifi_Sync() on arm9.
;------------------
;extern void Read_Flash(int address, char * destination, int length);
;  Read_Flash: Reads an arbitrary amount of data from the firmware flash chip
;    int address:        Offset to start reading from in the flash chip
;    char * destination: Pointer to a memory buffer to hold incoming data
;    int length:         The number of bytes to read
;------------------
;extern int arm7_PowerChip_ReadWrite(int cmd, int data);
;  arm7_PowerChip_ReadWrite: Reads or writes a value to the DS's power chip
;    int cmp:  The byte-long command to send to the chip ;TYPO: "cmd", not "cmp"
;              (top bit 1=read, 0=write,  other bits=register ID to read/write)
;    int data: The data to write to the chip
;              (if sending a read command, this should be zero)
;    Returns:  The data read returned by the serial connection; only really
;               useful when reading.
;------------------
;extern void arm7_Wifi_Interrupt();
;  arm7_Wifi_Interrupt: Handler for the arm7 wifi interrupt. Should be called
;  by the interrupt handler on arm7, and should *not* have multiple interrupts
;  enabled.
;------------------
;extern void arm7_Wifi_Update();
;  arm7_Wifi_Update: Sync function to ensure data continues to flow between
;  the two CPUs smoothly.  Should be called at a periodic interval, such as
;  in vblank.
;------------------
;extern void arm7_Wifi_Init(unsigned long WifiData);
;  arm7_Wifi_Init: Requires the data returned by the arm9_Wifi_Init call.
;  The arm9_Wifi_Init call's returned data must be passed to the arm7 and
;  then given to this function (or else very bad things happen).
;  This function also enables power to the wifi system, which will shorten
;  battery life.
;    unsigned long WifiData: You must pass the 32bit value returned by the
;                            call to  arm9_Wifi_Init on the ARM9.
;------------------
;extern void arm7_Wifi_Deinit();
;  arm7_Wifi_Deinit: In the case that it is necessary, this function cuts
;  power to the wifi system.  After this the wifi will be unusable until
;  arm7_Wifi_Init is called again.
;------------------
;extern void arm7_Wifi_Sync();
;  arm7_Wifi_Sync: Call this function when requested to sync by the arm9 side
;  of the wifi lib
;------------------
;extern void arm7_Wifi_SetSyncHandler(WifiSyncHandler sh);
;  arm7_Wifi_SetSyncHandler: Call this function to request notification of when
;  the ARM9-side arm9_Wifi_Sync function should be called.
;    WifiSyncHandler sh:  Pointer to the function to be called for notification.
;------------------
;extern void arm7_installWifiFIFO();
;------------------
;:----------------- dswifi-src-0.3.17.tar\include\dswifi9.h
;------------------
;this file consists of two parts (all fairly useless):
;---
;PART1:
;BLAH: useless DUPLICATED crap, same as in "wifi_shared.h" (and "wifi_arm9.h")
;---
;PART2:
;(doesn't contain anything important... aside from some comments/documentation)
;------------------
;PART1:
;------------------
;well, some flags and stuff are just stuffed in here and not documented very
;well yet... Most of the important stuff is documented though.
;Next version should clean up some of this a lot more :)
;------------------
;(same as wifi_shared.h) WIFIINIT_OPTION_USELED         equ 0002h
;(same as wifi_shared.h) ;------------------
;(UNLIKE wifi_arm9.h)    ;default option is to use 64k heap
;(UNLIKE wifi_arm9.h)    WIFIINIT_OPTION_USEHEAP_64     equ 0000h  ;\BUGGED: defined differently elsewhere
;(UNLIKE wifi_arm9.h)    WIFIINIT_OPTION_USEHEAP_128    equ 1000h  ;/
;(same as wifi_arm9.h)   WIFIINIT_OPTION_USEHEAP_256    equ 2000h
;(same as wifi_arm9.h)   WIFIINIT_OPTION_USEHEAP_512    equ 3000h
;(same as wifi_arm9.h)   WIFIINIT_OPTION_USECUSTOMALLOC equ 4000h
;(same as wifi_arm9.h)   WIFIINIT_OPTION_HEAPMASK       equ F000h
;(same as wifi_shared.h) ;------------------
;(same as wifi_shared.h) WFLAG_PACKET_DATA              equ 0001h
;(same as wifi_shared.h) WFLAG_PACKET_MGT               equ 0002h
;(same as wifi_shared.h) WFLAG_PACKET_BEACON            equ 0004h
;(same as wifi_shared.h) WFLAG_PACKET_CTRL              equ 0008h
;(same as wifi_shared.h) WFLAG_PACKET_ALL               equ 0FFFFh
;(same as wifi_shared.h) ;------------------
;(same as wifi_shared.h) WFLAG_APDATA_ADHOC             equ 0001h
;(same as wifi_shared.h) WFLAG_APDATA_WEP               equ 0002h
;(same as wifi_shared.h) WFLAG_APDATA_WPA               equ 0004h
;(same as wifi_shared.h) WFLAG_APDATA_COMPATIBLE        equ 0008h
;(same as wifi_shared.h) WFLAG_APDATA_EXTCOMPATIBLE     equ 0010h
;(same as wifi_shared.h) WFLAG_APDATA_SHORTPREAMBLE     equ 0020h
;(same as wifi_shared.h) WFLAG_APDATA_ACTIVE            equ 8000h
;(same as wifi_shared.h) ;------------------
;(same as wifi_shared.h) WIFI_RETURN_OK          equ 0  ;everything went ok
;(same as wifi_shared.h) WIFI_RETURN_LOCKFAILED  equ 1  ;the spinlock attempt failed (it wasn't retried cause that could lock both cpus- retry again after a delay.
;(same as wifi_shared.h) WIFI_RETURN_ERROR       equ 2  ;there was an error in attempting to complete the requested task.
;(same as wifi_shared.h) WIFI_RETURN_PARAMERROR  equ 3  ;there was an error in the parameters passed to the function.
;(same as wifi_shared.h) ;------------------
;(same as wifi_shared.h) ;software stats enum's...
;(same as wifi_shared.h) WSTAT_RXQUEUEDPACKETS  equ 00h ;number of packets queued into the rx fifo
;(same as wifi_shared.h) WSTAT_TXQUEUEDPACKETS  equ 01h ;number of packets queued into the tx fifo
;(same as wifi_shared.h) WSTAT_RXQUEUEDBYTES    equ 02h ;number of bytes queued into the rx fifo
;(same as wifi_shared.h) WSTAT_TXQUEUEDBYTES    equ 03h ;number of bytes queued into the tx fifo
;(same as wifi_shared.h) WSTAT_RXQUEUEDLOST     equ 04h ;number of packets lost due to space limitations in queuing
;(same as wifi_shared.h) WSTAT_TXQUEUEDREJECTED equ 05h ;number of packets rejected due to space limitations in queuing
;(same as wifi_shared.h) WSTAT_RXPACKETS        equ 06h
;(same as wifi_shared.h) WSTAT_RXBYTES          equ 07h
;(same as wifi_shared.h) WSTAT_RXDATABYTES      equ 08h
;(same as wifi_shared.h) WSTAT_TXPACKETS        equ 09h
;(same as wifi_shared.h) WSTAT_TXBYTES          equ 0Ah
;(same as wifi_shared.h) WSTAT_TXDATABYTES      equ 0Bh
;(same as wifi_shared.h) WSTAT_ARM7_UPDATES     equ 0Ch
;(same as wifi_shared.h) WSTAT_DEBUG            equ 0Dh
;(same as wifi_shared.h) ;harware stats (function mostly unknown.)
;(same as wifi_shared.h) WSTAT_HW_1B0           equ 0Eh
;(same as wifi_shared.h) WSTAT_HW_1B1           equ 0Fh
;(same as wifi_shared.h) WSTAT_HW_1B2           equ 10h
;(same as wifi_shared.h) WSTAT_HW_1B3           equ 11h
;(same as wifi_shared.h) WSTAT_HW_1B4           equ 12h
;(same as wifi_shared.h) WSTAT_HW_1B5           equ 13h
;(same as wifi_shared.h) WSTAT_HW_1B6           equ 14h
;(same as wifi_shared.h) WSTAT_HW_1B7           equ 15h
;(same as wifi_shared.h) WSTAT_HW_1B8           equ 16h
;(same as wifi_shared.h) WSTAT_HW_1B9           equ 17h
;(same as wifi_shared.h) WSTAT_HW_1BA           equ 18h
;(same as wifi_shared.h) WSTAT_HW_1BB           equ 19h
;(same as wifi_shared.h) WSTAT_HW_1BC           equ 1Ah
;(same as wifi_shared.h) WSTAT_HW_1BD           equ 1Bh
;(same as wifi_shared.h) WSTAT_HW_1BE           equ 1Ch
;(same as wifi_shared.h) WSTAT_HW_1BF           equ 1Dh
;(same as wifi_shared.h) WSTAT_HW_1C0           equ 1Eh
;(same as wifi_shared.h) WSTAT_HW_1C1           equ 1Fh
;(same as wifi_shared.h) WSTAT_HW_1C4           equ 20h
;(same as wifi_shared.h) WSTAT_HW_1C5           equ 21h
;(same as wifi_shared.h) WSTAT_HW_1D0           equ 22h
;(same as wifi_shared.h) WSTAT_HW_1D1           equ 23h
;(same as wifi_shared.h) WSTAT_HW_1D2           equ 24h
;(same as wifi_shared.h) WSTAT_HW_1D3           equ 25h
;(same as wifi_shared.h) WSTAT_HW_1D4           equ 26h
;(same as wifi_shared.h) WSTAT_HW_1D5           equ 27h
;(same as wifi_shared.h) WSTAT_HW_1D6           equ 28h
;(same as wifi_shared.h) WSTAT_HW_1D7           equ 29h
;(same as wifi_shared.h) WSTAT_HW_1D8           equ 2Ah
;(same as wifi_shared.h) WSTAT_HW_1D9           equ 2Bh
;(same as wifi_shared.h) WSTAT_HW_1DA           equ 2Ch
;(same as wifi_shared.h) WSTAT_HW_1DB           equ 2Dh
;(same as wifi_shared.h) WSTAT_HW_1DC           equ 2Eh
;(same as wifi_shared.h) WSTAT_HW_1DD           equ 2Fh
;(same as wifi_shared.h) WSTAT_HW_1DE           equ 30h
;(same as wifi_shared.h) WSTAT_HW_1DF           equ 31h
;(same as wifi_shared.h) ;num stat entries:
;(same as wifi_shared.h) NUM_WIFI_STATS         equ 32h
;(same as wifi_shared.h) ;------------------
;(same as wifi_shared.h) ;user code should NEVER have to use the WIFI_MODE or WIFI_AUTHLEVEL enums...
;(same as wifi_shared.h) ;is here in case I want to have some debug code...
;(same as wifi_shared.h) WIFIMODE_DISABLED            equ 00h
;(same as wifi_shared.h) WIFIMODE_NORMAL              equ 01h
;(same as wifi_shared.h) WIFIMODE_SCAN                equ 02h
;(same as wifi_shared.h) WIFIMODE_ASSOCIATE           equ 03h
;(same as wifi_shared.h) WIFIMODE_ASSOCIATED          equ 04h
;(same as wifi_shared.h) WIFIMODE_DISASSOCIATE        equ 05h
;(same as wifi_shared.h) WIFIMODE_CANNOTASSOCIATE     equ 06h
;(same as wifi_shared.h) ;---
;(same as wifi_shared.h) WIFI_AUTHLEVEL_DISCONNECTED  equ 00h
;(same as wifi_shared.h) WIFI_AUTHLEVEL_AUTHENTICATED equ 01h
;(same as wifi_shared.h) WIFI_AUTHLEVEL_ASSOCIATED    equ 02h
;(same as wifi_shared.h) WIFI_AUTHLEVEL_DEASSOCIATED  equ 03h
;(same as wifi_shared.h) ;------------------
;(same as wifi_arm9.h)   ;user code uses members of the WIFIGETDATA structure in calling arm9_Wifi_GetData
;(same as wifi_arm9.h)   ;to retreive miscellaneous odd information
;(same as wifi_arm9.h)   WIFIGETDATA_MACADDRESS equ 0 ;MACADDRESS: returns data in the buffer, requires at least 6 bytes
;(same as wifi_arm9.h)   WIFIGETDATA_NUMWFCAPS  equ 1 ;NUM WFC APS: returns number between 0 and 3, doesn't use buffer.
;(same as wifi_arm9.h)   MAX_WIFIGETDATA        equ 2
;(same as wifi_shared.h) ;------------------
;(same as wifi_shared.h) WEPMODE_NONE   equ 0    ;\
;(same as wifi_shared.h) WEPMODE_40BIT  equ 1    ; enum's
;(same as wifi_shared.h) WEPMODE_128BIT equ 2    ;/
;(same as wifi_shared.h) ;------------------
;(same as wifi_shared.h) ;ASSOCSTATUS enum's returned by arm9_Wifi_AssocStatus() after calling arm9_Wifi_ConnectAPk
;(same as wifi_shared.h) ;uh, that should be probably "Wifi_ConnectAP" not "Wifi_ConnectAPk" (TYPO: "k")
;(same as wifi_shared.h) ASSOCSTATUS_DISCONNECTED   equ 0 ;not *trying* to connect
;(same as wifi_shared.h) ASSOCSTATUS_SEARCHING      equ 1 ;data given does not completely specify an AP, looking for AP that matches the data.
;(same as wifi_shared.h) ASSOCSTATUS_AUTHENTICATING equ 2 ;connecting...
;(same as wifi_shared.h) ASSOCSTATUS_ASSOCIATING    equ 3 ;connecting...
;(same as wifi_shared.h) ASSOCSTATUS_ACQUIRINGDHCP  equ 4 ;connected to AP, but getting IP data from DHCP
;(same as wifi_shared.h) ASSOCSTATUS_ASSOCIATED     equ 5 ;Connected! (COMPLETE if arm9_Wifi_ConnectAP was called to start)
;(same as wifi_shared.h) ASSOCSTATUS_CANNOTCONNECT  equ 6 ;error in connecting... (COMPLETE if arm9_Wifi_ConnectAP was called to start)
;(same as wifi_shared.h) ;------------------
;(same as wifi_shared.h) ;most user code will never need to know about the WIFI_TXHEADER or WIFI_RXHEADER
;(same as wifi_shared.h) ;struct Wifi_TxHeader:
;(same as wifi_shared.h)  sgTxHdr_enable_flags equ 00h ;2  ;u16 enable_flags
;(same as wifi_shared.h)  sgTxHdr_unknown      equ 02h ;2  ;u16 unknown
;(same as wifi_shared.h)  sgTxHdr_countup      equ 04h ;2  ;u16 countup
;(same as wifi_shared.h)  sgTxHdr_beaconfreq   equ 06h ;2  ;u16 beaconfreq
;(same as wifi_shared.h)  sgTxHdr_tx_rate      equ 08h ;2  ;u16 tx_rate
;(same as wifi_shared.h)  sgTxHdr_tx_length    equ 0Ah ;2  ;u16 tx_length
;(same as wifi_shared.h)  sgTxHdr_size         equ 0Ch ;total
;(same as wifi_shared.h) ;---
;(same as wifi_shared.h) ;struct Wifi_RxHeader
;(same as wifi_shared.h)  sgRxHdr_a            equ 00h ;2  ;u16 a
;(same as wifi_shared.h)  sgRxHdr_b            equ 02h ;2  ;u16 b
;(same as wifi_shared.h)  sgRxHdr_c            equ 04h ;2  ;u16 c
;(same as wifi_shared.h)  sgRxHdr_d            equ 06h ;2  ;u16 d
;(same as wifi_shared.h)  sgRxHdr_byteLength   equ 08h ;2  ;u16 byteLength
;(same as wifi_shared.h)  sgRxHdr_rssi_        equ 0Ah ;2  ;u16 rssi_
;(same as wifi_shared.h)  sgRxHdr_size         equ 0Ch ;total
;(same as wifi_shared.h) ;------------------
;(extra comment)         ;WIFI_ACCESSPOINT is an important structure in that it defines how to connect
;(extra comment)         ;to an access point.
;(extra comment)         ;listed inline are information about the members and their function
;(extra comment)         ;if a field is not necessary for arm9_Wifi_ConnectAP it will be marked as such
;(extra comment)         ;*only* 4 fields are absolutely required to be filled in correctly for the
;(extra comment)         ;connection to work, they are:  ssid, ssid_len, bssid, and channel
;(extra comment)         ;all others can be ignored (though flags should be set to 0)
;(same as wifi_shared.h) ;---
;(same as wifi_shared.h) ;struct Wifi_AccessPoint:
;(                     )  sgWifiAp_ssid       equ 00h ;21h ;char ssid[33]      ;the AP's SSID - zero terminated is not necessary.. if ssid[0] is zero, the ssid will be ignored in trying to find an AP to connect to. [REQUIRED]  ;(0..32 bytes, plus ending zero)
;(                     )  sgWifiAp_ssid_len   equ 21h ;1   ;char ssid_len      ;number of valid bytes in the ssid field (0-32) [REQUIRED]
;(     basically,      )  sgWifiAp_bssid      equ 22h ;6   ;u8   bssid[6]      ;BSSID is the AP's SSID - setting it to all 00's indicates this is not known and it will be ignored [REQUIRED]
;(same as wifi_shared.h)  sgWifiAp_macaddr    equ 28h ;6   ;u8   macaddr[6]    ;mac address of the "AP" is only necessary in ad-hoc mode. [generally not required to connect]
;(        but,         )  sgWifiAp_maxrate    equ 2Eh ;2   ;u16  maxrate       ;max rate is measured in steps of 1/2Mbit - 5.5Mbit will be represented as 11, or 0x0B [not required to connect]
;( with extra comments )  sgWifiAp_timectr    equ 30h ;4   ;u32  timectr       ;internal information about how recently a beacon has been received [not required to connect]
;(                     )  sgWifiAp_rssi       equ 34h ;2   ;u16  rssi          ;running average of the recent RSSI values for this AP, will be set to 0 after not receiving beacons for a while. [not required to connect]
;(                     )  sgWifiAp_flags      equ 36h ;2   ;u16  flags         ;flags indicating various parameters for the AP [not required, but the WFLAG_APDATA_ADHOC flag will be used]
;(                     )  sgWifiAp_spinlock   equ 38h ;4   ;u32  spinlock      ;internal data word used to lock the record to guarantee data coherence [not required to connect]
;(                     )  sgWifiAp_channel    equ 3Ch ;1   ;u8   channel       ;valid channels are 1-13, setting the channel to 0 will indicate the system should search. [REQUIRED]
;(                     )  sgWifiAp_rssi_past  equ 3Dh ;8   ;u8   rssi_past[8]  ;rssi_past indicates the RSSI values for the last 8 beacons received ([7] is the most recent) [not required to connect]
;(                     )  sgWifiAp_base_rates equ 45h ;10h ;u8   base_rates[16];list of the base rates "required" by the AP (same format as maxrate) - zero-terminated list [not required to connect]
;(                     )  sgWifiAp_size       equ 55h ;total
;------------------
;PART2:
;------------------
;typedef void (*WifiPacketHandler)(int, int);
;  Wifi Packet Handler function: (int packetID, int packetlength) - packetID
;  is only valid while the called function is executing.
;  call arm9_Wifi_RxRawReadPacket while in the packet handler function, to
;  retreive the data to a local buffer.
;------------------
;typedef void (*WifiSyncHandler)();
;  Wifi Sync Handler function: Callback function that is called when the arm7
;  needs to be told to synchronize with new fifo data.
;  If this callback is used (see arm9_Wifi_SetSyncHandler()), it should send a
;  message via the fifo to the arm7, which will call arm7_Wifi_Sync() on arm7.
;------------------
;Init/update/state management functions...
;------------------
;extern unsigned long arm9_Wifi_Init(int initflags);
; arm9_Wifi_Init: Initializes the wifi library (arm9 side) and the sgIP library.
;  int initflags: set up some optional things, like controlling the LED blinking
;  Returns: a 32bit value that *must* be passed to arm7
;------------------
;extern int arm9_Wifi_CheckInit();
; arm9_Wifi_CheckInit: Verifies when the ARM7 has been successfully initialized
;  Returns: 1 if the arm7 is ready for wifi, 0 otherwise
;------------------
;extern void arm9_Wifi_DisableWifi();
; arm9_Wifi_DisableWifi: Instructs the ARM7 to disengage wireless and stop
; receiving or transmitting.
;------------------
;extern void arm9_Wifi_EnableWifi();
; arm9_Wifi_EnableWifi: Instructs the ARM7 to go into a basic "active" mode,
; not actually associated to an AP, but actively receiving and potentially
; transmitting
;------------------
;extern void arm9_Wifi_SetPromiscuousMode(int enable);
; arm9_Wifi_SetPromiscuousMode: Allows the DS to enter or leave a "promsicuous"
; mode, in which all data that can be received is forwarded to the arm9 for
; user processing.
; Best used with arm9_Wifi_RawSetPacketHandler, to allow user code to use the
; data (well, the lib won't use 'em, so they're just wasting CPU otherwise.)
;   int enable:  0 to disable promiscuous mode, nonzero to engage
;------------------
;extern void arm9_Wifi_ScanMode();
; arm9_Wifi_ScanMode: Instructs the ARM7 to periodically rotate through the
; channels to pick up and record information from beacons given off by APs
;------------------
;extern void arm9_Wifi_SetChannel(int channel);
; arm9_Wifi_SetChannel: If the wifi system is not connected or connecting to an
; access point, instruct the chipset to change channel
;   int channel: the channel to change to, in the range of 1-13
;------------------
;extern int arm9_Wifi_GetNumAP();
; arm9_Wifi_GetNumAP:
; Returns: the current number of APs that are known about and tracked internally
;------------------
;extern int arm9_Wifi_GetAPData(int apnum, Wifi_AccessPoint * apdata);
; arm9_Wifi_GetAPData: Grabs data from internal structures for user code (always
; succeeds) (... uh, what succeeds how always ??? it CAN return error codes!)
;   int apnum:   the 0-based index of the access point record to fetch
;   Wifi_AccessPoint * apdata:  Pointer to the location where the retrieved
;                               data should be stored
;------------------
;extern int arm9_Wifi_FindMatchingAP(int numaps, Wifi_AccessPoint * apdata, Wifi_AccessPoint * match_dest);
; arm9_Wifi_FindMatchingAP: determines whether various APs exist in the local area.
; You provide a list of APs, and it will return the index of the first one in
; the list that can be found in the internal list of APs that are being tracked
;   int numaps:                    number of records in the list
;   Wifi_AccessPoint * apdata:     pointer to an array of structures with
;                                  information about the APs to find
;   Wifi_AccessPoint * match_dest: OPTIONAL pointer to a record to receive the
;                                  matching AP record.
;   Returns: -1 for none found, or a positive/zero integer index into the array
;            (ASM port returns a POINTER instead of an INDEX) (or -1=none)
;------------------
;extern int arm9_Wifi_ConnectAP(Wifi_AccessPoint * apdata, int wepmode, int wepkeyid, unsigned char * wepkey);
; arm9_Wifi_ConnectAP: Connect to an access point
;  Wifi_AccessPoint * apdata:  basic data on the AP
;  int wepmode:                indicates whether wep is used, and what kind
;  int wepkeyid:               indicates which wep key ID to use for transmitting
;  unsigned char * wepkey:     the wep key, to be used in all 4 key slots (should make this more flexible in the future)
;  Returns:                    0 for ok, -1 for error with input data
;------------------
;extern void arm9_Wifi_AutoConnect();
; arm9_Wifi_AutoConnect: Connect to an access point specified by the WFC data in
; the firmware
;------------------
;extern int arm9_Wifi_AssocStatus();
; arm9_Wifi_AssocStatus: Returns information about the status of connection to an AP
;   Returns: a value from the WIFI_ASSOCSTATUS enum, continue polling until you
;            receive ASSOCSTATUS_CONNECTED or ASSOCSTATUS_CANNOTCONNECT
;------------------
;extern int arm9_Wifi_DisconnectAP();
; arm9_Wifi_DisconnectAP: Disassociate from the Access Point
;------------------
;extern void arm9_Wifi_Timer(int num_ms);
; arm9_Wifi_Timer: This function should be called in a periodic interrupt. It
; serves as the basis for all updating in the sgIP library, all retransmits,
; timeouts, and etc are based on this function being called. It's not timing
; critical but it is rather essential.
;   int num_ms:  The number of milliseconds since the last time this
;                function was called.
;------------------
;extern unsigned long arm9_Wifi_GetIP(); // get local ip
; arm9_Wifi_GetIP: Returns:  The current IP address of the DS (may not be valid
; before connecting to an AP, or setting the IP manually.)
;------------------
;extern struct in_addr arm9_Wifi_GetIPInfo(struct in_addr * pGateway,struct in_addr * pSnmask,struct in_addr * pDns1,struct in_addr * pDns2);
; arm9_Wifi_GetIPInfo: (values may not be valid before connecting to an AP, or
; setting the IP manually.)
;   struct in_addr * pGateway:  pointer to receive the currently configured gateway IP
;   struct in_addr * pSnmask:   pointer to receive the currently configured subnet mask
;   struct in_addr * pDns1:     pointer to receive the currently configured primary DNS server IP
;   struct in_addr * pDns2:     pointer to receive the currently configured secondary DNS server IP
;   Returns:                    The current IP address of the DS
;------------------
;extern void arm9_Wifi_SetIP(unsigned long IPaddr, unsigned long gateway, unsigned long subnetmask, unsigned long dns1, unsigned long dns2);
; arm9_Wifi_SetIP: Set the DS's IP address and other IP configuration information.
;   unsigned long IPaddr:       The new IP address (NOTE! if this value is zero, the IP, the gateway, and the subnet mask will be allocated via DHCP)
;   unsigned long gateway:      The new gateway (example: 192.168.1.1 is 0xC0A80101)
;   unsigned long subnetmask:   The new subnet mask (example: 255.255.255.0 is 0xFFFFFF00)
;   unsigned long dns1:         The new primary dns server (NOTE! if this value is zero AND the IPaddr value is zero, dns1 and dns2 will be allocated via DHCP)
;   unsigned long dns2:         The new secondary dns server
;------------------
;extern int arm9_Wifi_GetData(int datatype, int bufferlen, unsigned char * buffer);
; arm9_Wifi_GetData: Retrieve an arbitrary or misc. piece of data from the wifi
; hardware. see WIFIGETDATA enum.
;   int datatype:               element from the WIFIGETDATA enum specifing what kind of data to get
;   int bufferlen:              length of the buffer to copy data to (not always used)
;   unsigned char * buffer:     buffer to copy element data to (not always used)
;   Returns:                    -1 for failure, the number of bytes written to the buffer, or the value requested if the buffer isn't used.
;------------------
;extern u32 arm9_Wifi_GetStats(int statnum);
; arm9_Wifi_GetStats: Retreive an element of the wifi statistics gathered
;   int statnum:                Element from the WIFI_STATS enum, indicating what statistic to return
;   Returns:                    the requested stat, or 0 for failure
;------------------
;Raw Send/Receive functions
;------------------
;extern int arm9_Wifi_RawTxFrame(unsigned short datalen, unsigned short rate, unsigned short * data);
; arm9_Wifi_RawTxFrame: Send a raw 802.11 frame at a specified rate
;   unsigned short datalen:     The length in bytes of the frame to send
;   unsigned short rate:        The rate to transmit at (Specified as mbits/10, 1mbit=0x000A, 2mbit=0x0014)
;   unsigned short * data:      Pointer to the data to send (should be halfword-aligned)
;   Returns:                    Nothing of interest.
;------------------
;extern void arm9_Wifi_RawSetPacketHandler(WifiPacketHandler wphfunc);
; arm9_Wifi_RawSetPacketHandler: Set a handler to process all raw incoming packets
;   WifiPacketHandler wphfunc:  Pointer to packet handler (see WifiPacketHandler definition for more info)
;------------------
;extern int arm9_Wifi_RxRawReadPacket(long packetID, long readlength, unsigned short * data);
; arm9_Wifi_RxRawReadPacket:  Allows user code to read a packet from within the WifiPacketHandler function
;   long packetID:              a non-unique identifier which locates the packet specified in the internal buffer
;   long readlength:            number of bytes to read (actually reads (number+1)&~1 bytes)
;   unsigned short * data:      location for the data to be read into
;------------------
;Fast transfer support - update functions
;------------------
;extern void arm9_Wifi_Update();
; arm9_Wifi_Update: Checks for new data from the arm7 and initiates routing
; if data is available.
;------------------
;extern void arm9_Wifi_Sync();
; arm9_Wifi_Sync: Call this function when requested to sync by the arm7 side
; of the wifi lib
;------------------
;extern void arm9_Wifi_SetSyncHandler(WifiSyncHandler sh);
; Wifi_SetSyncHandler: Call this function to request notification of when the
; ARM7-side arm7_Wifi_Sync function should be called.
;   WifiSyncHandler sh:    Pointer to the function to be called for notification.
;------------------
WFC_CONNECT    equ 1  ;true   ;<-- USED by USER code, as parameter for "arm9_Wifi_InitDefault"
INIT_ONLY      equ 0  ;false
;------------------
;:----------------- dswifi-src-0.3.17.tar\include\dswifi_version.h
;------------------
;BLAH: none of that version info is used anywhere
;BUGGED: the SGIP_DHCP_CLASSNAME should probably rely on MAJOR/MINOR,
;        but it's actually hardcoded as "sgIP 0.3"
;---
;DSWIFI_MAJOR    equ 0
;DSWIFI_MINOR    equ 3
;DSWIFI_REVISION equ 17
;---
;DSWIFI_VERSION  db "0.3.17",0
;------------------
;:----------------- dswifi-src-0.3.17.tar\include\netdb.h
;------------------
;BLAH: below "hostent" is used ONLY by "gethostbyname"
;BLAH: below "hostent" is SAME as "sgIP_DNS_Hostent"
;struct hostent:
; sgHostent_h_name      equ 00h ;4  ;char *  h_name
; sgHostent_h_aliases   equ 04h ;4  ;char ** h_aliases
; sgHostent_h_addrtype  equ 08h ;4  ;int     h_addrtype
; sgHostent_h_length    equ 0Ch ;4  ;int     h_length
; sgHostent_h_addr_list equ 10h ;4  ;char ** h_addr_list
; sgHostent_size        equ 14h ;total
;------------------
;:----------------- dswifi-src-0.3.17.tar\include\arpa\inet.h
;------------------
;BLAH (empty, 0 bytes)
;------------------
;:----------------- dswifi-src-0.3.17.tar\include\netinet\in.h
;------------------
INADDR_ANY             equ 000000000h
INADDR_BROADCAST       equ 0FFFFFFFFh
INADDR_NONE            equ 0FFFFFFFFh
;------------------
;struct in_addr:                ;\kinda BLAH to have a "struct"
;  unsigned long s_addr;        ;/with only one entry in it
;------------------
;struct sockaddr_in:   ;aka "soin" or "sain"  ;uh, probably "_in" means "InterNet" (not INput)?
 sgSoin_sin_family equ 00h  ;2  ;unsigned short          sin_family
 sgSoin_sin_port   equ 02h  ;2  ;unsigned short          sin_port
 sgSoin_sin_addr   equ 04h  ;4  ;struct   in_addr        sin_addr
 sgSoin_sin_zero   equ 08h  ;8  ;unsigned char           sin_zero[8]
 sgSoin_size       equ 10h  ;total
;------------------
;:----------------- dswifi-src-0.3.17.tar\include\netinet\tcp.h
;------------------
;BLAH (empty, 0 bytes)
;------------------
;:----------------- dswifi-src-0.3.17.tar\include\sys\socket.h
;------------------
;this file is mostly BLAH, except for a few USED definitions:
;  AF_INET
;  SOCK_STREAM and SOCK_DGRAM
;  FIONBIO and FIONREAD
;  MSG_PEEK
;------------------
;BLAH: none of the below "SOL_xxx" values is actually used
;Level number for "getsockopt/setsockopt" to apply to socket itself.
;SOL_SOCKET             equ 0fffh   ;options for socket level
;SOL_TCP                equ 6       ;TCP level
;------------------
;PF_UNSPEC              equ 0
PF_INET                 equ 2
;PF_INET6               equ 10
;---
;AF_UNSPEC              equ PF_UNSPEC    ;\
AF_INET                 equ PF_INET      ; ONLY the "AF_INET" value IS USED
;AF_INET6               equ PF_INET6     ;/      ;<-- aka "10=AF_CCITT" in windows.inc
;------------------
SOCK_STREAM            equ 1
SOCK_DGRAM             equ 2
;------------------
;need to sync FIO* values with commonly accepted ones sometime
FIONBIO                equ 1
FIONREAD               equ 2
;------------------
;BLAH: "SOCKET_ERROR" isn't used anywhere
;SOCKET_ERROR           equ -1
;------------------
;BLAH: mostly unused (aside for MSG_PEEK)
;send()/recv()/etc flags, at present, only MSG_PEEK is implemented though.
;MSG_WAITALL            equ 40000000h
;MSG_TRUNC              equ 20000000h
MSG_PEEK                equ 10000000h
;MSG_OOB                equ 08000000h
;MSG_EOR                equ 04000000h
;MSG_DONTROUTE          equ 02000000h
;MSG_CTRUNC             equ 01000000h
;------------------
;BLAH: none of the below "SHUT_xxx" values is actually used
;shutdown() flags:
;SHUT_RD                equ 1
;SHUT_WR                equ 2
;SHUT_RDWR              equ 3
;------------------
;BLAH: none of the below "SO_xxx" values is actually used
;(maybe related to the "setsockopt" and "getsockopt" dummy functions?)
;---
;Option flags per-socket.
;SO_DEBUG       equ 0001h   ;turn on debugging info recording
;SO_ACCEPTCONN  equ 0002h   ;socket has had listen()
;SO_REUSEADDR   equ 0004h   ;allow local address reuse
;SO_KEEPALIVE   equ 0008h   ;keep connections alive
;SO_DONTROUTE   equ 0010h   ;just use interface addresses
;SO_BROADCAST   equ 0020h   ;permit sending of broadcast msgs
;SO_USELOOPBACK equ 0040h   ;bypass hardware when possible
;SO_LINGER      equ 0080h   ;linger on close if data present
;SO_OOBINLINE   equ 0100h   ;leave received OOB data in line
;SO_REUSEPORT   equ 0200h   ;allow local address & port reuse
;---
;SO_DONTLINGER  equ NOT SO_LINGER
;---
;Additional options, not kept in so_options.
;SO_SNDBUF       equ 1001h   ;send buffer size
;SO_RCVBUF       equ 1002h   ;receive buffer size
;SO_SNDLOWAT     equ 1003h   ;send low-water mark
;SO_RCVLOWAT     equ 1004h   ;receive low-water mark
;SO_SNDTIMEO     equ 1005h   ;send timeout
;SO_RCVTIMEO     equ 1006h   ;receive timeout
;SO_ERROR        equ 1007h   ;get error status and clear
;SO_TYPE         equ 1008h   ;get socket type
;------------------
;BLAH: below "sockaddr" is duplicate of "sockaddr_in"
;      (but less detailed on the "data" field)
;struct sockaddr:
; sgSockaddr_sa_family equ 00h ;2    ;unsigned short sa_family
; sgSockaddr_sa_data   equ 02h ;14   ;char           sa_data[14]
; sgSockaddr_size      equ 10h ;total
;------------------
;BLAH: below is just a list of supported functions (though possibly useful)
;  extern int socket(int domain, int type, int protocol);
;  extern int bind(int socket, const struct sockaddr * addr, int addr_len);
;  extern int connect(int socket, const struct sockaddr * addr, int addr_len);
;  extern int send(int socket, const void * data, int sendlength, int flags);
;  extern int recv(int socket, void * data, int recvlength, int flags);
;  extern int sendto(int socket, const void * data, int sendlength, int flags, const struct sockaddr * addr, int addr_len);
;  extern int recvfrom(int socket, void * data, int recvlength, int flags, struct sockaddr * addr, int * addr_len);
;  extern int listen(int socket, int max_connections);
;  extern int accept(int socket, struct sockaddr * addr, int * addr_len);
;  extern int shutdown(int socket, int shutdown_type);
;  extern int closesocket(int socket);
;  extern int ioctl(int socket, long cmd, void * arg);
;  extern int setsockopt(int socket, int level, int option_name, const void * data, int data_len);
;  extern int getsockopt(int socket, int level, int option_name, void * data, int * data_len);
;  extern int getpeername(int socket, struct sockaddr *addr, int * addr_len);
;  extern int getsockname(int socket, struct sockaddr *addr, int * addr_len);
;  extern int gethostname(char *name, size_t len);
;  extern int sethostname(const char *name, size_t len);
;  unsigned short htons(unsigned short num);
;  unsigned long htonl(unsigned long num);
;  extern int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout);
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_Config.h
;------------------
;#define __LINUX_ERRNO_EXTENSIONS__
;#include <errno.h>
;------------------
;General options - these control the core functionality of the stack...
;------------------
SGIP_USEDYNAMICMEMORY   equ 1
  ;SGIP_USEDYNAMICMEMORY: Allows the stack to use memory as it needs it, via
  ;malloc()/free()
  ;This option is extremely useful in environments where it can be used, as it
  ;prevents the overhead of allocating per-connection memory in advance, and
  ;allows an unlimited number of connections, provided the memory space.
  ;This option requires the implementation of two C functions,
  ;  "void * sgIP_malloc(int)" and "void sgIP_free(void *)",
  ;which behave similarly to the malloc and free functions commonly used in C.
;------------------
SGIP_INTERRUPT_THREADING_MODEL  equ 1
  ;SGIP_INTERRUPT_THREADING_MODEL: Provides memory protection in a system that
  ;can allow multiple processing "threads" by way of interrupts. This is not
  ;required on single threaded systems, and not adequate on multithreaded
  ;systems, but provides a way to allow protection against contention on
  ;interrupt-driven systems. This option requires the system to implement two C
  ;functions
  ;  "int sgIP_DisableInterrupts()" and "void sgIP_RestoreInterrupts(int)"
  ;that takes as a parameter the value returned by sgIP_DisableInterrupts().
  ;Interrupts are disabled upon beginning work with sensitive memory areas or
  ;allocation/deallocation of memory, and are restored afterwards.
;------------------
;UNDEFINE SGIP_MULTITHREADED_THREADING_MODEL
  ;SGIP_MULTITHREADED_THREADING_MODEL: Standard memory protection for large
  ;multithreaded systems, such as operating systems and the like. This kind of
  ;memory protection is useful for true multithreaded systems but useless in a
  ;single-threaded system and harmful in an interrupt-based multiprocess system.
;------------------
SGIP_LITTLEENDIAN               equ 1
;------------------
;Temporary memory system settings...
;------------------
SGIP_MEMBLOCK_DATASIZE          equ 1600
  ;SGIP_MEMBLOCK_DATASIZE: This is the maximum data size contained in a single
  ;sgIP_memblock. For best performance ensure this value is larger than any
  ;packet that is expected to be received, however, in a memory-tight situation,
  ;much smaller values can be used.
;------------------
SGIP_MEMBLOCK_BASENUM           equ 12
  ;SGIP_MEMBLOCK_BASENUM: The starting number of memblocks that will be
  ;allocated. This is also the total number of memblocks that will be
  ;allocated if sgIP is not configured to use dynamic memory allocation.
;------------------
SGIP_MEMBLOCK_STEPNUM           equ 6
  ;SGIP_MEMBLOCK_STEPNUM: In the case that all memblocks are full, and dynamic
  ;memory is enabled, this many additional memblocks will be allocated in an
  ;attempt to satasfy the memory usage demands of the stack.
;------------------
SGIP_MEMBLOCK_DYNAMIC_MALLOC_ALL equ 1
  ;SGIP_MEMBLOCK_DYNAMIC_MALLOC_ALL: Who cares what the other memblock defines
  ;say, let's Generate all memblocks by mallocing 'em.
;------------------
;Hardware layer settings...
;------------------
SGIP_MAXHWADDRLEN               equ 8
  ;SGIP_MAXHWADDRLEN: The maximum usable hardware address length.
  ;Ethernet is 6 bytes.
;------------------
SGIP_MAXHWHEADER                equ 16
  ;SGIP_MAXHWHEADER: The maximum allocated size for hardware headers.
;------------------
SGIP_MTU_OVERRIDE               equ 1460
  ;SGIP_MTU_OVERRIDE: This is the maximum MTU that will be accepted. By
  ;default it is being set to 1460 bytes in order to be courteous to Ethernet
  ;and it's ridiculously low MTU.
  ;This value will allow you to prevent fragmentation of IP packets by not
  ;using the full MTU available to your network interface when the IP packet
  ;will just be sliced and diced at the next smaller MTU. (the stack will
  ;still use HW mtu if it's lower.)
;------------------
;Connection settings - can be tuned to change memory usage and performance...
;------------------
SGIP_TCP_STATELESS_LISTEN       equ 1
  ;SGIP_TCP_STATELESS_LISTEN: Uses a technique to prevent syn-flooding from
  ;blocking listen ports by using all the connection blocks/memory.
;------------------
;UNDEFINE SGIP_TCP_STEALTH
  ;SGIP_TCP_STEALTH: Only sends packets in response to connections to active
  ;ports. Doing so causes ports to appear not as closed, but as if the deviced
  ;does not exist when probing ports that are not in use.
;------------------
SGIP_IP_TTL                     equ 128
  ;SGIP_TCP_TTL: Time-to-live value given to outgoing packets, in the absence
  ;of a reason to manually override this value.
  ;uh, why does the comment refer to "TCP_TTL" when the constant is "IP_TTL"?
;------------------
SGIP_TCP_RECEIVEBUFFERLENGTH    equ 8192
  ;SGIP_TCPRECEIVEBUFFERLENGTH: The size (in bytes) of the receive FIFO
  ;in a TCP connection
;------------------
SGIP_TCP_TRANSMITBUFFERLENGTH   equ 8192
  ;SGIP_TCPTRANSMITBUFFERLENGTH: The size (in bytes) of the transmit FIFO
  ;in a TCP connection
;------------------
SGIP_TCP_OOBBUFFERLENGTH        equ 256
  ;BLAH: that "buf_oob" stuff isn't actually used/implemented
  ;SGIP_TCPOOBBUFFERLENGTH: The size (in bytes) of the receive OOB data FIFO
  ;in a TCP connection
;------------------
SGIP_ARP_MAXENTRIES             equ 32
  ;SGIP_ARP_MAXENTRIES: The maximum number of cached ARP entries - this is
  ;defined staticly because it's somewhat impractical to dynamicly allocate
  ;memory for such a small structure (at least on most smaller systems)
;------------------
SGIP_HUB_MAXHWINTERFACES        equ 1
  ;SGIP_HUB_MAXHWINTERFACES: The maximum number of hardware interfaces the
  ;sgIP hub will connect to. A hardware interface being some port (ethernet,
  ;wifi, etc) that will relay packets to the outside world.
;------------------
SGIP_HUB_MAXPROTOCOLINTERFACES  equ 1
  ;SGIP_HUB_MAXPROTOCOLINTERFACES: The maximum number of protocol interfaces
  ;the sgIP hub will connect to. A protocol interface being a software handler
  ;for a certain protocol type (such as IP)
;------------------
;BUGGED: original code uses 40000-65000, but official numbering seems to be:
;  0-1023       = System Ports (assigned by IANA)
;  1024-49151   = User Ports (assigned by IANA)
;  49152-65535  = Dynamic Ports (free)
;so one should probably better use 49152-65535 instead of 40000-65000 here.
;- - -
SGIP_TCP_FIRSTOUTGOINGPORT      equ 49152 ;original: 40000
SGIP_TCP_LASTOUTGOINGPORT       equ 65535 ;original: 65000  ;<-- up to INCLUDING this last value (?) (!!)
SGIP_UDP_FIRSTOUTGOINGPORT      equ 49152 ;original: 40000
SGIP_UDP_LASTOUTGOINGPORT       equ 65535 ;original: 65000  ;<-- up to INCLUDING this last value (?) (!!)
SGIP_TCP_NUMPORTS equ SGIP_TCP_LASTOUTGOINGPORT+1-SGIP_TCP_FIRSTOUTGOINGPORT
SGIP_UDP_NUMPORTS equ SGIP_UDP_LASTOUTGOINGPORT+1-SGIP_UDP_FIRSTOUTGOINGPORT
;------------------
SGIP_TCP_GENTIMEOUTMS           equ 6000        ;BLAH/UNUSED
SGIP_TCP_TRANSMIT_DELAY         equ 25
SGIP_TCP_TRANSMIT_IMMTHRESH     equ 40
SGIP_TCP_TIMEMS_2MSL            equ 1000*128    ;uh, what is a "MSL"? seems to mean "minutes"! (the value is counted in milliseconds (via "sgIP_timems"), so 1000*60*2 would mean 120 seconds aka "2 minutes") (in ASM code: use 128 seconds instead)
SGIP_TCP_MAXRETRY               equ 7
SGIP_TCP_MAXSYNS                equ 64
SGIP_TCP_REACK_THRESH           equ 1000
;---
SGIP_TCP_SYNRETRYMS             equ 250
SGIP_TCP_GENRETRYMS             equ 500
SGIP_TCP_BACKOFFMAX             equ 1024*6      ;original: 6000
;------------------
SGIP_SOCKET_MAXSOCKETS          equ 32   ;uh, caution: this must be same (or less) than "FD_SETSIZE"
;------------------
;disabled/outcommented option:
;UNDEFINE SGIP_SOCKET_DEFAULT_NONBLOCK   equ 1
;------------------
;DNS settings...
;------------------
SGIP_DNS_MAXRECORDSCACHE        equ 16
SGIP_DNS_MAXRECORDADDRS         equ 4
SGIP_DNS_MAXALIASES             equ 4
SGIP_DNS_TIMEOUTMS              equ 1024*5      ;original: 5000
SGIP_DNS_MAXRETRY               equ 3
SGIP_DNS_MAXSERVERRETRY         equ 4
;------------------
SGIP_DHCP_ERRORTIMEOUT          equ 1024*45     ;original: 45000
SGIP_DHCP_RESENDTIMEOUT         equ 1024*3  ;*1   ;;512 ;;;XNAY 1024*3      ;original: 3000 (uh, that would 3 seconds before retry, looks a bit too long)   ;XXX small value like "100" can overload fritzbox (causing to refuse wifi at all, even when resuming to use larger timeout values?!)
;------------------
SGIP_DHCP_DEFAULTHOSTNAME       db  "NintendoDS",0      ;\
SGIP_DHCP_CLASSNAME             db  "sgIP 0.3",0        ; XXX data
.align 4                                                ;/
;------------------
;Static memory settings - only used if SGIP_USEDYNAMICMEMORY is NOT defined.
;BLAH: actually, below "SGIP_TCP_MAXCONNECTIONS" is NEVER used
;---
;SGIP_TCP_MAXCONNECTIONS         equ 10
;  ;SGIP_TCP_MAXCONNECTIONS: In the case dynamic memory is not used, this
;  ;value gives the max number of TCP blocks available for inbound/outbound
;  ;connections via TCP.
;------------------
;Debugging options...
;------------------
;UNDEFINE SGIP_DEBUG
  ;SGIP_DEBUG: Enable debug logging.
  ;requires external function "void sgIP_dbgprint(char *, ...);"
;---
.ifdef SGIP_DEBUG
 ;SGIP_DEBUG_MESSAGE(param) equ sgIP_dbgprint param
 ;SGIP_DEBUG_ERROR(param)   equ sgIP_dbgprint param, while(1)  ;UNUSED
.else
 ;SGIP_DEBUG_MESSAGE(param) equ N/A
 ;SGIP_DEBUG_ERROR(param)   equ N/A                            ;UNUSED
.endif
;------------------
;Error handling
;#define SGIP_ERROR(a)  === ((errno=(a)), -1)
;#define SGIP_ERROR0(a) === ((errno=(a)), 0)
;------------------
;Error checking
.ifdef SGIP_MULTITHREADED_THREADING_MODEL
 .ifdef SGIP_INTERRUPT_THREADING_MODEL
  .error ;SGIP_INTERRUPT_THREADING_MODEL and SGIP_MULTITHREADED_THREADING_MODEL cannot be used together!
 .endif
.endif
;------------------
.ifdef SGIP_INTERRUPT_THREADING_MODEL
  sgIP_IntrProtect    equ enterCriticalSection    ;out: r0=old
  sgIP_IntrReprotect  equ enterCriticalSection    ;out: r0=old
  sgIP_IntrUnprotect  equ leaveCriticalSection    ;in: r0=old
  sgIP_WaitEvent      equ arm9_sgIP_IntrWaitEvent ;in/out: none
.else
  sgIP_IntrProtect:   bx lr
  sgIP_IntrReprotect: bx lr
  sgIP_IntrUnprotect: bx lr
  sgIP_WaitEvent:     bx lr
.endif
;------------------
;External option-based dependencies
;#include <nds/interrupts.h>
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP.h
;------------------
;(only blah)
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_ARP.h
;------------------
SGIP_ARP_FLAG_ACTIVE        equ 0001h
SGIP_ARP_FLAG_HAVEHWADDR    equ 0002h
SGIP_HEADER_ARP_BASESIZE    equ 8
;------------------
;struct sgIP_ARP_Record:
 sgArpRec_flags             equ 00h ;2  ;unsigned short         flags
 sgArpRec_retrycount        equ 02h ;2  ;unsigned short         retrycount
 sgArpRec_idletime          equ 04h ;4  ;unsigned long          idletime
 sgArpRec_linked_interface  equ 08h ;4  ;sgIP_Hub_HWInterface * linked_interface
 sgArpRec_queued_packet     equ 0ch ;4  ;MemBlk                 queued_packet
 sgArpRec_linked_protocol   equ 10h ;4  ;int                    linked_protocol
 sgArpRec_protocol_address  equ 14h ;4  ;unsigned long          protocol_address
 sgArpRec_hw_address        equ 18h ;NN ;char                   hw_address[SGIP_MAXHWADDRLEN]
 sgArpRec_size              equ 18h+SGIP_MAXHWADDRLEN  ;total
;------------------
;struct sgIP_Header_ARP:
 sgArpHdr_hwspace           equ 00h ;2  ;unsigned short hwspace          // ethernet=1
 sgArpHdr_protocol          equ 02h ;2  ;unsigned short protocol
 sgArpHdr_hw_addr_len       equ 04h ;1  ;unsigned char  hw_addr_len
 sgArpHdr_protocol_addr_len equ 05h ;1  ;unsigned char  protocol_addr_len
 sgArpHdr_opcode            equ 06h ;2  ;unsigned short opcode           // request=1, reply=2
 sgArpHdr_addresses         equ 08h ;20 ;unsigned char  addresses[8+12]  // sender HW, sender Protocol, dest HW, dest Protocol
with_arp_padding         equ 0;1  ;1/2019
with_arp_grat_request    equ 01  ;1/2019
.if with_arp_padding
 sgArpHdr_padding           equ 1Ch ;18
 sgArpHdr_size              equ 2Eh ;total
.else
 sgArpHdr_size              equ 1Ch ;total (28 bytes, aka 14 halfwords)
.endif
;XXX with_arp_padding: network may append 12h bytes padding to above 1Ch bytes
;    (somewhat ethernet minimum packet size 46 bytes)
;    (should be NOT required for Wifi-packets, but the network may
;    automatically append zeroes/garbage as padding when forwarding the packets, which shouldn't disturb though, even if garbage is used as padding)
;---
;46 bytes is the minimum amount of user data permitted in an Ethernet packet.
;There's an 8 byte preamble, a 6 byte destination MAC, a 6 byte source MAC, a 2 byte type/length, user data, and a 4 byte frame check sequence. Since the minimum packet is 64 bytes, that means the user data cannot be fewer than 46 bytes.
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_DHCP.h
;------------------
DHCP_BOOTP_SERVER equ 4300h ;aka htons(67)  ;"DHCP Server" port
DHCP_BOOTP_CLIENT equ 4400h ;aka htons(68)  ;"DHCP Client" port
;------------------
;DHCP messages broadcast by a client prior to that client obtaining its IP
;address must have the source address field in the IP header set to 0.
;------------------
;struct sgIP_DHCP_Packet:      ;yes, freaking big endian prevails here too
 sgDhcpPkt_op        equ 00h  ;1    ;unsigned char  op           ;opcode/message type (1=BOOTREQUEST, 2=BOOTREPLY)
 sgDhcpPkt_htype     equ 01h  ;1    ;unsigned char  htype        ;hardware address type
 sgDhcpPkt_hlen      equ 02h  ;1    ;unsigned char  hlen         ;Hardware address length (should be 6, for ethernet/wifi)
 sgDhcpPkt_hops      equ 03h  ;1    ;unsigned char  hops         ;set to 0
 sgDhcpPkt_xid       equ 04h  ;4    ;unsigned long  xid          ;4-byte client specified transaction ID
 sgDhcpPkt_secs      equ 08h  ;2    ;unsigned short secs         ;seconds elapsed since client started trying to boot
 sgDhcpPkt_flags     equ 0Ah  ;2    ;unsigned short flags        ;flags
 sgDhcpPkt_ciaddr    equ 0Ch  ;4    ;unsigned long  ciaddr       ;client IP address, filled in by client if verifying previous params
 sgDhcpPkt_yiaddr    equ 10h  ;4    ;unsigned long  yiaddr       ;"your" (client) IP address
 sgDhcpPkt_siaddr    equ 14h  ;4    ;unsigned long  siaddr       ;IP addr of next server to use in bootstrap.
 sgDhcpPkt_giaddr    equ 18h  ;4    ;unsigned long  giaddr       ;Relay agent IP address
 sgDhcpPkt_chaddr    equ 1Ch  ;10h  ;unsigned char  chaddr[16]   ;client hardware address
 sgDhcpPkt_sname     equ 2Ch  ;40h  ;char           sname[64]    ;optional server hostname (null terminated string)
 sgDhcpPkt_file      equ 6Ch  ;80h  ;char           file[128]    ;boot file name, null terminated string
 sgDhcpPkt_options   equ 0ECh ;138h ;char           options[312] ;optional parameters
 sgDhcpPkt_size      equ 224h ;total (224h aka 548 decimal)
;------------------
SGIP_DHCP_STATUS_IDLE          equ 0             ;\
SGIP_DHCP_STATUS_WORKING       equ 1 ;aka "busy" ; enum's
SGIP_DHCP_STATUS_FAILED        equ 2             ;
SGIP_DHCP_STATUS_SUCCESS       equ 3 ;aka "done" ;/
;------------------
DHCP_TYPE_DISCOVER             equ 1    ;\
DHCP_TYPE_OFFER                equ 2    ;
DHCP_TYPE_REQUEST              equ 3    ;
DHCP_TYPE_ACK                  equ 5    ;
DHCP_TYPE_RELEASE              equ 7    ;/
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_DNS.h
;------------------
.if with_dns
;------------------
SGIP_DNS_FLAG_ACTIVE    equ 1
SGIP_DNS_FLAG_RESOLVED  equ 2
SGIP_DNS_FLAG_BUSY      equ 4
;------------------
;struct sgIP_DNS_Record
 @@a equ SGIP_DNS_MAXALIASES*256
 @@b equ SGIP_DNS_MAXRECORDADDRS*4
 ;note: original code has the three "big" arrays at the BEGIN of the sgDnsRec
 ;structure; that looks nice, but it works badly on ARM processors (which can't
 ;deal well with large structure indices for halfwords, so it's better to move
 ;that stuff to the begin of structure, and to added the "reserved" padding).
 sgDnsRec_addrlen   equ 000h         ;2    ;short             addrlen
 sgDnsRec_addrclass equ 002h         ;2    ;short             addrclass
 sgDnsRec_numaddr   equ 004h         ;4    ;int               numaddr
 sgDnsRec_numalias  equ 008h         ;4    ;int               numalias
 sgDnsRec_TTL       equ 00Ch         ;4    ;int               TTL (time-to-live)
 sgDnsRec_flags     equ 010h         ;4    ;int               flags
 sgDnsRec_reserved  equ 014h         ;12   ;padding (added for better shifted 8bit ARM indices)
 sgDnsRec_name      equ 020h         ;100h ;char              name[256]
 sgDnsRec_aliases   equ 120h         ;@@x  ;char              aliases[SGIP_DNS_MAXALIASES][256]
 sgDnsRec_addrdata  equ 120h+@@a     ;@@y  ;unsigned char     addrdata[SGIP_DNS_MAXRECORDADDRS*4]
 sgDnsRec_size      equ 120h+@@a+@@b ;total
;------------------
;struct sgIP_DNS_Hostent:
 sgDnsHst_h_name      equ 00h  ;4  ;ptr to name
 sgDnsHst_h_aliases   equ 04h  ;4  ;ptr to alias_list (which contains ptr's to alias names)
 sgDnsHst_h_addrtype  equ 08h  ;4  ;class (1=IN=internet?... uh, or rather or 2=AF_INET?)
 sgDnsHst_h_length    equ 0Ch  ;4  ;addr length (should be 4, for 4-byte IP addresses)
 sgDnsHst_h_addr_list equ 10h  ;4  ;ptr to addr_list (which contains ptr's to IP addresses)
 sgDnsHst_size        equ 14h  ;total
;------------------
.endif ;with_dns
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_Hub.h
;------------------
SGIP_FLAG_PROTOCOL_IN_USE               equ 0001h
SGIP_FLAG_PROTOCOL_ENABLED              equ 8000h
;------------------
SGIP_FLAG_HWINTERFACE_IN_USE            equ 0001h
SGIP_FLAG_HWINTERFACE_CONNECTED         equ 0002h
SGIP_FLAG_HWINTERFACE_USEDHCP           equ 0004h
SGIP_FLAG_HWINTERFACE_CHANGENETWORK     equ 0008h
SGIP_FLAG_HWINTERFACE_ENABLED           equ 8000h
;------------------
.ifdef SGIP_LITTLEENDIAN
 PROTOCOL_ETHER_ARP                     equ 0608h  ;=htons(0806h)
 PROTOCOL_ETHER_IP                      equ 0008h  ;=htons(0800h)
 .if with_dsi_wifi
   PROTOCOL_ETHER_EAPOL                 equ 8e88h  ;=htons(888Eh)
 .endif
 HWSPACE_ETHERNET                       equ 0100h  ;=htons(0001h)
 ARP_OPCODE_REQUEST                     equ 0100h  ;=htons(0001h)
 ARP_OPCODE_RESPONSE                    equ 0200h  ;=htons(0002h)
 DNS_PORT                               equ 3500h  ;=htons(53)
.else
 PROTOCOL_ETHER_ARP                     equ 0806h
 PROTOCOL_ETHER_IP                      equ 0800h
 .if with_dsi_wifi
   PROTOCOL_ETHER_EAPOL                 equ 888eh
 .endif
 HWSPACE_ETHERNET                       equ 0001h
 ARP_OPCODE_REQUEST                     equ 0001h
 ARP_OPCODE_RESPONSE                    equ 0002h
.endif
;------------------
;struct sgIP_Hub_Protocol:
 ;Used to record the interface between the sgIP Hub and a protocol handler
 sgHubPrt_flags            equ 00h ;2   ;unsigned short flags
 sgHubPrt_protocol         equ 02h ;2   ;unsigned short protocol
 sgHubPrt_ReceivePacket    equ 04h ;4   ;int (*ReceivePacket)(sgIP_memblock *)
 sgHubPrt_size             equ 08h ;total
;------------------
;struct sgIP_Hub_HWInterface:
 sgHubHwi_flags            equ 00h ;2   ;unsigned short flags
 sgHubHwi_hwaddrlen        equ 02h ;2   ;unsigned short hwaddrlen
 sgHubHwi_MTU              equ 04h ;4   ;int            MTU
 sgHubHwi_TransmitFunction equ 08h ;4   ;int (*TransmitFunction)(struct SGIP_HUB_HWINTERFACE *, sgIP_memblock *);
 sgHubHwi_userdata         equ 0Ch ;4   ;void *         userdata
 sgHubHwi_ipaddr           equ 10h ;4   ;unsigned long  ipaddr
 sgHubHwi_gateway          equ 14h ;4   ;unsigned long  gateway
 sgHubHwi_snmask           equ 18h ;4   ;unsigned long  snmask
 sgHubHwi_dns              equ 1Ch ;12  ;unsigned long  dns[3]
 sgHubHwi_hwaddr           equ 28h ;..  ;unsigned char  hwaddr[SGIP_MAXHWADDRLEN]
 sgHubHwi_size             equ 28h+SGIP_MAXHWADDRLEN ;total
;------------------
;struct sgIP_Header_Ethernet:
 sgEthHdr_dest_mac equ 00h ;6  ;unsigned char  dest_mac[6]
 sgEthHdr_src_mac  equ 06h ;6  ;unsigned char  src_mac[6]
 sgEthHdr_protocol equ 0Ch ;2  ;unsigned short protocol
 sgEthHdr_size     equ 0Eh ;total
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_ICMP.h
;------------------
;struct sgIP_Header_ICMP:
 sgIcmpHdr_type     equ 00h ;1  ;type
 sgIcmpHdr_code     equ 01h ;1  ;code
 sgIcmpHdr_checksum equ 02h ;2  ;checksum
 sgIcmpHdr_xtra     equ 04h ;4  ;xtra
 sgIcmpHdr_size     equ 08h ;total
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_IP.h
;------------------
PROTOCOL_IP_ICMP     equ 1
PROTOCOL_IP_TCP      equ 6
PROTOCOL_IP_UDP      equ 17
;------------------
;struct sgIP_Header_IP:
 sgIpHdr_version_ihl     equ 00h ;1   ;version = top 4 bits == 4, IHL = header length in 32bit increments = bottom 4 bits
 sgIpHdr_type_of_service equ 01h ;1   ;[3bit prescidence][ D ][ T ][ R ][ 0 0 ] - D=low delya, T=high thoroughput, R=high reliability
 sgIpHdr_tot_length      equ 02h ;2   ;total length of packet including header
 sgIpHdr_identification  equ 04h ;2   ;value assigned by sender to aid in packet reassembly
 sgIpHdr_fragment_offset equ 06h ;2   ;top 3 bits are flags [0][DF][MF] (Don't Fragment / More Fragments Exist) - offset is in 8-byte chunks.
 sgIpHdr_TTL             equ 08h ;1   ;time to live, measured in hops
 sgIpHdr_protocol        equ 09h ;1   ;protocols: ICMP=1, TCP=6, UDP=17 (PROTOCOL_IP_xx)
 sgIpHdr_header_checksum equ 0Ah ;2   ;checksum:
 sgIpHdr_src_address     equ 0Ch ;4   ;src address is 32bit IP address
 sgIpHdr_dest_address    equ 10h ;4   ;dest address is 32bit IP address
 sgIpHdr_options         equ 14h ;0/4 ;optional options come here. ;options[4]  ;<-- OPTIONAL the length in "IHL" is usually 5 words (=20 bytes, aka 14h bytes)
;sgIpHdr_size            equ 14h ;total  ;usually 20 (14h), or could be more if "options" are present
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_memblock.h
;------------------
;struct sgIP_memblock:
 sgMemBlk_totallength equ 00h ;4   ;int totallength;
 sgMemBlk_thislength  equ 04h ;4   ;int thislength;
 sgMemBlk_next        equ 08h ;4   ;struct SGIP_MEMBLOCK * next;
 sgMemBlk_datastart   equ 0Ch ;4   ;char * datastart;
 sgMemBlk_reserved    equ 10h ;..  ;char reserved[SGIP_MEMBLOCK_DATASIZE-16]; // assume the other 4 values are 16 bytes total in length.
 sgMemBlk_size        equ SGIP_MEMBLOCK_DATASIZE  ;total size
;---
SGIP_MEMBLOCK_HEADERSIZE        equ 16
SGIP_MEMBLOCK_INTERNALSIZE      equ (SGIP_MEMBLOCK_DATASIZE-16)
SGIP_MEMBLOCK_FIRSTINTERNALSIZE equ (SGIP_MEMBLOCK_DATASIZE-16-SGIP_MAXHWHEADER)
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_sockets.h
;------------------
SGIP_SOCKET_FLAG_ALLOCATED             equ 8000h
SGIP_SOCKET_FLAG_NONBLOCKING           equ 4000h
SGIP_SOCKET_FLAG_VALID                 equ 2000h
SGIP_SOCKET_FLAG_CLOSING               equ 1000h
SGIP_SOCKET_FLAG_TYPEMASK              equ 0001h
SGIP_SOCKET_FLAG_TYPE_TCP              equ 0001h
SGIP_SOCKET_FLAG_TYPE_UDP              equ 0000h
SGIP_SOCKET_MASK_CLOSE_COUNT           equ 0FFFF0000h
SGIP_SOCKET_SHIFT_CLOSE_COUNT          equ 16
;------------------
;Maybe define a better value for this in the future. But 5 minutes sounds ok.
;TCP specification disagrees on this point, but this is a limited platform.
;5 minutes assuming 1000ms ticks = 300 = 12Ch
SGIP_SOCKET_VALUE_CLOSE_COUNT   equ  (12Ch shl SGIP_SOCKET_SHIFT_CLOSE_COUNT)
;------------------
;struct sgIP_socket_data:
 sgSockDta_flags    equ 00h ;4  ;unsigned int flags
 sgSockDta_conn_ptr equ 04h ;4  ;void *       conn_ptr
 sgSockDta_size     equ 08h ;total
;------------------
;sys/time.h (actually intersects partly with libnds,
;so I'm letting libnds handle fd_set for the time being)
;...uh, handle what/where...?
;extern int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout);
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_TCP.h
;------------------
.if with_tcp
;------------------
SGIP_TCP_STATE_NODATA       equ 0  ;newly allocated                 ;\
SGIP_TCP_STATE_UNUSED       equ 1  ;allocated & BINDed              ;
SGIP_TCP_STATE_LISTEN       equ 2  ;listening                       ; enum's
SGIP_TCP_STATE_SYN_SENT     equ 3  ;connect initiated               ;
SGIP_TCP_STATE_SYN_RECEIVED equ 4  ;spawned from listen socket      ;
SGIP_TCP_STATE_ESTABLISHED  equ 5  ;syns have been exchanged        ;
SGIP_TCP_STATE_FIN_WAIT_1   equ 6  ;sent a FIN, haven't got FIN or ACK yet
SGIP_TCP_STATE_FIN_WAIT_2   equ 7  ;got ACK for our FIN, haven't got FIN yet
SGIP_TCP_STATE_CLOSE_WAIT   equ 8  ;got FIN, wait for user code to close socket & send FIN
SGIP_TCP_STATE_CLOSING      equ 9  ;got FIN, waiting for ACK of our FIN
SGIP_TCP_STATE_LAST_ACK     equ 10 ;wait for ACK of our last FIN
SGIP_TCP_STATE_TIME_WAIT    equ 11 ;wait to ensure remote tcp knows it's been terminated
SGIP_TCP_STATE_CLOSED       equ 12 ;Block is unused                 ;/
;------------------
SGIP_TCP_FLAG_FIN           equ 1
SGIP_TCP_FLAG_SYN           equ 2
SGIP_TCP_FLAG_RST           equ 4
SGIP_TCP_FLAG_PSH           equ 8
SGIP_TCP_FLAG_ACK           equ 16
SGIP_TCP_FLAG_URG           equ 32
;------------------
;struct sgIP_Header_TCP:
 sgTcpHdr_srcport  equ 00h ;2  ;unsigned short srcport
 sgTcpHdr_destport equ 02h ;2  ;unsigned short destport
 sgTcpHdr_seqnum   equ 04h ;4  ;unsigned long  seqnum
 sgTcpHdr_acknum   equ 08h ;4  ;unsigned long  acknum
 sgTcpHdr_dataofs_ equ 0Ch ;1  ;unsigned char  dataofs_
 sgTcpHdr_tcpflags equ 0Dh ;1  ;unsigned char  tcpflags
 sgTcpHdr_window   equ 0Eh ;2  ;unsigned short window
 sgTcpHdr_checksum equ 10h ;2  ;unsigned short checksum
 sgTcpHdr_urg_ptr  equ 12h ;2  ;unsigned short urg_ptr
 sgTcpHdr_options  equ 14h ;4  ;unsigned char  options[4]  ;uh, UNUSED... or unimplemented... is this a a CUSTOM/INTERNAL structure... or is it some standarized PACKET HEADER that is actually transmitted in that form?
 sgTcpHdr_size     equ 18h ;total   ;uh, several functions use "20" decimal, which does (at least in some cases) seem to be the "sgTcpHdr_size"... but "20" would mean 14h, not 18h !?! uh, but, the actual header size SHOULD depend on "dataofs_"?
;------------------
;struct sgIP_Record_TCP:  ;a TCP record, to store data for an active TCP connection
 @@x equ SGIP_TCP_RECEIVEBUFFERLENGTH
 @@y equ SGIP_TCP_TRANSMITBUFFERLENGTH
 @@z equ SGIP_TCP_OOBBUFFERLENGTH
 sgTcpRec_next             equ 00h             ;4   ;struct SGIP_RECORD_TCP * next   ;operate as a linked list
 sgTcpRec_tcpstate         equ 04h             ;4   ;int             tcpstate        ;TCP state information
 sgTcpRec_sequence         equ 08h             ;4   ;unsigned long   sequence        ;sequence number of first byte not acknowledged by remote system
 sgTcpRec_ack              equ 0Ch             ;4   ;unsigned long   ack             ;external sequence number of next byte to receive
 sgTcpRec_sequence_next    equ 10h             ;4   ;unsigned long   sequence_next   ;sequence number of first unsent byte
 sgTcpRec_rxwindow         equ 14h             ;4   ;unsigned long   rxwindow        ;sequence of last byte in receive window
 sgTcpRec_txwindow         equ 18h             ;4   ;unsigned long   txwindow        ;sequence of last byte allowed to send
 sgTcpRec_time_last_action equ 1Ch             ;4   ;int             time_last_action;used for retransmission and etc.
 sgTcpRec_time_backoff     equ 20h             ;4   ;int             time_backoff    ;
 sgTcpRec_retrycount       equ 24h             ;4   ;int             retrycount      ;
 sgTcpRec_srcip            equ 28h             ;4   ;unsigned long   srcip           ;
 sgTcpRec_destip           equ 2Ch             ;4   ;unsigned long   destip          ;
 sgTcpRec_srcport          equ 30h             ;2   ;unsigned short  srcport         ;
 sgTcpRec_destport         equ 32h             ;2   ;unsigned short  destport        ;
 sgTcpRec_listendata       equ 34h             ;4   ;struct SGIP_RECORD_TCP ** listendata
 sgTcpRec_maxlisten        equ 38h             ;4   ;int             maxlisten       ;
 sgTcpRec_errorcode        equ 3Ch             ;4   ;int             errorcode       ;
 sgTcpRec_want_shutdown    equ 40h             ;4   ;int             want_shutdown   ;0=don't want shutdown, 1=want shutdown, 2=being shutdown
 sgTcpRec_want_reack       equ 44h             ;4   ;int             want_reack      ;
 sgTcpRec_buf_rx_in        equ 48h             ;4   ;int             buf_rx_in       ;\
 sgTcpRec_buf_rx_out       equ 4Ch             ;4   ;int             buf_rx_out      ;
 sgTcpRec_buf_tx_in        equ 50h             ;4   ;int             buf_tx_in       ; TCP buffer information
 sgTcpRec_buf_tx_out       equ 54h             ;4   ;int             buf_tx_out      ;
 sgTcpRec_buf_oob_in       equ 58h             ;4   ;int             buf_oob_in      ;
 sgTcpRec_buf_oob_out      equ 5Ch             ;4   ;int             buf_oob_out     ;/
 sgTcpRec_buf_rx           equ 60h             ;@@x ;unsigned char   buf_rx[SGIP_TCP_RECEIVEBUFFERLENGTH];
 sgTcpRec_buf_tx           equ 60h+@@x         ;@@y ;unsigned char   buf_tx[SGIP_TCP_TRANSMITBUFFERLENGTH];
 sgTcpRec_buf_oob          equ 60h+@@x+@@y     ;@@z ;unsigned char   buf_oob[SGIP_TCP_OOBBUFFERLENGTH];
 sgTcpRec_size             equ 60h+@@x+@@y+@@z ;total
;------------------
;struct sgIP_TCP_SYNCookie:
 sgTcpSyn_localseq    equ 00h ;4  ;unsigned long     localseq
 sgTcpSyn_remoteseq   equ 04h ;4  ;unsigned long     remoteseq
 sgTcpSyn_localip     equ 08h ;4  ;unsigned long     localip
 sgTcpSyn_remoteip    equ 0Ch ;4  ;unsigned long     remoteip
 sgTcpSyn_localport   equ 10h ;2  ;unsigned short    localport
 sgTcpSyn_remoteport  equ 12h ;2  ;unsigned short    remoteport
 sgTcpSyn_timenext    equ 14h ;4  ;unsigned long     timenext
 sgTcpSyn_timebackoff equ 18h ;4  ;unsigned long     timebackoff
 sgTcpSyn_linked      equ 1Ch ;4  ;TcpRec            linked  ;parent listening connection
 sgTcpSyn_size        equ 20h ;total
;------------------
.endif ;with_tcp
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_UDP.h
;------------------
SGIP_UDP_STATE_UNBOUND equ 0 ;newly allocated           ;\
SGIP_UDP_STATE_BOUND   equ 1 ;got a source address/port ; enum's
SGIP_UDP_STATE_UNUSED  equ 2 ;no longer in use.         ;/
;------------------
;struct sgIP_Header_UDP:
 sgUdpHdr_srcport  equ 00h ;2  ;unsigned short srcport
 sgUdpHdr_destport equ 02h ;2  ;unsigned short destport
 sgUdpHdr_length   equ 04h ;2  ;unsigned short length
 sgUdpHdr_checksum equ 06h ;2  ;unsigned short checksum
 sgUdpHdr_size     equ 08h ;total
;------------------
;struct sgIP_Record_UDP:
 sgUdpRec_next               equ 00h ;4  ;struct SGIP_RECORD_UDP * next
 sgUdpRec_state              equ 04h ;4  ;int                      state
 sgUdpRec_srcip              equ 08h ;4  ;unsigned long            srcip
 sgUdpRec_destip             equ 0Ch ;4  ;unsigned long            destip
 sgUdpRec_srcport            equ 10h ;2  ;unsigned short           srcport
 sgUdpRec_destport           equ 12h ;2  ;unsigned short           destport
 sgUdpRec_incoming_queue     equ 14h ;4  ;MemBlk                   incoming_queue
 sgUdpRec_incoming_queue_end equ 18h ;4  ;MemBlk                   incoming_queue_end
 sgUdpRec_size               equ 1Ch ;total
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\wifi_arm9.h
;------------------
;BUGGED: WIFIINIT_OPTION_USEHEAP_128 and WIFIINIT_OPTION_USEHEAP_64
;        are assigned vice-versa in "wifi_arm9.h" versus "include\dswifi9.h"
;------------------
WIFIINIT_OPTION_USEHEAP_128    equ 00000h ;default=128K ;\  ;<-- BUGGED: (unlike as in "include\dswifi9.h")
WIFIINIT_OPTION_USEHEAP_64     equ 01000h               ;   ;<-- BUGGED: (unlike as in "include\dswifi9.h")
WIFIINIT_OPTION_USEHEAP_256    equ 02000h               ;
WIFIINIT_OPTION_USEHEAP_512    equ 03000h               ;
WIFIINIT_OPTION_USECUSTOMALLOC equ 04000h               ;
WIFIINIT_OPTION_HEAPMASK       equ 0F000h               ;/
;------------------
;user code uses members of the WIFIGETDATA structure in calling arm9_Wifi_GetData
;to retreive miscellaneous odd information
WIFIGETDATA_MACADDRESS equ 0 ;MACADDRESS: returns data in the buffer, requires at least 6 bytes
WIFIGETDATA_NUMWFCAPS  equ 1 ;NUM WFC APS: returns number between 0 and 3, doesn't use buffer.
;MAX_WIFIGETDATA       equ 2 ;<-- BLAH (number of above values, not needed, even for error checking it isn't really needed)
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm7\source\wifi_arm7.h
;------------------
;keepalive_time updated in the update handler, which should be called in vblank
WIFI_KEEPALIVE_COUNT    equ (60*128)   ;keepalive set for about 2 minutes

        ;;;WIFI_KEEPALIVE_COUNT    equ (60) ;XNAY

;------------------
.if with_nds_wifi
WIFI_REG     equ 4800000h         ;(*((volatile u16 *)(0x04800000+(ofs))))
;---
W_WEPKEY0    equ 4805F80h         ; (((volatile u16 *)(0x04805F80)))
W_WEPKEY1    equ 4805FA0h         ; (((volatile u16 *)(0x04805FA0)))
W_WEPKEY2    equ 4805FC0h         ; (((volatile u16 *)(0x04805FC0)))
W_WEPKEY3    equ 4805FE0h         ; (((volatile u16 *)(0x04805FE0)))
;---
;note: original code used hardcoded hex numbers for the Wifi RAM addresses,
;below constants should make it more clear how the Wifi RAM is mapped:
WIFIRAM_TX_LOC3_START   equ 0000h ;\TX packet (960h bytes, 2400 decimal)
WIFIRAM_TX_LOC3_SIZE    equ 0960h ;/
WIFIRAM_TX_BEACON_START equ 0960h ;\TX beacon (2A0h bytes, 672 decimal)
WIFIRAM_TX_BEACON_SIZE  equ 02A0h ;/
WIFIRAM_RX_BUFFER_START equ 0C00h ;\RX packets (1360h bytes, 4960 decimal)
WIFIRAM_RX_BUFFER_SIZE  equ 1360h-20h ;/   ;XXX "-20" for better align (for use as shifted 8bit ARM immediate)
WIFIRAM_SOMETHING_START equ 1F60h ;-used for something (by hardware?)
WIFIRAM_WEP_KEY_START   equ 1F80h ;-used for WEP keys (by hardware)
WIFIRAM_TOTAL_SIZE      equ 2000h ;-end of 8Kbyte Wifi RAM
WIFIRAM_BASE32          equ 4804000h  ;\base address for Wifi RAM (as 32bit
WIFIRAM_BASE16          equ 4000h     ;/ARM address, and 16bit Wifi address)
.endif ;with_nds_wifi
;------------------
;BUGGED: below uses wrong waitstate area (4800xxxh instead 4808xxxh)
;and, below is totally INCOMPLETE, and doesn't comply with gbatek names
;W_MODE_RST   equ 4800004h         ;(*((volatile u16 *)(0x04800004)))
;W_MODE_WEP   equ 4800006h         ;(*((volatile u16 *)(0x04800006)))
;W_IF         equ 4800010h         ;(*((volatile u16 *)(0x04800010)))
;W_IE         equ 4800012h         ;(*((volatile u16 *)(0x04800012)))
;W_MACADDR    equ 4800018h         ; (((volatile u16 *)(0x04800018)))
;W_BSSID      equ 4800020h         ; (((volatile u16 *)(0x04800020)))
;W_AIDS       equ 4800028h         ;(*((volatile u16 *)(0x04800028)))
;W_RETRLIMIT  equ 480002Ch         ;(*((volatile u16 *)(0x0480002C)))
;W_POWERSTATE equ 480003Ch         ;(*((volatile u16 *)(0x0480003C)))
;W_RANDOM     equ 4800044h         ;(*((volatile u16 *)(0x04800044)))
;W_BBSIOCNT   equ 4800158h         ;(*((volatile u16 *)(0x04800158)))
;W_BBSIOWRITE equ 480015Ah         ;(*((volatile u16 *)(0x0480015A)))
;W_BBSIOREAD  equ 480015Ch         ;(*((volatile u16 *)(0x0480015C)))
;W_BBSIOBUSY  equ 480015Eh         ;(*((volatile u16 *)(0x0480015E)))
;W_RFSIODATA2 equ 480017Ch         ;(*((volatile u16 *)(0x0480017C)))
;W_RFSIODATA1 equ 480017Eh         ;(*((volatile u16 *)(0x0480017E)))
;W_RFSIOBUSY  equ 4800180h         ;(*((volatile u16 *)(0x04800180)))
;------------------
;BLAH: below is SAME as in "include\dswifi7.h"
;      (and also SIMILAR as in "include\dswifi9.h", but, for other cpu there)
;typedef void (*WifiSyncHandler)();
;  Wifi Sync Handler function: Callback function that is called when the arm9
;  needs to be told to synchronize with new fifo data.
;  If this callback is used (see arm7_Wifi_SetSyncHandler()), it should send a
;  message via the fifo to the arm9, which will call arm9_Wifi_Sync() on arm9.
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP.c
;------------------
.data?
sgIP_timems   dd 0  ;1ms timer     ;unsigned long volatile
count_100ms   dd 0  ;100ms timer   ;unsigned long
count_1000ms  dd 0  ;1000ms timer  ;unsigned long
;BLAH/UNUSED: int sgIP_errno;
.code
.pool
;------------------
sgIP_Init:      ;in/out: none
 ;Initializes sgIP hub and sets up a default surrounding interface (ARP and IP)
 push lr
 ldr  r1,=sgIP_timems                   ;\
 mov  r0,0                              ; reset time(ms)
 str  r0,[r1]                           ;/
 bl   sgIP_memblock_Init                ;\
 bl   sgIP_Hub_Init                     ;
 bl   sgIP_sockets_Init                 ;
 bl   sgIP_ARP_Init                     ; call init functions
.if with_tcp
 bl   sgIP_TCP_Init                     ;
.endif
 bl   sgIP_UDP_Init                     ;
.if with_dns
 bl   sgIP_DNS_Init                     ;
.endif
 bl   sgIP_DHCP_Init                    ;/
 mov  r0,PROTOCOL_ETHER_IP              ;\
 ldr  r1,=sgIP_IP_ReceivePacket ;rx.proc; add IP interface
 mov  r2,0    ;=none          ;init.proc;
 bl   sgIP_Hub_AddProtocolInterface     ;/
 pop  pc
;------------------
sgIP_Timer:  ;in: r0=num_ms


       ;bx lr   ;XNAY XXXXXXXXXXXXX


 push  r4,lr
 mov   r4,r0     ;memorize num_ms
 ldr   r1,=sgIP_timems                  ;\
 ldr   r0,[r1]                          ; raise time(ms)
 add   r0,r4     ;add num_ms            ;
 str   r0,[r1]                          ;/
 ldr   r1,=count_100ms                  ;\
 ldr   r0,[r1]                          ;
 add   r0,r4     ;add num_ms            ; raise count(100ms)
 cmp   r0,100*2  ;\crop if too big      ; and, if 100ms ellapsed,
 movhs r0,100    ;/                     ; call ARP handler
 cmp   r0,100    ;\crop range   ;-->hs  ;
 subhs r0,100    ;/             ;<--hs  ;
 str   r0,[r1]                  ;   hs  ;
 blhs  sgIP_ARP_Timer100ms      ;<--hs  ;/
 ldr   r1,=count_1000ms                 ;\
 ldr   r0,[r1]                          ;
 add   r0,r4     ;add num_ms            ; raise count(1000ms)
 cmp   r0,1000*2 ;\crop if too big      ; and, if 1000ms ellapsed,
 movhs r0,1000   ;/                     ; call SOCKETS handler
 cmp   r0,1000   ;\crop range   ;-->hs  ;
 subhs r0,1000   ;/             ;<--hs  ;
 str   r0,[r1]                  ;   hs  ;
 blhs  sgIP_sockets_Timer1000ms ;<--hs  ;/
.if with_tcp
 bl    sgIP_TCP_Timer                   ;-process TCP timer (1ms)
.endif
 pop   r4,pc
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_ARP.c
;------------------
;BUGGED: original code doesn't disable IRQs in any ARP functions, so that ARP
;functions called by user code could collide with ARP functions called from
;IRQ handlers. That can cause several problems: Twice allocating the SAME
;"unused" ARP record by different functions, or trying to process incompletely
;initialized/modified ARP records.
;  sgIP_ARP_SendGratARP         ;\were called with IRQs enabled
;  sgIP_ARP_FlushInterface      ;/
;  sgIP_ARP_ProcessARPFrame     ;\were usually/always called with IRQs disabled
;  sgIP_ARP_SendProtocolFrame   ;/
;just to be sure, it's best to disable IRQs in all of the above four functions
;------------------
.data?
ArpRecords: defs sgArpRec_size*SGIP_ARP_MAXENTRIES  ;ArpRecords[SGIP_ARP_MAXENTRIES];
.code
;------------------
sgIP_ARP_FindArpSlot:  ;in: r0=HubHwi, r1=destIP, out: r0=ArpRec
 ;differences to original library:
 ;* return ADDRESS of ArpRec         (instead of INDEX in slot array)
 ;* or ZERO if not found             (instead of MINUS ONE)
 push r4,lr
 ldr  r2,=ArpRecords
 mov  r3,SGIP_ARP_MAXENTRIES
@@lop:
 ldrh  r4,[r2,sgArpRec_flags]           ;\
 eor   r4,SGIP_ARP_FLAG_ACTIVE          ; want used entry
 tst   r4,SGIP_ARP_FLAG_ACTIVE          ; and
 ldreq r4,[r2,sgArpRec_linked_interface]; want matching HubHW
 cmpeq r4,r0  ;HubHw                    ; and
 ldreq r4,[r2,sgArpRec_protocol_address]; want matching destIP
 cmpeq r4,r1  ;destIP                   ;
 beq   @@this_r2  ;out: r2=ArpRec       ;/
 add  r2,sgArpRec_size                  ;\
 subs r3,1                              ; lop next
 bne  @@lop                             ;/
 mov  r2,0   ;0=not found               ;-not found
@@this_r2:
 mov  r0,r2  ;out: r0=ArpRec (or 0=not found)
 pop  r4,pc
;------------------

want_irq_off:   ;XNAY

                push r0-r3,lr
                mov r0,cpsr
                and r0,80h
                eor r0,80h
                mov r0,r0,lsr 7
                mov  r1,4000000h
                ldr  r1,[r1,REG_IME]
                ands r0,r1
                beq @@ookk
                mov  r0,lr
                bl   wrhex32bit
                mov r0,':' // bl wrchr_r0
                mov r0,':' // bl wrchr_r0
                mov r0,':' // bl wrchr_r0
                mov r0,':' // bl wrchr_r0
                mov r0,':' // bl wrchr_r0
                mov r0,':' // bl wrchr_r0
                bl  wrcrlf
                b $
                @@ookk:
                pop  r0-r3,pc


;------------------
sgIP_ARP_GetUnusedArpSlot:  ;in: none, out: r0=ArpRec (free slot, or newly free'ed slot)
 ;differences to original library:
 ;* return ADDRESS of ArpRec         (instead of INDEX in slot array)
 ;* renamed to "sgIP_ARP_GetUnusedArpSlot" (instead of "sgIP_GetArpSlot")
 push r4,lr


       .if 0       ;XNAY
        bl want_irq_off

        mov r0,11h // bl wrchr_r0
        mov r0,'F' // bl wrchr_r0
        mov r0,'A' // bl wrchr_r0
        mov r0,10h // bl wrchr_r0
       .endif

 ldr  r0,=ArpRecords
 mov  r1,SGIP_ARP_MAXENTRIES
 mov  r2,0      ;idle
@@lop:
 ldrh r3,[r0,sgArpRec_flags]            ;\
 tst  r3,SGIP_ARP_FLAG_ACTIVE           ; check if free
 beq  @@found_free                      ;/
 ldr  r3,[r0,sgArpRec_idletime]         ;\
 cmp  r3,r2     ;idle                   ; or else search biggest idle time
 movhs r2,r3    ;idle                   ;
 movhs r4,r0    ;ArpRec                 ;/
 add  r0,sgArpRec_size                  ;\
 subs r1,1                              ; lop next
 bne  @@lop                             ;/

       .if 0
        mov r0,'-' // bl wrchr_r0
        mov r0,'N' // bl wrchr_r0
        mov r0,'O' // bl wrchr_r0
        mov r0,'A' // bl wrchr_r0
        mov r0,'R' // bl wrchr_r0
        mov r0,'P' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
        b $
       .endif

;- - - slot *was* in use, so let's fix that situation...
 mov  r0,r4                     ;\discard the old "outdated" record
 bl   sgIP_ARP_DiscardArpSlot   ;/
 mov  r0,r4     ;out: r0=ArpRec (which had biggest idletime)
@@found_free:   ;out: r0=ArpRec
 pop  r4,pc
;------------------
sgIP_ARP_DiscardArpSlot:  ;in: r0=ArpRec, out: none
 ;BUGGED: original code didn't always clean up these things properly
 ;(sometimes only clearing the flags, without deallocating the queued_packet,
 ;or deallocating it's memblk, but without marking it as queued_packet=0)
 ;- - -
 push r4,lr
 mov  r4,r0  ;ArpRec
 ldr  r0,[r4,sgArpRec_queued_packet]    ;\
 cmp  r0,0                              ; dealloc queued packet (if any)
 blne sgIP_memblock_free  ;in: r0       ;/
 mov  r0,0                              ;\
 strh r0,[r4,sgArpRec_flags]            ;
 strh r0,[r4,sgArpRec_retrycount]       ; init empty slot
 str  r0,[r4,sgArpRec_idletime]         ;
 str  r0,[r4,sgArpRec_queued_packet]    ;/
 pop  r4,pc
;------------------
sgIP_is_broadcast_address:  ;in: r0=HubHwi, r1=IPaddr), out: r0
 ldr   r0,[r0,sgHubHwi_snmask]
 orr   r0,r1  ;SubNetMask or IPaddr
 cmp   r0,0ffffffffh
 moveq r0,1
 movne r0,0
 bx    lr
;------------------
sgIP_ARP_Check_isok:  ;in: r0=HubHwi, r1=MemBlk, r2=ArpHdr, out: r0
;this function could/should protect against malformed packets that could
;cause internal problems.
 mov  r0,1      ;doesn't do anything yet
 bx   lr
;------------------
sgIP_ARP_Init:  ;in/out: none
 ldr  r1,=ArpRecords
 mov  r2,SGIP_ARP_MAXENTRIES
 mov  r0,0
@@lop:
 strh r0,[r1,sgArpRec_flags]
 str  r0,[r1,sgArpRec_idletime]
 str  r0,[r1,sgArpRec_queued_packet]
 add  r1,sgArpRec_size                  ;\
 subs r2,1                              ; lop next
 bne  @@lop                             ;/
 bx   lr
;------------------
sgIP_ARP_Timer100ms:  ;in/out: none
 push r4-r5,lr

       .if 0        ;XNAY
                mov r0,cpsr
                tst r0,80h
                bne @@ookk
                mov r0,'T' // bl wrchr_r0
                mov r0,':' // bl wrchr_r0
                mov r0,':' // bl wrchr_r0
                mov r0,':' // bl wrchr_r0
                b $
                @@ookk:
       .endif

 ldr  r4,=ArpRecords
 mov  r5,SGIP_ARP_MAXENTRIES
@@lop:         ;bugfix 1/2019, some of below used "r1" instead "r4", outch
 ldrh r0,[r4,sgArpRec_flags]            ;\
 tst  r0,SGIP_ARP_FLAG_ACTIVE           ; skip if unused entry
 beq  @@lop_next                        ;/
 ldr  r0,[r4,sgArpRec_idletime]         ;\
 add  r0,1                              ; raise idletime
 str  r0,[r4,sgArpRec_idletime]         ;/
 ldrh r0,[r4,sgArpRec_flags]            ;\skip if ALREADY having hw addr
 tst  r0,SGIP_ARP_FLAG_HAVEHWADDR       ; bugfix 1/2019 (old skipped when NOT having it, which is opposite of desired behaviour, as the request want to OBTAIN the hw addr)
 bne  @@lop_next                        ;/
 ldrh r0,[r4,sgArpRec_retrycount]       ;\
 add  r0,1                              ;
 strh r0,[r4,sgArpRec_retrycount]       ; raise retrycount
 cmp  r0,125                            ; and
 bhi  @@give_up                         ; give up or retry
 and  r0,07h                            ; eventually
 cmp  r0,07h                            ;
 beq  @@do_retry                        ;/
@@lop_next:
 add  r4,sgArpRec_size                  ;\
 subs r5,1                              ; lop next
 bne  @@lop                             ;/
 pop  r4-r5,pc
;---
@@give_up:  ;it's a lost cause

       .if show_arp_info       ;XNAY
        mov r0,11h // bl wrchr_r0
        mov r0,'A' // bl wrchr_r0
        mov r0,'R' // bl wrchr_r0
        mov r0,'P' // bl wrchr_r0
        mov r0,'K' // bl wrchr_r0
        mov r0,'I' // bl wrchr_r0
        mov r0,'L' // bl wrchr_r0
        mov r0,'L' // bl wrchr_r0
        mov r0,10h // bl wrchr_r0
       .endif

 mov  r0,r4                     ;\discard the old "outdated" record
 bl   sgIP_ARP_DiscardArpSlot   ;/
 b    @@lop_next
;---
@@do_retry:    ;attempt retransmit of ARP frame

       .if show_arp_info     ;XNAY
        mov r0,11h // bl wrchr_r0
        mov r0,'A' // bl wrchr_r0
        mov r0,'R' // bl wrchr_r0
        mov r0,'P' // bl wrchr_r0
        mov r0,'R' // bl wrchr_r0
        mov r0,'E' // bl wrchr_r0
        mov r0,'T' // bl wrchr_r0
        mov r0,'R' // bl wrchr_r0
        mov r0,'Y' // bl wrchr_r0
        mov r0,10h // bl wrchr_r0
       .endif

 ldr  r0,[r4,sgArpRec_linked_interface] ;\
 ldr  r1,[r4,sgArpRec_linked_protocol]  ;
 ldr  r2,[r4,sgArpRec_protocol_address] ;
 bl   sgIP_ARP_SendARPRequest           ;/
 b    @@lop_next
;------------------
sgIP_ARP_FlushInterface:  ;in: r0=HubHwi (0=all), out: none
 push r4-r7,lr
 mov  r4,r0  ;HubHwi (0=all)

        ;;;bl want_irq_off

 bl   sgIP_IntrProtect          ;\
 mov  r5,r0                     ;/
 ldr  r6,=ArpRecords
 mov  r7,SGIP_ARP_MAXENTRIES
@@lop:
 ldr   r3,[r6,sgArpRec_linked_interface]    ;\
 cmp   r4,r3  ;<-- match (param)            ; discard (when matching param,
 cmpne r4,0   ;<-- wildcard (param=0)       ; or when param is zero/wildcard)
 moveq r0,r6  ;ArpRec            ;\discard  ;
 bleq  sgIP_ARP_DiscardArpSlot   ;/         ;/
 add  r6,sgArpRec_size                  ;\
 subs r7,1                              ; lop next
 bne  @@lop                             ;/

       .if 0       ;XNAY
        push lr
        mov r0,10h // bl wrchr_r0
        mov r0,'F' // bl wrchr_r0
        mov r0,'L' // bl wrchr_r0
        mov r0,'U' // bl wrchr_r0
        mov r0,'S' // bl wrchr_r0
        mov r0,'H' // bl wrchr_r0
        mov r0,11h // bl wrchr_r0
        pop lr
       .endif

 mov  r0,r5                     ;\
 bl   sgIP_IntrUnprotect        ;/
 pop  r4-r7,pc
;------------------
sgIP_ARP_ProcessIPFrame: ;in:r0=HubHwi, r1=MemBlk, out: r0
;don't *really* need to process this, but it helps.
 mov  r0,0
 bx   lr
;------------------
sgIP_ARP_ProcessARPFrame: ;in: r0=HubHwi, r1=MemBlk, out: r0=zero   ;Recv'ed
 push r4-r9,lr
 mov  r4,r0  ;HubHwi
 mov  r5,r1  ;MemBlk
        bl want_irq_off

        .if show_arp_info
          bl wrcrlf
          mov  r0,12h // bl wrchr_r0
          mov  r0,'A' // bl wrchr_r0
          mov  r0,'R' // bl wrchr_r0
          mov  r0,'P' // bl wrchr_r0
          mov  r0,11h // bl wrchr_r0
          mov  r0,'R' // bl wrchr_r0
          mov  r0,'E' // bl wrchr_r0
          mov  r0,'C' // bl wrchr_r0
          mov  r0,'V' // bl wrchr_r0
          mov  r0,12h // bl wrchr_r0
          ;exposeexpose
         ldr  r0,[r5,sgMemBlk_thislength]  ;\len  ;2Ah.req on NDS -- 3Ch.resp on DSi?
         bl wrhex8bit                      ;/
          mov  r0,10h // bl wrchr_r0
        .endif

 bl   sgIP_IntrProtect          ;\
 mov  r9,r0                     ;/
 cmp  r5,0   ;MemBlk            ;\reject if MemBlk=0
 beq  @@exit                    ;/
 cmp  r4,0   ;HubHwi            ;\reject if HubHwi=0
 beq  @@exit_free               ;/  ;BUGGED: fix: FREE if hw=0, but MemBlk<>0
 mov  r0,r5  ;MemBlk                    ;\
 mov  r1,-14                            ; hide 14 bytes at the start temporarily
 bl   sgIP_memblock_exposeheader        ;/
 ldr  r6,[r5,sgMemBlk_datastart]        ;-get ArpHdr (within MemBlk)
 mov  r0,r4  ;HubHwi                    ;\
 mov  r1,r5  ;MemBlk                    ;
 mov  r2,r6  ;ArpHdr                    ; error if arp header incorrect somehow
 bl   sgIP_ARP_Check_isok               ;
 cmp  r0,0                              ;
 beq  @@exit_free                       ;/
 mov  r0,r5  ;MemBlk                    ;\
 mov  r1,+14                            ; re-expose 14 bytes at the start
 bl   sgIP_memblock_exposeheader        ;/
 ldrh r0,[r6,sgArpHdr_opcode]           ;\
 cmp  r0,ARP_OPCODE_REQUEST  ;\request  ; opcode
 beq  @@request              ;/         ;
 cmp  r0,ARP_OPCODE_RESPONSE ;\response ;
 beq  @@response             ;/         ;/
;- - -
@@exit_free:
 mov  r0,r5  ;MemBlk            ;\free MemBlk
 bl   sgIP_memblock_free        ;/
@@exit:
 mov  r0,r9                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,0      ;uh, always returns 0
 pop  r4-r9,pc
;---
@@request:

       .if 0       ;XNAY
        mov r0,'R' // bl wrchr_r0
        mov r0,'E' // bl wrchr_r0
        mov r0,'Q' // bl wrchr_r0
        bl wrspc
       .endif

 add  r1,r6,sgArpHdr_addresses          ;\
 ldrb r2,[r6,sgArpHdr_hw_addr_len]      ;
 add  r1,r1,r2,lsl 1   ;<-- add LEN*2   ; get Requested IP from address[2]+4
 add  r1,4             ;<-- add 4       ;
 bl   ldr_32bit_r0_from_r1              ;
 mov  r8,r0  ;IP                        ;/

       .if show_arp_info      ;XNAY
        mov r0,13h // bl wrchr_r0
        mov r0,r8 ;IP                   ;\IP
        bl wrhex32bit                   ;/
        mov r0,10h // bl wrchr_r0
       .endif

;SGIP_DEBUG_MESSAGE(("ARP: request IP %08X",ip));
 ldr  r1,[r4,sgHubHwi_ipaddr]           ;\
 cmp  r1,r8  ;IP                        ; ignore if not our IP address
 bne  @@exit_free                       ;/

       .if show_arp_info     ;XNAY
        mov r0,'Y' // bl wrchr_r0
        mov r0,'O' // bl wrchr_r0
        bl wrspc
       .endif

 mov  r0,r4  ;HubHwi                    ;\someone's asking for our info,
 mov  r1,r5  ;MemBlk                    ; so toss them a reply
 bl   sgIP_ARP_SendARPResponse          ;/
 b    @@exit  ;exit (without free here)
;---
@@response:

       .if show_arp_info      ;XNAY
        mov r0,'R' // bl wrchr_r0
        mov r0,'E' // bl wrchr_r0
        mov r0,'S' // bl wrchr_r0
        mov r0,'P' // bl wrchr_r0
        bl wrspc
       .endif

 add  r1,r6,sgArpHdr_addresses          ;\
 ldrb r2,[r6,sgArpHdr_hw_addr_len]      ;
 add  r1,r1,r2,lsl 0   ;<-- add LEN*1   ; get Sender IP from address[1]
 bl   ldr_32bit_r0_from_r1              ;
 mov  r8,r0  ;IP                        ;/
 mov  r1,r8  ;IP                        ;\
 mov  r0,r4  ;HubHwi                    ; reject if we haven't been
 bl   sgIP_ARP_FindArpSlot              ; awaiting that response

       .if 0       ;XNAY
        push r0
        bl wrhex32bit
        bl wrspc
        pop r0
       .endif

 movs r7,r0  ;ArpSlot                   ;
 beq  @@exit_free  ;--> not found       ;/
 add  r0,r6,sgArpHdr_addresses+0   ;src ;\
 add  r1,r7,sgArpRec_hw_address    ;dst ; copy address[0] from ArpHdr to ArpRec
 ldrb r2,[r6,sgArpHdr_hw_addr_len] ;len ;
 bl   memcopy_bytewise                  ;/
 ldrh r0,[r7,sgArpRec_flags]            ;\
 orr  r0,SGIP_ARP_FLAG_HAVEHWADDR       ; set flag
 strh r0,[r7,sgArpRec_flags]            ;/
 ldr  r1,[r7,sgArpRec_queued_packet]    ;\
 cmp  r1,0   ;MemBlk'2 (queued_packet)  ; exit if no queued_packet
 beq  @@exit_free                       ;/
 mov  r0,0                              ;\remove queued_packet
 str  r0,[r7,sgArpRec_queued_packet]    ;/(since it'll be send now...)

       .if show_arp_info      ;XNAY
                ;DSi comes here (with below lengths=28h)
                ;NDS doesn't come here (apparently sends packet right away, without queueing)
        mov r0,'Q' // bl wrchr_r0    ;\
        mov r0,'U' // bl wrchr_r0    ; from queue
        mov r0,'E' // bl wrchr_r0    ;/
        ldr  r0,[r1,sgMemBlk_thislength]
        bl wrhex8bit
        bl wrspc
       .endif

 mov  r0,r4  ;HubHwi                    ;\
;mov  r1,r1  ;MemBlk'2 (queued_packet)  ;
 ldr  r2,[r7,sgArpRec_linked_protocol]  ; send queued_packet
 mov  r3,r8  ;IP                        ;
 bl   sgIP_ARP_SendProtocolFrame        ;/
 b    @@exit_free
;------------------
sgIP_ARP_SendProtocolFrame:  ;in: r0=HubHwi, r1=MemBlk, r2=protocol, r3=destaddr, out: r0
 push r4-r10,lr
 mov  r4,r0  ;HubHwi
 mov  r5,r1  ;MemBlk
 mov  r6,r2  ;protocol
 mov  r7,r3  ;destaddr

       .if 0       ;XNAY
        bl want_irq_off
       .endif

 bl   sgIP_IntrProtect          ;\
 mov  r10,r0                    ;/
 cmp  r5,0   ;MemBlk            ;\
 beq  @@fail                    ; reject if param(s) are zero
 cmp  r4,0   ;HubHwi            ;
 beq  @@fail_dealloc            ;/
 mov  r0,r5  ;MemBlk                    ;\
 mov  r1,+14                            ; add 14 bytes at start for the header
 bl   sgIP_memblock_exposeheader        ;/
 ldr  r9,[r5,sgMemBlk_datastart]        ;-get ptr to EthHdr
 mov  r0,r4  ;HubHwi                    ;\
 mov  r1,r7  ;destaddr                  ;
 bl   sgIP_is_broadcast_address         ; check if BROADCAST
 cmp  r0,0                              ;
 bne  @@broadcast                       ;/
 mov  r0,r4  ;HubHwi                    ;\
 mov  r1,r7  ;destaddr                  ;
 bl   sgIP_ARP_FindArpSlot              ; find slot (if none: CREATE a new one)
 movs r8,r0  ;ArpRec                    ;
 beq  @@create_new_slot                 ;/
 ldrh r0,[r8,sgArpRec_flags]            ;\
 tst  r0,SGIP_ARP_FLAG_HAVEHWADDR       ; check if having hw addr
 bne  @@have_hw_addr                    ;/
;we don't have the address, but are looking for it, so try queue'ing packet...
 ldr  r0,[r8,sgArpRec_queued_packet]    ;\fail if there is already a queued
 bne  @@fail_dealloc                    ;/packet (and reject the new one)
 mov  r0,r5  ;MemBlk                    ;\
 mov  r1,-14                            ; re-hide ethernet header
 bl   sgIP_memblock_exposeheader        ;/
 str  r5,[r8,sgArpRec_queued_packet]    ;-queue packet (MemBlk)         ;\queue
 str  r6,[r8,sgArpRec_linked_protocol]  ;-apply protocol                ;/
 b    @@return_zero   ;exit, not sent yet (but it's queued)
;---
@@have_hw_addr:
 mov  r0,0                              ;\clear idletime
 str  r0,[r8,sgArpRec_idletime]         ;/
;- - - construct ETHERNET header
 add  r0,r4,sgHubHwi_hwaddr                        ;src ;\
 add  r1,r9,sgEthHdr_src_mac                       ;dst ; src_mac = hwaddr
 bl   arm9_Wifi_CopyMacAddr                             ;/
 add  r0,r8,sgArpRec_hw_address                    ;src ;\
 add  r1,r9,sgEthHdr_dest_mac                      ;dst ; dest_mac = ArpRec's
 bl   arm9_Wifi_CopyMacAddr                             ;/            hw_addr

        .if 0
         add  r1,r9,sgEthHdr_dest_mac
         .rept 6
           ldrb r0,[r1],1 // bl wrhex8bit // bl wrspc
         .endm
        .endif

 b    @@set_protocol_and_send
;---
@@broadcast:
;- - - construct ETHERNET header
 add  r0,r4,sgHubHwi_hwaddr                        ;src ;\
 add  r1,r9,sgEthHdr_src_mac                       ;dst ; src_mac = hwaddr
 bl   arm9_Wifi_CopyMacAddr                             ;/
 ldr  r0,=const_FFFFFFFFFFFFh                      ;src ;\
 add  r1,r9,sgEthHdr_dest_mac                      ;dst ; dest_mac = broadcast
 bl   arm9_Wifi_CopyMacAddr                             ;/
@@set_protocol_and_send:
 strh r6,[r9,sgEthHdr_protocol]                         ;-protocol (incoming r2)
;- - - send ethernet packet...
 mov  r0,r4  ;HubHwi            ;\
 mov  r1,r5  ;MemBlk            ; send (this function will free the
 bl   sgIP_Hub_SendRawPacket    ; memory block when it's done)
 b    @@return_r0               ;/
;---
@@create_new_slot:

       .if 0       ;XNAY
        mov r0,'?' // bl wrchr_r0
       .endif

 bl   sgIP_ARP_GetUnusedArpSlot         ;\get a new/free ARP slot       ;\
 mov  r8,r0  ;ArpRec                    ;/                              ;
 mov  r0,SGIP_ARP_FLAG_ACTIVE           ;\mark used                     ; build
 strh r0,[r8,sgArpRec_flags]            ;/                              ; new
 mov  r0,0                              ;\                              ; record
 str  r0,[r8,sgArpRec_idletime]         ; clear idletime,retrycount     ;
 strh r0,[r8,sgArpRec_retrycount]       ;/                              ;
 str  r4,[r8,sgArpRec_linked_interface] ;-apply HubHwi                  ;
 str  r7,[r8,sgArpRec_protocol_address] ;-apply destaddr                ;/
 mov  r0,r5  ;MemBlk                    ;\
 mov  r1,-14                            ; re-hide ethernet header
 bl   sgIP_memblock_exposeheader        ;/

       .if show_arp_info       ;XNAY
         ldr  r0,[r8,sgArpRec_queued_packet]
         cmp  r0,0
         beq  @@okkk
        mov r0,13h // bl wrchr_r0
        mov r0,'O' // bl wrchr_r0
        mov r0,'U' // bl wrchr_r0
        mov r0,'T' // bl wrchr_r0
        mov r0,'C' // bl wrchr_r0
        mov r0,'H' // bl wrchr_r0
        mov r0,11h // bl wrchr_r0
        b $
         @@okkk:
        mov r0,'?' // bl wrchr_r0
       .endif


         ;;;  ldr  r0,=wifi_hw                     ;
         ;;;  ldr  r0,[r0]  ;HubHwi                ;
         ;;;  bl   sgIP_ARP_SendGratARP            ;


 str  r5,[r8,sgArpRec_queued_packet]    ;-queue packet (MemBlk)         ;\queue
 str  r6,[r8,sgArpRec_linked_protocol]  ;-apply protocol                ;/
 mov  r0,r4  ;HubHwi                    ;\
 mov  r1,r6  ;protocol                  ; send some REQUEST
 mov  r2,r7  ;destaddr                  ; (instead of sending the queued packet)
 bl   sgIP_ARP_SendARPRequest           ;/  (this request HW.ADDR for dest.IP?)
 b    @@return_zero   ;exit, not sent yet (but it's queued)
;---
@@fail_dealloc:

       .if show_arp_info   ;XNAY
        mov r0,13h // bl wrchr_r0
        mov r0,'A' // bl wrchr_r0
        mov r0,'R' // bl wrchr_r0
        mov r0,'P' // bl wrchr_r0
        mov r0,'F' // bl wrchr_r0
        mov r0,'A' // bl wrchr_r0
        mov r0,'I' // bl wrchr_r0
        mov r0,'L' // bl wrchr_r0
        mov r0,11h // bl wrchr_r0
        b $
       .endif

 mov  r0,r5  ;MemBlk            ;\dealloc
 bl   sgIP_memblock_free        ;/
@@fail:
@@return_zero:
 mov  r0,0   ;fail
@@return_r0:
 mov  r4,r0  ;return value
 mov  r0,r10                    ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r4  ;return value
 pop  r4-r10,pc
;------------------
sgIP_ARP_SendARPResponse:  ;in: r0=HubHwi, r1=MemBlk, out: r0
 push r4-r7,lr

       .if show_arp_info      ;XNAY
        push r0
        mov r0,'-' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
        pop r0
       .endif

       .if 0       ;XNAY
        bl want_irq_off
       .endif

 movs r5,r1  ;MemBlk            ;\
 beq  @@fail                    ; reject if param(s) are zero
 movs r4,r0  ;HubHwi            ;
 beq  @@fail_dealloc            ;/
 mov  r0,r5  ;MemBlk            ;\
 mov  r1,-14                    ; hide 14 bytes at the start temporarily...
 bl   sgIP_memblock_exposeheader;/

        ;NDS-wifi comes here (after dhcp)
        ;DSi-wifi doesn't ??? -- or fails to send sgIP_ARP_SendGratARP ???

       .if show_arp_info      ;XNAY
        mov r0,'+' // bl wrchr_r0
        mov r0,'+' // bl wrchr_r0
        mov r0,'+' // bl wrchr_r0
        mov r0,'+' // bl wrchr_r0
        mov r0,'+' // bl wrchr_r0
        mov r0,'+' // bl wrchr_r0
        mov r0,'+' // bl wrchr_r0
        mov r0,'+' // bl wrchr_r0
        mov r0,'+' // bl wrchr_r0
        mov r0,'A' // bl wrchr_r0
       .endif

.if with_arp_padding
      ;XXX should add padding, but MemBlk is pre-allocated and MAY be too small
.endif

;- - - repurpose existing ARP packet...
 ldr  r6,[r5,sgMemBlk_datastart]                        ;-get ptr to ArpHdr
 mov  r0,r6  ;ArpHdr            ;\
 bl   sgIP_ARP_Check_isok       ; reject if ARP Header (at MemBlk's DATA) is bad
 cmp  r0,0                      ;
 beq  @@fail_dealloc            ;/
 ldrb r0,[r6,sgArpHdr_hw_addr_len]        ;8bit         ;\
 ldrh r1,[r4,sgHubHwi_hwaddrlen]          ;16bit        ; reject unexpected
 cmp   r0,r1     ;hw_addr_len                           ; addr_len's
 ldrb  r0,[r6,sgArpHdr_protocol_addr_len] ;8bit         ; (can't send back
 cmpeq r0,4      ;protocol_addr_len                     ; that, sorry)
 bne  @@fail_dealloc                                    ;/
 mov  r0,ARP_OPCODE_RESPONSE                            ;\opcode (response)
 strh r0,[r6,sgArpHdr_opcode]                           ;/
 add  r0,r6,sgArpHdr_addresses                     ;src ;\
 ldrh r2,[r4,sgHubHwi_hwaddrlen] ;\len addr(0)     ;len ; copy addr(0,1)
 add  r2,4                       ;/plus addr(1)    ;len ;   to addr(2,3)
 add  r1,r0,r2   ;dst = src+len                    ;dst ;
 bl   memcopy_bytewise                                  ;/
 add  r1,r6,sgArpHdr_addresses                     ;dst ;-dest for below addr's
 add  r0,r4,sgHubHwi_hwaddr                        ;src ;\
 ldrh r2,[r4,sgHubHwi_hwaddrlen]                   ;len ; addr(0) = hwaddr
 bl   memcopy_bytewise                                  ;/
 add  r0,r4,sgHubHwi_ipaddr                        ;src ;\
 mov  r2,4                                         ;len ; addr(1) = ipaddr
 bl   memcopy_bytewise                                  ;/
;- - - construct ETHERNET header...
 mov  r0,r5  ;MemBlk                    ;\
 mov  r1,+14                            ; add 14 bytes at start for the header
 bl   sgIP_memblock_exposeheader        ;/
 ldr  r7,[r5,sgMemBlk_datastart]                        ;-get ptr to EthHdr
 add  r0,r4,sgHubHwi_hwaddr                        ;src ;\
 add  r1,r7,sgEthHdr_src_mac                       ;dst ; src_mac = hwaddr
 bl   arm9_Wifi_CopyMacAddr                             ;/
 add  r0,r6,sgArpHdr_addresses   ;<--from ARP      ;src ;\
 ldrh r3,[r4,sgHubHwi_hwaddrlen]                   ;src ;
 add  r0,r3   ;skip addr(0), now point to addr(1)  ;src ; dest_mac = addr(2)
 add  r0,4    ;skip addr(1), now point to addr(2)  ;src ; (aka requesting party)
 add  r1,r7,sgEthHdr_dest_mac                      ;dst ;
 bl   arm9_Wifi_CopyMacAddr                             ;/
 ldr  r0,=PROTOCOL_ETHER_ARP                            ;\protocol ARP
 strh r0,[r7,sgEthHdr_protocol]                         ;/
;- - - send ethernet packet...

       .if show_arp_info      ;XNAY
        mov r0,'Y' // bl wrchr_r0
        mov r0,'E' // bl wrchr_r0
        mov r0,'P' // bl wrchr_r0
        mov r0,'P' // bl wrchr_r0
        bl wrspc
       .endif

 mov  r0,r4  ;HubHwi            ;\
 mov  r1,r5  ;MemBlk            ; send (this function will free the
 bl   sgIP_Hub_SendRawPacket    ; memory block when it's done)
 b    @@return_r0               ;/
;---
@@fail_dealloc:
 mov  r0,r5  ;MemBlk            ;\dealloc
 bl   sgIP_memblock_free        ;/
@@fail:
 mov  r0,0  ;fail
@@return_r0:
 pop  r4-r7,pc
;------------------
sgIP_ARP_SendGratARP:  ;in: r0=HubHwi, out: r0
 push r4-r8,lr
 mov  r4,r0  ;HubHwi

       .if 0       ;XNAY
        ;;;bl want_irq_off
       .endif

       .if show_arp_info     ;XNAY
          bl wrcrlf
          mov  r0,12h // bl wrchr_r0
          mov  r0,'A' // bl wrchr_r0
          mov  r0,'R' // bl wrchr_r0
          mov  r0,'P' // bl wrchr_r0
          mov  r0,11h // bl wrchr_r0
          mov  r0,'G' // bl wrchr_r0
          mov  r0,'R' // bl wrchr_r0
          mov  r0,'A' // bl wrchr_r0
          mov  r0,'T' // bl wrchr_r0
          mov  r0,12h // bl wrchr_r0
            ldr  r1,=WifiData_curChannel
            ldrh r0,[r1]
            bl wrhex8bit
          mov  r0,10h // bl wrchr_r0
       .endif

 bl   sgIP_IntrProtect          ;\
 mov  r8,r0                     ;/
 cmp  r4,0   ;HubHwi                    ;\reject if hw=0
 beq  @@fail                            ;/
 ldrh r0,[r4,sgHubHwi_hwaddrlen]        ;\
 mov  r0,r0,lsl 1   ;mul2               ;
 add  r0,SGIP_HEADER_ARP_BASESIZE+2*4   ; alloc mem
.if with_arp_padding
        mov r0,sgArpHdr_size
.endif
 bl   sgIP_memblock_alloc               ;
 movs r5,r0  ;MemBlk                    ;
 beq  @@fail                            ;/

    .if 0 ;XNAY
       @@ww:    ;XNAY
                mov r0,'!' // bl wrchr_r0
        ldr  r0,=WifiData_flags9               ;\
        ldr  r0,[r0]                           ;
        tst  r0,WFLAG_ARM9_NETUP               ;
        beq  @@ww                              ;/
     ;  mov r0,100000h
     ;  @@ll:                   ;XXXX need this delay, else Grat could be send BEFORE "NETUP" flag is getting set!
     ;  subs r0,1               ;     NO, ACTUALLY DON'T NEED IT
     ;  bne @@ll
    .endif

;- - - construct ARP packet...
 ldr  r6,[r5,sgMemBlk_datastart]                        ;-get ptr to ArpHdr
 mov  r0,PROTOCOL_ETHER_IP                              ;\protocol (ether_ip)
 strh r0,[r6,sgArpHdr_protocol]                         ;/
 mov  r0,HWSPACE_ETHERNET                               ;\hwspace (ethernet)
 strh r0,[r6,sgArpHdr_hwspace]                          ;/
.if with_arp_grat_request
   mov  r0,ARP_OPCODE_REQUEST                           ;\opcode (request)
.else
   mov  r0,ARP_OPCODE_RESPONSE                          ;\opcode (response)
.endif
 strh r0,[r6,sgArpHdr_opcode]                           ;/
 ldrh r0,[r4,sgHubHwi_hwaddrlen]  ;16bit (unlike below) ;\hw_addr_len
 strb r0,[r6,sgArpHdr_hw_addr_len] ;8bit (unlike above) ;/
 mov  r0,04h                                            ;\protocol_addr_len
 strb r0,[r6,sgArpHdr_protocol_addr_len]                ;/
 add  r1,r6,sgArpHdr_addresses                     ;dst ;-dest for below addr's
 add  r0,r4,sgHubHwi_hwaddr                        ;src ;\
 ldrh r2,[r4,sgHubHwi_hwaddrlen]                   ;len ; addr(0) = hwaddr        ;SHA sender hw addr
 bl   memcopy_bytewise                                  ;/
 add  r0,r4,sgHubHwi_ipaddr                        ;src ;\
 mov  r2,4                                         ;len ; addr(1) = ipaddr        ;SPA sender protocol addr
 bl   memcopy_bytewise                                  ;/
.if with_arp_grat_request
   mov  r0,00h                                     ;fil ;\
   ldrh r2,[r4,sgHubHwi_hwaddrlen]                 ;len ; addr(2) = ZERO          ;THA target hw addr
   bl   memfill_bytewise                                ;/
.else
   add  r0,r4,sgHubHwi_hwaddr                      ;src ;\
   ldrh r2,[r4,sgHubHwi_hwaddrlen]                 ;len ; addr(2) = hwaddr, too   ;THA target hw addr
   bl   memcopy_bytewise                                ;/
.endif
 add  r0,r4,sgHubHwi_ipaddr                        ;src ;\
 mov  r2,4                                         ;len ; addr(3) = ipaddr, too   ;TPA target protocol addr
 bl   memcopy_bytewise                                  ;/

.if with_arp_padding
 mov  r0,00h                                       ;fil ;\
 add  r1,r6,sgArpHdr_padding                       ;dst ;
 mov  r2,18                                        ;len ;
 bl   memfill_bytewise                                  ;/
.endif

;- - - construct ETHERNET header...
 mov  r0,r5  ;MemBlk                    ;\
 mov  r1,+14                            ; add 14 bytes at start for the header
 bl   sgIP_memblock_exposeheader        ;/
 ldr  r7,[r5,sgMemBlk_datastart]                        ;-get ptr to EthHdr
 add  r0,r4,sgHubHwi_hwaddr                        ;src ;\
 add  r1,r7,sgEthHdr_src_mac                       ;dst ; src_mac = hwaddr
 bl   arm9_Wifi_CopyMacAddr                             ;/
 ldr  r0,=const_FFFFFFFFFFFFh                      ;src ;\
 add  r1,r7,sgEthHdr_dest_mac                      ;dst ; dest_mac = broadcast
 bl   arm9_Wifi_CopyMacAddr                             ;/
 ldr  r0,=PROTOCOL_ETHER_ARP                            ;\protocol ARP
 strh r0,[r7,sgEthHdr_protocol]                         ;/
;- - - send ethernet packet...

       ;ldr r1,=XXXX_tx_log_request     ;XNAY
       ;mov r0,1
       ;str r0,[r1]

 mov  r0,r4  ;HubHwi            ;\
 mov  r1,r5  ;MemBlk            ; send (this function will free the
 bl   sgIP_Hub_SendRawPacket    ; memory block when it's done)
 b    @@return_r0               ;/
;---
@@fail:
 mov  r0,0   ;fail
@@return_r0:
 mov  r4,r0  ;return value
 mov  r0,r8                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r4  ;return value
 pop  r4-r8,pc
;------------------
sgIP_ARP_SendARPRequest:  ;in: r0=HubHwi, r1=protocol, r2=protocol_addr, out: r0
 push r4-r9,lr

        bl want_irq_off

 mov  r7,r2  ;protocol_addr             ;\memorize params
 mov  r6,r1  ;protocol                  ;/
 movs r4,r0  ;HubHwi                    ;\reject if hw=0
 beq  @@fail                            ;/
 ldrh r0,[r4,sgHubHwi_hwaddrlen]        ;\
 mov  r0,r0,lsl 1   ;mul2               ;
 add  r0,SGIP_HEADER_ARP_BASESIZE+2*4   ; alloc mem
.if with_arp_padding
        mov r0,sgArpHdr_size
.endif
 bl   sgIP_memblock_alloc               ;
 movs r5,r0  ;MemBlk                    ;
 beq  @@fail                            ;/
;- - - construct ARP packet...

       .if show_arp_info     ;XNAY
          bl wrcrlf
          mov  r0,12h // bl wrchr_r0
          mov  r0,'A' // bl wrchr_r0
          mov  r0,'R' // bl wrchr_r0
          mov  r0,'P' // bl wrchr_r0
          mov  r0,11h // bl wrchr_r0
          mov  r0,'S' // bl wrchr_r0
          mov  r0,'E' // bl wrchr_r0
          mov  r0,'N' // bl wrchr_r0
          mov  r0,'D' // bl wrchr_r0
          mov  r0,'R' // bl wrchr_r0
          mov  r0,'E' // bl wrchr_r0
          mov  r0,'Q' // bl wrchr_r0
          mov  r0,12h // bl wrchr_r0

          mov  r0,10h // bl wrchr_r0
       .endif

 ldr  r8,[r5,sgMemBlk_datastart]                        ;-get ptr to ArpHdr
 strh r6,[r8,sgArpHdr_protocol]                         ;-protocol (incoming r1)
 mov  r0,HWSPACE_ETHERNET                               ;\hwspace (ethernet)
 strh r0,[r8,sgArpHdr_hwspace]                          ;/
 mov  r0,ARP_OPCODE_REQUEST                             ;\opcode (request)
 strh r0,[r8,sgArpHdr_opcode]                           ;/
 ldrh r0,[r4,sgHubHwi_hwaddrlen]  ;16bit (unlike below) ;\hw_addr_len (6)
 strb r0,[r8,sgArpHdr_hw_addr_len] ;8bit (unlike above) ;/
 mov  r0,04h                                            ;\protocol_addr_len
 strb r0,[r8,sgArpHdr_protocol_addr_len]                ;/
 add  r1,r8,sgArpHdr_addresses                     ;dst ;-dest (for below 4 addr's)
 add  r0,r4,sgHubHwi_hwaddr                        ;src ;\
 ldrh r2,[r4,sgHubHwi_hwaddrlen]                   ;len ; addr(0) = hwaddr
 bl   memcopy_bytewise                                  ;/
 add  r0,r4,sgHubHwi_ipaddr                        ;src ;\
 mov  r2,4                                         ;len ; addr(1) = ipaddr
 bl   memcopy_bytewise                                  ;/
 mov  r0,00h                                       ;fil ;\
 ldrh r2,[r4,sgHubHwi_hwaddrlen]                   ;len ; addr(2) = ZERO
 bl   memfill_bytewise                                  ;/
 mov  r0,r7   ;protocol_addr (incoming r2)         ;val ;\addr(3) = protocol_addr
 bl   str_32bit_r0_to_r1                                ;/
.if with_arp_padding
 mov  r0,00h                                       ;fil ;\
 add  r1,r8,sgArpHdr_padding                       ;dst ;
 mov  r2,18                                        ;len ;
 bl   memfill_bytewise                                  ;/
.endif

;- - - construct ETHERNET header...
 mov  r0,r5  ;MemBlk                    ;\
 mov  r1,+14                            ; add 14 bytes at start for the header
 bl   sgIP_memblock_exposeheader        ;/
 ldr  r9,[r5,sgMemBlk_datastart]                        ;-get ptr to EthHdr
 add  r0,r4,sgHubHwi_hwaddr                        ;src ;\
 add  r1,r9,sgEthHdr_src_mac                       ;dst ; src_mac = hwaddr
 bl   arm9_Wifi_CopyMacAddr                             ;/
 ldr  r0,=const_FFFFFFFFFFFFh                      ;src ;\
 add  r1,r9,sgEthHdr_dest_mac                      ;dst ; dest_mac = broadcast
 bl   arm9_Wifi_CopyMacAddr                             ;/
 ldr  r0,=PROTOCOL_ETHER_ARP                            ;\protocol ARP
 strh r0,[r9,sgEthHdr_protocol]                         ;/
;- - - send ethernet packet...
 mov  r0,r4  ;HubHwi            ;\
 mov  r1,r5  ;MemBlk            ; send (this function will free the
 bl   sgIP_Hub_SendRawPacket    ; memory block when it's done)
 b    @@return_r0               ;/
;---
@@fail:
 mov  r0,0  ;fail
@@return_r0:
 pop  r4-r9,pc
;------------------
.pool
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_DHCP.c
;------------------
.data?
DHCP_HOSTNAME_SIZE equ 64
 dhcp_socket         dd 0       ;
 dhcp_tid            dd 0       ;
 dhcp_hostname:      defs DHCP_HOSTNAME_SIZE    ;hostname
 dhcp_timestart      dd 0       ;time.start
 dhcp_timelastaction dd 0       ;time.recent.transaction
 dhcp_int            dd 0       ;HubHwi
;dhcp_p              dd 0       ;DhcpPkt
;dhcp_optionptr      dd 0       ;
 dhcp_requestDNS     dd 0       ;
 dhcp_status         dd 0       ;
 dhcp_state          dd 0       ;state (0=send DHCPDISCOVER wait for DHCPOFFER, 1=send DHCPREQUEST wait for DHCPACK)
 dhcp_rcvd_ip        dd 0       ;IP           ;\info received via DHCP
 dhcp_rcvd_gateway   dd 0       ;gateway      ; (will be applied to HubHwi
 dhcp_rcvd_snmask    dd 0       ;subnet mask  ; once when DHCP is finished)
 dhcp_rcvd_dns       dd 0,0,0   ;dns[3]       ;/
 dhcp_serverip       dd 0       ;serverIP
.code
;------------------
sgIP_DHCP_Init:  ;in/out: none
 mov  r0,0                                      ;\
;ldr  r1,=dhcp_p       // str  r0,[r1]          ;
 ldr  r1,=dhcp_socket  // str  r0,[r1]          ; clear stuff
 ldr  r1,=dhcp_int     // str  r0,[r1]          ;
 ldr  r1,=dhcp_rcvd_ip // str  r0,[r1]          ;/
 ldr  r1,=dhcp_status                           ;\
 mov  r0,SGIP_DHCP_STATUS_IDLE                  ; mark idle
 str  r0,[r1]                                   ;/
 ldr  r0,=SGIP_DHCP_DEFAULTHOSTNAME        ;src ;\
 ldr  r1,=dhcp_hostname                    ;dst ; init hostname ("sethostname")
 b    copy_asciz       ;--> and exit            ;/
;------------------
sgIP_DHCP_CreateAndSendDgram:  ;in: r0=dgramtype, out: none
;note: original code did have this split into two functions:
;  "sgIP_DHCP_BeginDgram" and "sgIP_DHCP_SendDgram"
;that would have allowed it to insert extra options between the two
;function calls (the code didn't actually do that), or to modify some
;settings between the calls (that was done for "ciaddr=ipaddr" upon
;RELEASE, and that's done automatically in below code).
;anyways, having the two functions merged into a single function is nicer.
;- - -
 push r4-r7,lr
 sub  sp,sgSoin_size            ;\alloc sockaddr
 mov  r7,sp                     ;/
 mov  r4,r0  ;dgramtype         ;-memorize dgramtype (DHCP_TYPE_xxx)
;ldr  r0,=dhcp_p                ;\
;ldr  r0,[r0]                   ; dealloc old dhcp packet buf (if any)
;cmp  r0,0                      ; BLAH: should never happen
;blne sgIP_free                 ;/
 mov  r0,sgDhcpPkt_size         ;\
 bl   sgIP_malloc               ; alloc new dhcp packet buf
 movs r5,r0    ;DhcpPkt         ;
 beq  @@malloc_failed           ;
;ldr  r1,=dhcp_p  ;\memorize    ;
;str  r0,[r1]     ;/            ;/
;mov  r0,r0/r5  ;DhcpPkt        ;\
 mov  r1,sgDhcpPkt_size         ; initially zerofill whole packet
 bl   zerofill_bytewise         ;/
 ldr  r6,=dhcp_int              ;\get HubHwi
 ldr  r6,[r6]                   ;/
;- - - init DHCP Packet header...
 mov  r0,01h  // strb r0,[r5,sgDhcpPkt_op]    ;01h=BOOTREQUEST
 mov  r0,01h  // strb r0,[r5,sgDhcpPkt_htype] ;01h=ethernet address type
 mov  r0,06h  // strb r0,[r5,sgDhcpPkt_hlen]    ;-hardware address length (6)
;mov  r0,00h  // strb r0,[r5,sgDhcpPkt_hops]    ;-client sets this to zero (0)
 ldr  r0,=dhcp_tid                              ;\DHCP transaction ID
 ldr  r0,[r0] // str  r0,[r5,sgDhcpPkt_xid]     ;/
 ldr  r0,=sgIP_timems                           ;\
 ldr  r0,[r0]                                   ;
 ldr  r1,=dhcp_timestart                        ;
 ldr  r1,[r1]                                   ; seconds since DHCP start
 sub  r0,r1   ;time-start                       ; bugfix 2018: use SWI div
 mov  r1,1000                                   ;     (not SWI sqrt, oops)
 swi  swi_div                                   ;
   ;XXX should make BIG-ENDIAN ?
   bl   htons    ;<-- better so?!!
 strh r0,[r5,sgDhcpPkt_secs]                    ;/
;mov  r0,0000h                                  ;\flags (top bit set would
;bl   htons                                     ; request broadcast response)
;strh r0,[r5,sgDhcpPkt_flags]                   ;/

        mov  r0,0 ;8000h
        bl   htons
        strh r0,[r5,sgDhcpPkt_flags]


;mov  r0,0                                      ;\
;str  r0,[r5,sgDhcpPkt_ciaddr]  ;CI addr client ;
;str  r0,[r5,sgDhcpPkt_yiaddr]  ;YI addr your   ; init addr's
;str  r0,[r5,sgDhcpPkt_siaddr]  ;SI addr server ; normally all kept zero (0)
;str  r0,[r5,sgDhcpPkt_giaddr]  ;GI addr gateway; expect CI addr for RELEASE
 cmp   r4,DHCP_TYPE_RELEASE  ;dgramtype         ;
 ldreq r0,[r6,sgHubHwi_ipaddr]  ;\CI addr       ;  ;<-- done here automatically
 streq r0,[r5,sgDhcpPkt_ciaddr] ;/              ;/ ;(unlike as in original code)
 add  r0,r6,sgHubHwi_hwaddr   ;src              ;\
 add  r1,r5,sgDhcpPkt_chaddr  ;dst              ; chaddr (copy 6 bytes, and
 bl   arm9_Wifi_CopyMacAddr                     ;/leave remaining bytes zero)
;str   ZERO,[r5,sgDhcpPkt_sname+(0..N)]         ;\leave server name and file
;str   ZERO,[r5,sgDhcpPkt_file+(0..N)]          ;/zerofilled
;- - - add header/id and some necessary options...
 add  r1,r5,sgDhcpPkt_options   ;dst ;dhcp_optionptr
 ldr  r0,=63538263h ;=63h,82h,53h,63h   ;\4-byte "magic cookie" (bleh!)
 bl   str_32bit_r0_to_r1                ;/
 mov  r0,35h // strb r0,[r1],1 ;token   ;\
 mov  r0,01h // strb r0,[r1],1 ;len(1)  ; DHCP Message type (DHCP_TYPE_xxx)
 strb r4,[r1],1             ;dgramtype  ;/
 mov  r0,3Dh // strb r0,[r1],1 ;token   ;\
 mov  r0,07h // strb r0,[r1],1 ;len(1+6); DHCP client identifier
 mov  r0,01h // strb r0,[r1],1 ;hw type ;  (not really needed)
 add  r0,r6,sgHubHwi_hwaddr ;src ;\hw   ;
 bl   arm9_Wifi_CopyMacAddr      ;/addr ;/
 mov  r0,0Ch // strb r0,[r1],1          ;\
 ldr  r0,=dhcp_hostname       ;src ;\   ;
 push r0-r1                        ;    ; DHCP host name (NintendoDS)
 bl   get_strlen                   ;    ;  (not really needed)
 mov  r2,r0                   ;len ;    ;
 pop  r0-r1                        ;/   ;
 strb r2,[r1],1                ;strlen  ;
;mov  r0,r0              ;src ;\        ;
;mov  r2,r2              ;len ; name    ;
 bl   memcopy_bytewise        ;/        ;/
 mov  r0,37h // strb r0,[r1],1 ;token   ;\
 ldr  r0,=dhcp_requestDNS   ;\          ;
 ldr  r0,[r0]  ;flag (0..1) ; flag      ; DHCP Parameter request list
 cmp  r0,0     ;flag (0..1) ;/   ;-->zf ;
 add  r0,2 // strb r0,[r1],1 ;len(2..3) ;
 mov  r0,01h // strb r0,[r1],1          ;   ;<-- request subnet mask
 mov  r0,03h // strb r0,[r1],1          ;   ;<-- request router
 mov  r0,06h // strneb r0,[r1],1 ;<--zf ;/  ;<-- request dns server (optionally)
 cmp  r4,DHCP_TYPE_REQUEST  ;dgramtype  ;\
 bne  @@skip_ip_request                 ;
 mov  r0,32h // strb r0,[r1],1 ;token   ; ;\
 mov  r0,04h // strb r0,[r1],1 ;len(4)  ; ; DHCP Requested IP address
 ldr  r0,=dhcp_rcvd_ip     ;\           ; ;
 ldr  r0,[r0]              ; rcvd'IP    ; ;
 bl   str_32bit_r0_to_r1   ;/           ; ;/
 mov  r0,36h // strb r0,[r1],1 ;token   ; ;\
 mov  r0,04h // strb r0,[r1],1 ;len(4)  ; ; DHCP Server identifier
 ldr  r0,=dhcp_serverip    ;\           ; ;
 ldr  r0,[r0]              ; server'IP  ; ;
 bl   str_32bit_r0_to_r1   ;/           ; ;/
@@skip_ip_request:                      ;/
 mov  r0,3Ch // strb r0,[r1],1 ;token   ;\
 ldr  r0,=SGIP_DHCP_CLASSNAME ;src ;\   ;
 push r0-r1                        ;    ; DHCP Vendor Class ID
 bl   get_strlen                   ;    ;  (not really needed)
 mov  r2,r0                   ;len ;    ;
 pop  r0-r1                        ;/   ;
 strb r2,[r1],1                ;strlen  ;
;mov  r0,r0              ;src ;\        ;
;mov  r2,r2              ;len ; name    ;
 bl   memcopy_bytewise        ;/        ;/
 ;- - -
 ;(original code did EXIT here, and do below stuff in "sgIP_DHCP_SendDgram")
 ;- - -
 mov  r0,0ffh // strb r0,[r1],1 ;end    ;-terminate options list
 sub  r2,r1,r5 ;len DhcpPkt+options     ;\

       ;;; mov r0,r2 // bl wrdecimal // bl wrspc ;XNAY (280=discover, 292=next)

 cmp   r2,300     ;\force len MIN 300   ; len of DhcpPkt (plus options)
 movlo r2,300     ;/uh, WHY that FUCK?  ;/     XXXX? (300 = 12Ch)

 mov  r0,DHCP_BOOTP_SERVER              ;\sockaddr port = bootp server port
 strh r0,[r7,sgSoin_sin_port]           ;/
 mov  r0,0FFFFFFFFh                     ;\sockaddr addr = broadcast
 str  r0,[r7,sgSoin_sin_addr]           ;/
 push r4-r5  ;--->                              ;\
 ldr  r0,=dhcp_socket    ;\socket               ;
 ldr  r0,[r0]            ;/                     ;
 mov  r1,r5     ;DhcpPkt ;\DhcpPkt & size       ;
;mov  r2,r2     ;len     ;/                     ; send the DHCP packet
 mov  r3,0      ;flags   ;-flags                ;
 mov  r4,r7     ;sgSoin  ;\sockaddr & size      ;
 mov  r5,sgSoin_size     ;/                     ;
 bl   sendto                                    ;
 pop  r4-r5  ;<---                              ;/
 ldr  r0,=sgIP_timems                           ;\
 ldr  r0,[r0]                                   ; memorize most recent
 ldr  r1,=dhcp_timelastaction                   ; DHCP transaction time
 str  r0,[r1]                                   ;/
 mov  r0,r5     ;DhcpPkt                        ;\
 bl   sgIP_free                                 ; dealloc packet
;ldr  r1,=dhcp_p        ;\                      ;
;mov  r0,0              ; mark deallocated      ;
;str  r0,[r1]           ;/                      ;/
@@malloc_failed:
 add  sp,sgSoin_size                            ;-dealloc sockaddr (r7)
 pop  r4-r7,pc
;------------------
sgIP_DHCP_Start:  ;in: r0=HubHwi, r1=getDNS, out: none  ;begin dhcp transaction to get IP and maybe DNS data.
 push r4-r6,lr
 sub  sp,sgSoin_size            ;\alloc sockaddr
 mov  r6,sp                     ;/
 mov  r4,r0   ;HubHwi
 mov  r5,r1   ;getDNS
;SGIP_DEBUG_MESSAGE(("sgIP_DHCP_Start()"));
 bl   sgIP_DHCP_Terminate                       ;-Terminate
 ldr  r1,=dhcp_int          ;\HubHwi            ;\
 str  r4,[r1]               ;/                  ; apply hardware interface
 ldr  r1,=dhcp_requestDNS   ;\getDNS            ; and getDNS flag
 str  r5,[r1]               ;/(0 or 1)          ;/
 ldr  r1,=sgIP_timems           ;\get time      ;\
 ldr  r0,[r1]                   ;/              ; memorize start time
 ldr  r1,=dhcp_timestart        ;\start time    ;   (and initially set recent
 str  r0,[r1]                   ;/              ; access time to same value)
 ldr  r1,=dhcp_timelastaction   ;\recent access ;   (and also use the value as
 str  r0,[r1]                   ;/              ; "random" DHCP transaction ID)
 ldr  r1,=dhcp_tid              ;\transact id   ;
 str  r0,[r1]                   ;/              ;/
 ldr  r1,=dhcp_status                           ;\
 mov  r0,SGIP_DHCP_STATUS_WORKING               ; status = WORKING (aka BUSY)
 str  r0,[r1]                                   ;/
 mov  r0,0                                              ;\
 ldr  r1,=dhcp_state        // str r0,[r1] ;state       ;
 ldr  r1,=dhcp_rcvd_ip      // str r0,[r1] ;ip          ;
 ldr  r1,=dhcp_rcvd_gateway // str r0,[r1] ;gateway     ; clear stuff
 ldr  r1,=dhcp_rcvd_snmask  // str r0,[r1] ;gateway     ;
 ldr  r1,=dhcp_rcvd_dns+0   // str r0,[r1] ;dns(0)      ;
 ldr  r1,=dhcp_rcvd_dns+4   // str r0,[r1] ;dns(1)      ;
 ldr  r1,=dhcp_rcvd_dns+8   // str r0,[r1] ;dns(2)      ;/
 mov  r0,DHCP_BOOTP_CLIENT              ;\sockaddr bootp client port
 strh r0,[r6,sgSoin_sin_port]           ;/
 mov  r0,00000000h                      ;\sockaddr addr=0
 str  r0,[r6,sgSoin_sin_addr]           ;/
 mov  r0,AF_INET                        ;\
 mov  r1,SOCK_DGRAM                     ;
 mov  r2,0                              ; socket
 bl   socket                            ;
 ldr  r1,=dhcp_socket                   ;
 str  r0,[r1]                           ;/
;mov  r0,r0               ;socket       ;\
 mov  r1,r6               ;sgSoin       ; bind
 mov  r2,sgSoin_size      ;sgSoin_size  ;
 bl   bind                              ;/
 ldr  r1,=dhcp_socket                   ;\
 ldr  r0,[r1]             ;socket       ;
 mov  r1,FIONBIO          ;FIO          ; ioctl
 sub  sp,4    ;ptr_to_1 alloc    ;-->   ;
 mov  r2,00000001h                      ;
 str  r2,[sp] ;ptr_to_1 init            ;
 mov  r2,sp   ;ptr_to_1 ptr             ;
 bl   ioctl                             ;
 add  sp,4    ;ptr_to_1 dealloc  ;<--   ;
;mov  N/A,r0                            ;/

            ;ldr r1,=XXXX_tx_log_request   ;XNAY
            ;mov r0,1
            ;str r0,[r1]
                ldr  r1,=txt_dhcp_discover
                bl   wrstr_r1

 mov  r0,DHCP_TYPE_DISCOVER             ;\send Dgram
 bl   sgIP_DHCP_CreateAndSendDgram      ;/

;;;;;;;mov r0,100000h // swi  03h shl 16   ;WaitByLoop   ;XNAY

 add  sp,sgSoin_size            ;-dealloc sockaddr (r6)
 pop  r4-r6,pc
;---
                txt_dhcp_discover   db 'DHCP Discover',0dh,0
                txt_dhcp_request    db 'DHCP Request',0dh,0
                txt_dhcp_retry      db 'DHCP Retry',0dh,0
                txt_dhcp_release    db 'DHCP Release',0dh,0
                .align 4
;------------------
sgIP_DHCP_Release:  ;in/out: none    ;call to dump our DHCP address and leave
 ldr  r0,=dhcp_status                   ;\
 ldr  r0,[r0]                           ; if status=working (aka busy)
 cmp  r0,SGIP_DHCP_STATUS_WORKING       ; then redirect to TERMINATE
 beq  sgIP_DHCP_Terminate    ;-->       ;/
                ldr  r1,=txt_dhcp_release
                bl   wrstr_r1
 mov  r0,DHCP_TYPE_RELEASE              ;\else issue Dgram(RELEASE)
 b    sgIP_DHCP_CreateAndSendDgram      ;/
;------------------
sgIP_DHCP_Update:  ;in: none, out: r0   ;MUST be called periodicly; returns status - call until it returns SGIP_DHCP_STATUS_SUCCESS or _FAILED.
 push r4-r8,lr
 sub  sp,sgSoin_size            ;\alloc sockaddr
 mov  r4,sp                     ;/
 sub  sp,4                      ;\alloc dummy_ptr
 mov  r5,sp                     ;/
 ldr  r1,=dhcp_status                           ;\exit if status
 ldr  r0,[r1]                                   ; isn't WORKING (aka BUSY)
 cmp  r0,SGIP_DHCP_STATUS_WORKING               ; ie. process below only if busy
 bne  @@done_return_status_r0 ;out: r0=old stat ;/
 mov  r0,sgDhcpPkt_size                         ;\
 bl   sgIP_malloc                               ; allocate packet
 movs r8,r0  ;DhcpPkt                           ;
 beq  @@alloc_failed                            ;/

        ;XXX comes here often
        ;bl wrdot

        mov  r0,sgSoin_size  ;\XXX try so for recvfrom...
        str  r0,[r5]         ;/    doesn't help on faster dhcp

@@recv_lop:
 ldr  r0,=dhcp_socket   ;\socket                ;\
 ldr  r0,[r0]           ;/                      ;
 mov  r1,r8  ;DhcpPkt   ;\packet & size         ;
 mov  r2,sgDhcpPkt_size ;/                      ;
 mov  r3,0              ;-flags                 ;
;mov  r4,r4 ;sockaddr   ;\sockaddr & size_ptr   ;
;mov  r5,r5 ;dummy_ptr  ;/                      ;
 bl   recvfrom                                  ;
 mov  r6,r0    ;recv.length (with option_len)   ;/
 cmp  r6,-1                                     ;\leave if nothing received
 beq  @@leave_recv_lop                          ;/(fritzbox sends 132h bytes)

        ;XXX comes here rarely (after some long time)
        ;bl wrhex16bit  ;recv.len (fritzbox sends 132h bytes)
        ;bl wrdot

       .if 0       ;XNAY
        mov r0,'D' // bl wrchr_r0
        mov r0,'H' // bl wrchr_r0
        mov r0,'C' // bl wrchr_r0
        mov r0,'P' // bl wrchr_r0
       .endif

 ldrb r0,[r8,sgDhcpPkt_op]                      ;\
 ldrb r1,[r8,sgDhcpPkt_htype]                   ;
 ldrb r2,[r8,sgDhcpPkt_hlen]                    ; check if the received packet
 ldr  r3,[r8,sgDhcpPkt_xid]                     ; contains the desired stuff,
 cmp   r0,02h    ;op (2=BOOTREPLY)              ; if not, then
 cmpeq r1,01h    ;htype                         ; try to receive ANOTHER packet
 cmpeq r2,06h    ;hlen                          ; (if any present)
 ldreq r0,=dhcp_tid   ;\tid                     ;
 ldreq r0,[r0]        ;/                        ;
 cmpeq r3,r0     ;xid,tid (transact id)         ;
 bne  @@recv_lop      ;--> try recv another one ;/
 add  r1,r8,sgDhcpPkt_options                   ;-begin of options
 sub  r6,sgDhcpPkt_options ;RecvLen-OptionBegin ;-length of options
 subs r6,4     ;option_len                      ;\
 bmi  @@recv_lop                                ; 4-byte "magic cookie" (bleh!)
 bl   ldr_32bit_r0_from_r1                      ; (if not there, try recv
 ldr  r2,=63538263h ;=63h,82h,53h,63h           ; another packet)
 cmp  r0,r2                                     ;
 bne  @@recv_lop                                ;/
@@option_lop:
 cmp  r6,0     ;option_len                      ;\end if option_len<=0
 ble  @@option_end                              ;/
 ldrb r3,[r1],1                                 ;\get token
 sub  r6,1     ;option_len                      ;/
 cmp  r3,00h   ;0 decimal                       ;\token 00h: Ignore/nop
 beq  @@token_00h_nop                           ;/
 cmp  r3,0FFh  ;255 decimal                     ;\token FFh: End
 beq  @@token_FFh_end                           ;/
 ldrb r7,[r1],1  ;token_len                     ;\get num params (per token)
 sub  r6,1     ;option_len-1                    ;/
 subs r6,r7    ;option_len-token_len            ;\recv another if corrupt
 bmi  @@recv_lop                                ;/  (num params exceeds length)
 cmp  r3,35h   ;53 decimal                      ;\token 35h: MessageType
 beq  @@token_53h_msg_type                      ;/
 ldr  r0,=dhcp_state                      ;\
 ldr  r0,[r0]                             ;
 cmp  r0,0                                ; only if state=0,
 bne  @@skip_tokens_01h_03h_36h_06h       ;
 cmp  r7,4     ;token_len                 ;  ;\only if param = min 4-byes,
 blo  @@skip_tokens_01h_03h_36h           ;  ;
 cmp  r3,01h   ;1 decimal                 ;  ;  ;\token 01h: Subnet Mask
 beq  @@token_01h_subnet_mask             ;  ;  ;/
 cmp  r3,03h   ;3 decimal                 ;  ;  ;\token 03h: Gateway
 beq  @@token_03h_gateway                 ;  ;  ;/
 cmp  r3,36h   ;54 decimal                ;  ;  ;\token 36h: Server ID
 beq  @@token_36h_server_id               ;  ;  ;/
@@skip_tokens_01h_03h_36h:                ;  ;/
 ldr  r0,=dhcp_requestDNS                 ;  ;\
 ldr  r0,[r0]                             ;  ;
 cmp  r0,0                                ;  ; only if DNS requested,
 beq  @@skip_token_06h                    ;  ;
 cmp  r3,06h   ;6 decimal                 ;  ;  ;\token 06h: DNS Server(s)
 beq  @@token_06h_dns_servers             ;  ;  ;/
@@skip_token_06h:                         ;  ;/
@@skip_tokens_01h_03h_36h_06h:            ;/
@@token_done:
 add  r1,r7    ;ptr+token_len             ;-token XXh: skip param(s)
@@token_00h_nop:
 b    @@option_lop
;---
@@option_end:      ;<-- end via option_length (oops, is that valid?)
@@token_FFh_end:   ;<-- end via token FFh (properly terminated)
 ;note: end of STAGE 1 (REQUEST) is normally handled in "@@token_53h_msg_type"
 ;so, below code is normally executed ONLY at end of STAGE 0 (DISCOVER), but
 ;not at end of STAGE 1 (REQUEST). And, hoping that all required info was
 ;received during STAGE 0, we will now switch to STAGE 1...

       .if 0       ;XNAY
        mov r0,'*' // bl wrchr_r0
        mov r0,'*' // bl wrchr_r0
        mov r0,'*' // bl wrchr_r0
       .endif

 ldr  r0,[r8,sgDhcpPkt_yiaddr] ;YI addr ;\
 ldr  r1,=dhcp_rcvd_ip                  ; copy IP (from hdr, not from options)
 str  r0,[r1]                           ;/
 ldr  r1,=dhcp_state                    ;\enter STAGE 1 (switch to REQUEST,
 mov  r0,1                              ;               instead of DISCOVER)
 str  r0,[r1]                           ;/
               ldr  r1,=txt_dhcp_request
               bl   wrstr_r1

.if 01
 ldr  r0,=sgIP_timems                   ;\
 ldr  r0,[r0]                           ;
 ldr  r1,=dhcp_timestart                ;
 ldr  r1,[r1]                           ; increment transaction id
 sub  r2,r0,r1   ;time-start            ; (weirdly raised by "time-start+1",
 add  r2,1       ;time-start+1          ; dunno why, maybe just a random step?)
 ldr  r1,=dhcp_tid                      ;   (for next SEND+REPLY msg pair)
 ldr  r0,[r1]    ;transact id           ;
 add  r0,r2      ;raise by time-start+1 ;
 str  r0,[r1]    ;transact id           ;/
.endif

 movs r0,r8  ;DhcpPkt                   ;\dealloc packet
 bl   sgIP_free                         ;/
 b    @@send_next_step                  ;-do instant "RESEND" (for new stage)
;- - -
@@leave_recv_lop:
 movs r0,r8  ;DhcpPkt                   ;\dealloc packet
 bl   sgIP_free                         ;/
 ldr  r0,=sgIP_timems                   ;\
 ldr  r0,[r0]                           ; handle timeout's
 ldr  r1,=dhcp_timestart                ;  ;\
 ldr  r1,[r1]                           ;  ;
 sub  r2,r0,r1   ;time-start            ;  ; fatal timeout --> ERROR
 cmp  r2,SGIP_DHCP_ERRORTIMEOUT         ;  ;
 bhi  @@timeout_error                   ;  ;/
 ldr  r1,=dhcp_timelastaction           ;  ;\
 ldr  r1,[r1]                           ;  ;
 sub  r2,r0,r1   ;time-last             ;  ; retry timeout --> RESEND
 cmp  r2,SGIP_DHCP_RESENDTIMEOUT        ;  ;
 bhi  @@resend_retry                    ;/ ;/
;- - -
@@done_keep_status_working:             ;\done for now, but keep
 mov  r0,SGIP_DHCP_STATUS_WORKING       ;/status=WORKING (aka BUSY)
;- - -
@@done_return_status_r0:
 ldr  r1,=dhcp_status           ;\apply status, and ALSO return it in r0
 str  r0,[r1]                   ;/
 add  sp,4                      ;-dealloc dummy_ptr (r5)
 add  sp,sgSoin_size            ;-dealloc sockaddr (r4)
 pop  r4-r8,pc          ;out: r0=[dhcp_status]
;--- --- --- ---
@@token_01h_subnet_mask:
 bl   ldr_32bit_r0_from_r1                              ;\
 sub  r1,4 ;stepback (instead, raise via paramlen byte) ; subnet mask
 ldr  r2,=dhcp_rcvd_snmask                              ;
 str  r0,[r2]                                           ;/
 b    @@token_done
;---
@@token_03h_gateway:
 bl   ldr_32bit_r0_from_r1                              ;\
 sub  r1,4 ;stepback (instead, raise via paramlen byte) ; gateway
 ldr  r2,=dhcp_rcvd_gateway                             ;
 str  r0,[r2]                                           ;/
 b    @@token_done
;---
@@token_36h_server_id:
 bl   ldr_32bit_r0_from_r1                              ;\
 sub  r1,4 ;stepback (instead, raise via paramlen byte) ; server ID
 ldr  r2,=dhcp_serverip                                 ;  uh, or IP ?
 str  r0,[r2]                                           ;/
 b    @@token_done
;---
@@token_06h_dns_servers:
 push r1 ;-->                                           ;\
 mov  r0,r1                     ;-src                   ;
 ldr  r1,=dhcp_rcvd_dns         ;-dst                   ; DNS[0..2]
 and  r2,r7,not 3 ;-align 4     ;\                      ; (max 3 words, if any)
 cmp  r2,4+4+4    ;\max 3 words ; token_len             ;
 movhi r2,4+4+4   ;/            ;/                      ;
 bl   memcopy_bytewise                                  ;
 pop  r1 ;<-- ;stepback(instead,raise via paramlen byte);/
 b    @@token_done
;---
@@token_53h_msg_type:
 cmp  r6,1   ;option_len                                ;\min 1-byte (for type)
 blo  @@recv_lop  ;unexcpected --> try recv another     ;/
 ldr  r0,=dhcp_state                                    ;\
 ldr  r0,[r0]                                           ;
 cmp  r0,0                                              ; verify excepted type
 moveq r0,DHCP_TYPE_OFFER  ;for state=0                 ; (if corrupt/unexpected
 movne r0,DHCP_TYPE_ACK    ;for state=1                 ; then try recv another
 ldrb r2,[r1]              ;<-- get type (from options) ; packet)
 cmp  r2,r0                                             ;
 bne  @@recv_lop  ;unexcpected --> try recv another     ;/
 ldr  r0,=dhcp_state                                    ;\for STATE=0,
 ldr  r0,[r0]                                           ; just go on processing
 cmp  r0,0                                              ; further tokens
 beq  @@token_done                                      ;/
;- - - for STATE=1, we are DONE now, so clean up & apply received info...
 movs r0,r8  ;DhcpPkt                   ;\dealloc packet
 bl   sgIP_free                         ;/
 bl   sgIP_DHCP_Terminate               ;-terminate
;SGIP_DEBUG_MESSAGE(("DHCP Configured!"));
;SGIP_DEBUG_MESSAGE(("IP%08X SM%08X GW%08X",dhcp_rcvd_ip,dhcp_rcvd_snmask,dhcp_rcvd_gateway));
 ldr  r1,=dhcp_int                      ;\get HubHwi
 ldr  r1,[r1]                           ;/
 ldr  r0,=dhcp_rcvd_ip                  ;\
 ldr  r0,[r0]                           ; apply IP
 str  r0,[r1,sgHubHwi_ipaddr]           ;/
 ldr  r0,=dhcp_rcvd_gateway             ;\
 ldr  r0,[r0]                           ; apply gateway
 str  r0,[r1,sgHubHwi_gateway]          ;/
 ldr  r0,=dhcp_rcvd_snmask              ;\
 ldr  r0,[r0]                           ; apply subnet
 str  r0,[r1,sgHubHwi_snmask]           ;/
 ldr  r0,=dhcp_requestDNS               ;\
 ldr  r0,[r0]                           ;
 cmp  r0,0                              ; if DNS was requested,
 beq  @@skip_dns                        ;
 ldr  r0,=dhcp_rcvd_dns            ;src ; ;\
 add  r1,r1,sgHubHwi_dns           ;dst ; ; apply DNS[0..2]
 mov  r2,4+4+4                     ;len ; ;
 bl   memcopy_bytewise                  ; ;/
;SGIP_DEBUG_MESSAGE(("DNS %08X %08X %08X",dhcp_rcvd_dns[0],dhcp_rcvd_dns[1],dhcp_rcvd_dns[2]));
@@skip_dns:                             ;/
 mov  r0,SGIP_DHCP_STATUS_SUCCESS       ;\done & finished !
 b    @@done_return_status_r0           ;/
;--- --- --- ---
@@resend_retry:
               ldr  r1,=txt_dhcp_retry
               bl   wrstr_r1

       .if 0       ;XNAY
        mov r0,'R' // bl wrchr_r0
        mov r0,'E' // bl wrchr_r0
       .endif

;- - -
@@send_next_step:
 ldr  r0,=dhcp_state                            ;\
 ldr  r0,[r0]                  ;state           ; resend another Dgram
 cmp  r0,0                                      ; (done either upon retry, or
 moveq r0,DHCP_TYPE_DISCOVER   ;for state=0     ; upon "dhcp_state" changes)
 movne r0,DHCP_TYPE_REQUEST    ;for state=1     ;
 bl    sgIP_DHCP_CreateAndSendDgram             ;/
 b     @@done_keep_status_working               ;-done for now (but keep busy)
;---
@@alloc_failed:
;SGIP_DEBUG_MESSAGE(("sgIP DHCP alloc failed!"));
 bl   sgIP_DHCP_Terminate                       ;-terminate
 mov  r0,SGIP_DHCP_STATUS_FAILED                ;\failed
 b    @@done_return_status_r0                   ;/
;---
@@timeout_error:
;SGIP_DEBUG_MESSAGE(("sgIP DHCP error timeout!"));
 bl   sgIP_DHCP_Terminate                       ;-terminate
 mov  r0,SGIP_DHCP_STATUS_FAILED                ;\failed
 b    @@done_return_status_r0                   ;/
;------------------
sgIP_DHCP_Terminate:  ;in/out: none  ;kill the process where it stands; deallocate all DHCP resources.
 push lr
 ldr  r1,=dhcp_socket           ;\      ;\
 ldr  r0,[r1]                   ; close ;
 cmp  r0,0                      ;       ; close socket (if any)
 blne closesocket  ;in: r0      ;/      ;
 ldr  r1,=dhcp_socket           ;\      ;
 mov  r0,0                      ; mark  ;
 str  r0,[r1]                   ;/      ;/
;ldr  r1,=dhcp_p                ;\      ;\
;ldr  r0,[r1]                   ; free  ;
;cmp  r0,0                      ;       ; dealloc (if any)
;blne sgIP_free    ;in: r0      ;/      ; BLAH: should never happen
;ldr  r1,=dhcp_p                ;\      ;
;mov  r0,0                      ; mark  ;
;str  r0,[r1]                   ;/      ;/
 ldr  r1,=dhcp_status                   ;\
 mov  r0,SGIP_DHCP_STATUS_IDLE          ; set status IDLE
 str  r0,[r1]                           ;/
 pop  pc
;------------------
.if with_dns
gethostname:  ;in: r0=name.dest, r1=len.max, out: r0
 push lr
 cmp  r0,0  ;name.dest                  ;\want bufdest nonzero
 beq  @@error_fault                     ;/
 cmp  r1,DHCP_HOSTNAME_SIZE+1           ;\want bufsiz min "SIZ+1"
 ble  @@error_incoming_value            ;/
 mov  r2,00h                            ;\append 00h at buf[SIZ](in case name
 strb r2,[r0,DHCP_HOSTNAME_SIZE]        ;/occupies the whole buf[0..SIZ-1])
 mov  r1,r0  ;name.dest         ;dst    ;\
 ldr  r0,=dhcp_hostname         ;src    ;
 mov  r2,DHCP_HOSTNAME_SIZE     ;max    ;
 bl   copy_asciz_with_len_limit         ;/
 mov  r0,0   ;okay
@@return_r0:
 pop  pc
;---
@@error_incoming_value:
 bl   sgIP_error_inval
 b    @@return_r0
;---
@@error_fault:
 bl   sgIP_error_fault
 b    @@return_r0
.endif
;------------------
.if with_dns
sethostname:  ;in: r0=name, r1=len, out: r0
 push r4-r6,lr
 movs r4,r0  ;name              ;\
 beq  @@error_fault             ;/
 mov  r5,r1  ;len               ;\
 cmp  r5,DHCP_HOSTNAME_SIZE-1   ; want len max "SIZ-1" (uh, why minus 1 here?)
 bhi  @@error_incoming_value    ;/                     (elsewhere it's plus 1)
 ldr  r0,=dhcp_hostname   ;old name     ;\
 bl   sgIP_DNS_FindDNSRecord            ; find DNS record for OLD hostname
 mov  r6,r0  ;sgDnsRec                  ;/
 ldr  r1,=dhcp_hostname            ;dst ;\
 mov  r0,r4  ;new name             ;src ; copy NEW name to DHCP "hostname"
 mov  r2,r5  ;len                  ;len ;
 bl   copy_asciz_with_len_limit   ;copy ;
 mov  r0,0      ;\attach eol            ;
 strb r0,[r1],1 ;/(if needed)           ;/
 cmp  r6,0                              ;\skip below if DNS record not found
 beq  @@skip_dns_entries                ;/  ;BUGGED: original code didn't skip
 add  r1,r6,sgDnsRec_aliases+0     ;dst ;\
 mov  r0,r4  ;new name             ;src ; copy NEW name to DNS record Aliases[0]
 mov  r2,r5  ;len                  ;len ;
 bl   copy_asciz_with_len_limit   ;copy ;
 mov  r0,0      ;\attach eol            ;
 strb r0,[r1],1 ;/(if needed)           ;/
 add  r1,r6,sgDnsRec_name          ;dst ;\
 mov  r0,r4  ;new name             ;src ; copy NEW name to DNS record Name
 mov  r2,r5  ;len                  ;len ;
 bl   copy_asciz_with_len_limit   ;copy ;
 mov  r0,0      ;\attach eol            ;
 strb r0,[r1],1 ;/(if needed)           ;/
@@skip_dns_entries:
 mov  r0,0   ;okay
@@return_r0:
 pop  r4-r6,pc
;---
@@error_incoming_value:
 bl   sgIP_error_inval
 b    @@return_r0
;---
@@error_fault:
 bl   sgIP_error_fault
 b    @@return_r0
.endif
;------------------
;sgIP_DHCP_SetHostName:  ;in: r0=name, out: none
;BLAH: this function is UNUSED, and it's essentially SAME as "sethostname"
;(but without adjusting DNS Record entries, and without the variable len=r1
;parameter, and without return value)
;  strncpy(dhcp_hostname,s,63);
;  dhcp_hostname[63]=0;
;  return
;------------------
.if with_gimmicks
sgIP_DHCP_IsDhcpIp:  ;in: r0=ip, out: r0=flag  ;check if the IP address was assigned via DHCP
 ldr  r1,=dhcp_rcvd_ip
 ldr  r1,[r1]
 cmp  r1,r0
 moveq r0,1  ;return r0=1 (same)
 movne r0,0  ;return r0=0 (not same)
 bx   lr
.endif
;------------------
.pool
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_DNS.c
;------------------
.if with_dns
;------------------
.data?
 dns_sock           dd 0
 time_count         dd 0
 last_id            dd 0
 query_time_start   dd 0
 dnsrecord_return:  defs sgDnsRec_size                  ;\
 dnsrecord_hostent: defs sgDnsHst_size                  ;
 alias_list:        defs (SGIP_DNS_MAXALIASES+1)*4      ; data to return via hostent
 addr_list:         defs (SGIP_DNS_MAXRECORDADDRS+1)*4  ;
 ipaddr_alias:      defs 256  ;ipaddr_alias[256]        ;
 ipaddr_ip          dd 0      ;ipaddr_ip                ;/
 dnsrecords:    defs sgDnsRec_size*SGIP_DNS_MAXRECORDSCACHE ;-cache record data
 querydata:     defs 512      ;querydata[512]               ;\
 responsedata:  defs 512      ;responsedata[512]            ;/
.code
;------------------
sgIP_DNS_Init:  ;in/out: none
 ldr  r1,=dnsrecords                    ;\
 mov  r2,SGIP_DNS_MAXRECORDSCACHE       ;
 mov  r0,0                              ;
@@lop:                                  ; clear "flags" for all DNS records
 str  r0,[r1,sgDnsRec_flags]            ;
 add  r1,sgDnsRec_size  ;\              ;
 subs r2,1              ; lop next      ;
 bne  @@lop             ;/              ;/
;mov  r0,0                              ;\
 ldr  r1,=time_count                    ; time_count = 0
 str  r0,[r1]                           ;/
 mov  r0,-1                             ;\
 ldr  r1,=dns_sock                      ; dns_sock = -1
 str  r0,[r1]                           ;/
 bx   lr
;------------------
sgIP_DNS_Timer1000ms:  ;in/out: none
 ldr  r1,=time_count                    ;\
 ldr  r0,[r1]                           ; raise time_count (one second steps)
 add  r0,1                              ;
 str  r0,[r1]                           ;/
 ldr  r1,=dnsrecords                    ;\
 mov  r2,SGIP_DNS_MAXRECORDSCACHE       ;
@@lop:                                  ; process all DNS records...
 ldr  r0,[r1,sgDnsRec_flags]    ;\      ;
 tst  r0,SGIP_DNS_FLAG_RESOLVED ;       ; if FLAGS=resolved
 beq  @@lop_next                ;/      ; then decrease time-to-live
 ldr  r0,[r1,sgDnsRec_TTL]      ;\      ; and if reaching zero
 subs r0,1                      ;       ; then clear flags
 str  r0,[r1,sgDnsRec_TTL]      ;/      ;
;moveq r0,0                             ;
 streq r0,[r1,sgDnsRec_flags] ;=0       ;
@@lop_next:                             ;
 add  r1,sgDnsRec_size  ;\              ;
 subs r2,1              ; lop next      ;
 bne  @@lop             ;/              ;/
 bx   lr
;------------------
sgIP_DNS_isipaddress:  ;in: r0=name, r1=ipdest_ptr, out: r0
 ;check if sting is a numeric IP address, and, if so, return [ipdest_ptr]=IP
 ;if the function fails, then the string is probably a domain name (which
 ;must be resolved via a DNS record)
 ;- - -
 ;normal IP's are "A.B.C.D", but there are also some other valid notations:
 ;  A       (32bit)               -->  AAAAAAAAh
 ;  A.B     (8bit.24bit)          -->  BBAAAAAAh
 ;  A.B.C   (8bit.8bit.16bit)     -->  CCBBAAAAh
 ;  A.B.C.D (8bit.8bit.8bit.8bit) -->  DDCCBBAAh
 ;normal IP's are decimal, but below code does also support hex/octal, uh, why?
 ;- - -
 push r4-r6,lr
 mov  r4,0   ;initial value (sum)
 mov  r2,32  ;max width for current part
@@dot_lop:
 ldrb  r3,[r0]          ;\                      ;\
 sub   r3,'0'           ; want 0..9             ;
 cmp   r3,9             ;                       ; prefix for decimal/octal/hex
 bhi   @@error          ;/                      ;
 cmp   r3,0             ;\                      ; (uh, original code does that,
 movne r5,10  ;unit     ; decimal (1NNN..9NNN)  ; but it looks like nonsense,
 bne   @@this_base      ;/                      ; and treating leading zeroes as
 ldrb  r3,[r0,1]        ;\                      ; octal could be kind of fatal,
 orr   r3,20h  ;locase  ;                       ; eg. zeropadded "010" would be
 cmp   r3,'x'           ; hex (0xNNN)           ; treated as "8" decimal)
 moveq r5,16  ;unit     ;                       ;
 addeq r0,2 ;skip "0x"  ;                       ; (normal IPs should be decimal)
 beq   @@this_base      ;/                      ;
 mov   r5,8   ;unit     ;-octal (0NNN)          ;
@@this_base:                                    ;/
 ldrb  r3,[r0],1        ;-get 1st digit         ;\
  ;without hex/octal support, above prefix      ;
  ;check could be replaced by this:             ;
  ;  mov  r5,16 ;unit ;-base 10 (decimal)       ;
  ;  cmp  r3,'.'      ;\reject DOT or EOL       ;
  ;  bls  @@error     ;/as FIRST digit          ;
 mov   r6,0  ;part
@@digit_lop:            ;\                      ;
 cmp   r3,'a'           ;                       ;
 subhs r3,20h  ;upcase  ; convert ascii         ; process all digits
 cmp   r3,'A'           ; to numeric digit      ; of the current part
 subhs r3,7             ;                       ;
 sub   r3,'0'           ;/                      ;
 cmp   r3,r5  ;unit     ;\digit range           ;
 bhs   @@error          ;/                      ;
 mul   r3,r3,r5         ;\merge with            ;
;XXX cmp MUL_MSW,0 ;\multiply                   ;
;XXX bne @@error   ;/overflow                   ;
 add   r6,r3  ;part     ;/old digits            ;
 ldrb  r3,[r0],1        ;\                      ;
 cmp   r3,00h      ;\   ; lop next digit        ;
 beq   @@eol       ;/   ; (unless part ends,    ;
 cmp   r3,'.'      ;\   ; with DOT or EOL)      ;
 bne   @@digit_lop ;/   ;/                      ;/
;- - -
 cmp  r6,100h   ;\leading parts must be 8bit            ;\
 bhs  @@error   ;/                                      ; merge part with sum
 subs r2,8     ;max width for next part                 ; and loop next part
 beq  @@error  ;error if more than 4 parts              ;
 orr  r4,r4,r6,lsl r2  ;merge SUM with current part     ;
 b    @@dot_lop                                         ;/
;---
@@error:
 mov  r0,0      ;out: r0=0 (failed, not a numeric IP address)
 b    @@return_r0
;---
@@eol:
 movs r3,r4,lsr r2  ;\verify max width for last part
 bne  @@error       ;/
 orr  r4,r6         ;\merge last part with sum,
 str  r4,[r1]       ;/and store SUM at dest
 mov  r0,1      ;out: r0=1 (okay)
@@return_r0:
 pop  r4-r6,pc
;------------------
sgIP_DNS_FindDNSRecord:  ;in: r0=name, out: r0=DnsRec (or 0=not found)
 push r4-r8,lr
 mov  r5,r0                     ;-memorize name
 bl   sgIP_IntrProtect          ;\
;mov  r0,r0                     ;/
 ldr  r4,=dnsrecords ;curr.rec          ;\                                 ;\
 mov  r2,SGIP_DNS_MAXRECORDSCACHE       ; search DNS records...            ;
@@record_lop:                           ;/                                 ;
 ldr  r1,[r4,sgDnsRec_flags]            ;\                                 ;
 tst   r1,SGIP_DNS_FLAG_ACTIVE          ; want active AND resolved         ;
 tstne r1,SGIP_DNS_FLAG_RESOLVED        ;                                  ;
 beq   @@next_record                    ;/                                 ;
 ldr   r7,[r4,sgDnsRec_numalias] ;num aliases   ;\                      ;\ ;
 add   r6,r4,sgDnsRec_aliases+0  ;alias[0]      ;                       ;  ;
 cmp   r7,0          ;\skip if 0 aliases        ; scan alias(es)        ;  ;
 beq   @@next_record ;/                         ;                       ;  ;
@@alias_lop:                                    ;/                      ;  ;
 mov  r8,0        ;char_index                               ;\          ;  ;
@@char_lop:                                                 ;           ;  ;
 ldrb r1,[r5,r8]  ;next char for "name"                     ; compare   ;  ;
 ldrb r2,[r6,r8]  ;next char for "alias[N]"                 ; strings   ;  ;
 add  r8,1        ;char_index                               ; (non-case ;  ;
 sub  r3,r1,'a' // cmp  r3,26 // sublo r1,20h  ;upcase(r1)  ; sensitive);  ;
 sub  r3,r2,'a' // cmp  r3,26 // sublo r2,20h  ;upcase(r2)  ;           ;  ;
 orrs r3,r1,r2        ;\found if both char's are EOL's      ;           ;  ;
 beq  @@found_name    ;/                                    ;           ;  ;
 cmp  r1,r2           ;\lop next char (unless mismatch)     ;           ;  ;
 beq  @@char_lop      ;/                                    ;/          ;  ;
 add  r6,256   ;=sgDnsRec_aliases+N             ;\                      ;  ;
 subs r7,1                                      ; try next alias        ;  ;
 bne  @@alias_lop                               ;/                      ;/ ;
@@next_record:                                                             ;
 add  r4,sgDnsRec_size          ;\                                         ;
 subs r2,1                      ; lop next DNS record                      ;
 bne  @@record_lop              ;/                                         ;/
 mov  r4,0                      ;-not found, return zero                   ;-
@@found_name:   ;out: r4
;mov  r0,r0                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r4     ;out: r0=DnsRec (or 0=not found)
 pop  r4-r8,pc
;------------------
sgIP_DNS_GetUnusedRecord:  ;in: none, out: r0=DnsRec
 ;uh, using an idle-count would seem better than the TTL (time-to-live) here
 ;(the TTL comes from the server, and if it's assigning different TTL's to
 ;different IP's (?), then the IP's with bigger TTL's would dominate the world,
 ;even when accessing the IP's with smaller TTL's much more frequently).
 ;- - -
 push r4-r5,lr
 bl   sgIP_IntrProtect          ;\
;mov  r0,r0                     ;/
 ldr  r5,=dnsrecords ;min.rec
 ldr  r4,=dnsrecords ;curr.rec
 mov  r3,0ffffffffh  ;minttl
 mov  r2,SGIP_DNS_MAXRECORDSCACHE
@@lop:
 ldr  r1,[r4,sgDnsRec_flags]    ;\
 tst  r1,SGIP_DNS_FLAG_ACTIVE   ; check if unused
 beq  @@found_unused            ;/
 tst  r1,SGIP_DNS_FLAG_BUSY     ;\
 bne  @@lop_next                ; check if not busy,
 ldr  r1,[r4,sgDnsRec_TTL]      ; and if having smallest TTL (time-to-live)
 cmp   r3,r1  ;minttl,ttl       ; if so, memorize it as candidate
 movls r3,r1  ;minttl=ttl       ;
 movls r5,r4  ;min.rec=curr.rec ;/
@@lop_next:
 add  r4,sgDnsRec_size          ;\
 subs r2,1                      ; lop next
 bne  @@lop                     ;/
 mov  r4,r5                     ;-no unused record found, use record with minttl
@@found_unused:
 mov  r1,0                      ;\clear flags of the record
 str  r1,[r4,sgDnsRec_flags]    ;/
;mov  r0,r0                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r4     ;out: r0=DnsRec
 pop  r4-r5,pc
;------------------
sgIP_ntoa:  ;in: r0=ipaddr, out: none (aside from [ipaddr_alias])  ;"static"
 ;convert 32bit IP to decimal ASCIZ string
 ;(eg. "192.128.10.3",00h) (max 16 bytes, including EOL)
 ;- - -
 push r4-r6,lr
 mov  r4,r0     ;ipaddr
 ldr  r5,=ipaddr_alias
 mov  r6,4   ;four bytes
@@lop:
 and  r0,r4,0ffh                                ;-get next 8bit
 cmp  r0,10                                     ;\
 blo  @@one_digit                               ;
 cmp  r0,100                                    ;
 blo  @@two_digit                               ; convert 8bit to
;mov  r0,r0                     ;\              ; decimal ascii
 mov  r1,100                    ;               ;
 swi  swi_div                   ; hundred's     ;
 orr  r0,30h     ;\digit        ;               ;
 strb r0,[r5],1  ;/             ;               ;
 mov  r0,r1  ;remainder         ;/              ;
@@two_digit:                                    ;
;mov  r0,r0                     ;\              ;
 mov  r1,10                     ;               ;
 swi  swi_div                   ; ten's         ;
 orr  r0,30h     ;\digit        ;               ;
 strb r0,[r5],1  ;/             ;               ;
 mov  r0,r1  ;remainder         ;/              ;
@@one_digit:                                    ;
 orr  r0,30h     ;\digit        ;\one's         ;
 strb r0,[r5],1  ;/             ;/              ;/
 mov  r4,r4,lsr 8       ;\
 subs r6,1              ; lop next 8bit part
 movne  r3,'.'          ; (and append DOT)
 strneb r3,[r5],1       ;
 bne    @@lop           ;/
;mov  r6,0              ;\append EOL
 strb r6,[r5]           ;/
 pop  r4-r6,pc
;------------------
sgIP_DNS_GenerateHostentIP:  ;in: r0=ipaddr, out: r0=DnsHst  ;"static"
 push r4-r5,lr
 ldr  r4,=dnsrecord_hostent  ;DnsHst
 ldr  r5,=ipaddr_ip
 str  r0,[r5]   ;store IP (for indirect access via "[ipaddr_ip]")
;mov  r0,r0      ;IP                    ;\in lack of domain name, create
 bl   sgIP_ntoa  ;out: [ipaddr_alias]   ;/a numeric ASCIZ string as name
 ldr  r1,=alias_list                            ;\
 str  r1,[r4,sgDnsHst_h_aliases]                ; create alias_list
 ldr  r0,=ipaddr_alias                          ; (only one entry)
 str  r0,[r1],4   ;addr_list[0]=ptr to NAME     ; and point DnsHst
 str  r0,[r4,sgDnsHst_h_name]  ;ptr to NAME     ; to it, and also
 mov  r0,0                                      ; point directly to NAME
 str  r0,[r1],4   ;addr_list[1]=0  ;list end    ;/
 ldr  r1,=addr_list                             ;\
 str  r1,[r4,sgDnsHst_h_addr_list]              ; create addr_list
;ldr  r5,ipaddr_ip                              ; (only one entry)
 str  r5,[r1],4   ;addr_list[0]=ptr to IP       ; and point DnsHst
 mov  r0,0                                      ; to it
 str  r0,[r1],4   ;addr_list[1]=0  ;list end    ;/
 mov  r0,AF_INET                                ;\
 str  r0,[r4,sgDnsHst_h_addrtype]               ;/
 mov  r0,4                                      ;\
 str  r0,[r4,sgDnsHst_h_length]                 ;/
 mov  r0,r4     ;out: r0=dnsrecord_hostent (DnsHst)
 pop  r4-r5,pc
;------------------
sgIP_DNS_GenerateHostent:  ;in: r0=DnsRec, out: r0=DnsHst
 push r4-r5,lr
 ldr  r4,=dnsrecord_return   ;DnsRec (copy)
 ldr  r5,=dnsrecord_hostent  ;DnsHst
;mov  r0,r0  ;DnsRec (incoming)    ;src ;\copy incoming DNS record to
 mov  r1,r4  ;DnsRec (copy)        ;dst ; "dnsrecord_hostent" (needed
 mov  r2,sgDnsRec_size             ;len ; for pointers to name strings
 bl   memcopy_bytewise                  ;/in that copy)
 add  r0,r4,sgDnsRec_name                               ;\ptr to name
 str  r0,[r5,sgDnsHst_h_name]                           ;/
 ldr  r0,=alias_list          ;\ptr to alias_list       ;\
 str  r0,[r5,sgDnsHst_h_name] ;/(with ptr's to aliases) ;
 add  r1,r4,sgDnsRec_aliases                            ;
 ldr  r2,[r4,sgDnsRec_numalias] ;num aliases            ;
 cmp  r2,0                                              ; alias list
 beq  @@alias_copy_done                                 ;
@@alias_copy_lop:                                ;\     ;
 str  r1,[r0],4                                  ;      ;
 add  r1,256   ;=sgDnsRec_aliases+N              ;      ;
 subs r2,1                                       ;      ;
 bne  @@alias_copy_lop                           ;/     ;
@@alias_copy_done:                                      ;
 mov  r1,0      ;\terminate alias_list                  ;
 str  r1,[r0],4 ;/                                      ;/
 ldr  r0,=addr_list           ;\ptr to addr_list        ;\
 str  r0,[r5,sgDnsHst_h_name] ;/(with ptr's to addr's)  ;
 add  r1,r4,sgDnsRec_addrdata                           ;
 ldr  r2,[r4,sgDnsRec_numaddr] ;num addr's              ;
 cmp  r2,0                                              ; addr list
 beq  @@addr_copy_done                                  ;
@@addr_copy_lop:                                 ;\     ;
 str  r1,[r0],4                                  ;      ;
 add  r1,4     ;=sgDnsRec_addrdata+N             ;      ;
 subs r2,1                                       ;      ;
 bne  @@addr_copy_lop                            ;/     ;
@@addr_copy_done:                                       ;
 mov  r1,0      ;\terminate addr_list                   ;
 str  r1,[r0],4 ;/                                      ;/
;- - -
 mov  r0,AF_INET                                ;\record class is probably AF_IN, not IN_ADDR  ;uh, unsure?
 str  r0,[r5,sgDnsHst_h_addrtype]               ;/
 ldrh r0,[r4,sgDnsRec_addrlen]  ;16bit here!    ;\addr len
 str  r0,[r5,sgDnsHst_h_length] ;32bit here!    ;/
 mov  r0,r5     ;out: r0=dnsrecord_hostent (DnsHst)
 pop  r4-r5,pc
;------------------
sgIP_DNS_genquery:  ;in: r0=name, out: r0=len, [querydata]   ;"static"
 ;generates a DNS query (12-byte header, ASCIZ string, 4-byte footer)
 push r4,lr
 mov  r4,r0                     ;-memorize name
 ldr  r0,=time_count            ;\
 ldrh r0,[r0]  ;16bit only!     ; get transaction id = htons(time)
 bl   htons                     ; and memorize it in [last_id]
 ldr  r2,=last_id               ;
 strh r0,[r2]              ;ID  ;/
;- - - header section... (12 bytes, aka six halfwords)
 ldr  r1,=querydata
 strh r0,[r1],2            ;ID    ;htons(time)  ;transaction id (aka last_id)
 mov  r0,0001h // strh r0,[r1],2  ;htons(0100h) ;flags: recursion desired, standard query
 mov  r0,0100h // strh r0,[r1],2  ;htons(0001h) ;num questions (1)
 mov  r0,0     // strh r0,[r1],2  ;0            ;num resource records (0)
                  strh r0,[r1],2  ;0            ;num nameserver records (0)
                  strh r0,[r1],2  ;0            ;num additional records (0)
;- - - question section... (ASCIZ, byte string)
 mov   r2,'.'  ;prev char (initially a dot)     ;\
@@name_lop:                                     ;
 ldrb  r0,[r4],1 ;src (name)                    ; copy the name including EOL
 strb  r0,[r4],1 ;dest                          ; and verify the dots
 cmp   r0,'.'      ;\if curr char is 00h or DOT ; (first/last chars may not
 cmpne r0,00h      ;/                           ; be "." dots, and there may be
 cmpeq r2,'.'      ;\and prev char was DOT      ; no ".." double dots, and
 moveq r0,0        ; then return r0=0 (failed)  ; string may not be "" empty)
 beq   @@return_r0 ;/                           ;
 movs  r2,r0   ;check eol & memorize prev char  ;
 bne   @@name_lop                               ;/
;XXX could also check max length (original code checked for NAME being max
;    255 chars+EOL, which would make the whole query max 12+256+4 bytes).
;    accordingly "querydata" needs to be only 12+256+4 bytes (whilst,
;    currently it's defined as 512 bytes, thus wasting memoty)
;- - - footer (type/class)... (four bytes, aka two halfwords) (unaligned)
 mov  r0,0100h // bl strh_16bit_r0_to_r1  ;qtype  = htons(0001h) ;Type=A (host address)
 mov  r0,0100h // bl strh_16bit_r0_to_r1  ;qclass = htons(0001h) ;Class=IN
;- - - done, return length
 ldr  r0,=querydata   ;start            ;\return r0=length
 sub  r0,r1,r0        ;len = end-start  ;/  (and return [querydata])
@@return_r0:
 pop  r4,pc
;------------------
sgIP_DNS_send_recv_query:  ;in: r0=name, r1=Intr state, out: r0=reply_len
 push r4-r11,lr
 sub  sp,sgSoin_size            ;\alloc sockaddr
 mov  r11,sp                    ;/
 mov  r4,r0  ;name
 mov  r5,r1  ;old Intr state
 ldr  r0,=dns_sock              ;\fail if DNS is already being queried
 ldr  r0,[r0]                   ; (that shouldn't happen, unless some IRQ
 cmp  r0,-1             ;\      ; handler would do so during "sgIP_WaitEvent")
 moveq r10,0            ;       ;
 beq   @@return_r10_raw ;/      ;/
 mov  r0,AF_INET                        ;\
 mov  r1,SOCK_DGRAM                     ;
 mov  r2,0                              ; get DNS socket
 bl   socket                            ;
 ldr  r1,=dns_sock ;\                   ;
 str  r0,[r1]      ;/                   ;
 mov  r7,r0  ;dns_socket                ;/
 mov  r0,r7  ;dns_socket                ;\
 mov  r1,FIONBIO                        ; set non-blocking
 sub  sp,4    ;ptr_to_1 alloc    ;-->   ;    i=ioctl(dns_sock,FIONBIO,&i);
 mov  r2,00000001h                      ;
 str  r2,[sp] ;ptr_to_1 init            ;
 mov  r2,sp   ;ptr_to_1 ptr             ;
 bl   ioctl                             ;
 add  sp,4    ;ptr_to_1 dealloc  ;<--   ;
;mov  N/A,r0                            ;/
 mov  r0,r4  ;name                      ;\
 bl   sgIP_DNS_genquery                 ; generate query packet
 mov  r8,r0  ;query_len                 ;/
 bl   sgIP_Hub_GetDefaultInterface      ;\get hardware interface
;mov  r0,r0  ;HubHwi                    ; and get DNS server IP from HubHwi
 ldr  r6,[r0,sgHubHwi_dns+0]  ;dns_ip   ;/
;- - -
 mov  r9,0   ;num_retries
@@retry_send_lop:
 ldr  r0,=sgIP_timems                   ;\
 ldr  r0,[r0]                           ; memorize query time
 ldr  r1,=query_time_start              ;
 str  r0,[r1]                           ;/
 str  r6,[r11,sgSoin_sin_addr]          ;\
 mov  r0,DNS_PORT                       ; apply dns_ip and dns_port
 strh r0,[r11,sgSoin_sin_port]          ;/
 push r4-r5  ;--->                      ;\
 mov  r0,r7  ;dns_socket                ;
 ldr  r1,=querydata      ;\packet       ;
 mov  r2,r8  ;query_len  ;/src & len    ; send the query request packet
 mov  r3,0                              ;
 mov  r4,r11             ;\sockaddr     ;
 mov  r5,sgSoin_size     ;/addr & len   ;
 bl   sendto                            ;
 pop  r4-r5  ;<---                      ;
;mov  N/A,r0                            ;/
;- - -
@@retry_recv_lop:
;- - -
@@wait_for_reply_lop:                                                   ;\
 push r4-r5  ;--->                      ;\                              ;
 sub  sp,4   ;--> dummy_ptr alloc       ;
 mov  r0,r7  ;dns_socket                ;                               ;
 ldr  r1,=responsedata   ;\packet       ;                               ;
 mov  r2,512  ;len       ;/dest & len   ; try recv response packet      ;
 mov  r3,0                              ;                               ;
 mov  r4,r11             ;\sockaddr     ;                               ;
 mov  r5,sp  ;dummy_ptr  ;/addr & [len] ;                               ;
 bl   recvfrom                          ;                               ;
 add  sp,4   ;<-- dummy_ptr dealloc     ;
 pop  r4-r5  ;<---                      ;                               ;
 cmp  r0,-1                             ;                               ;
 bne  @@got_reply  ;in: r0=reply_len    ;/                              ;
 ldr  r0,=sgIP_timems                   ;\                              ;
 ldr  r0,[r0]                           ;                               ;
 ldr  r1,=query_time_start              ;                               ;
 ldr  r1,[r1]                           ; check dns timeout             ;
 sub  r0,r1    ;time-start              ;                               ;
 cmp  r0,SGIP_DNS_TIMEOUTMS             ;                               ;
 bhi  @@reply_timeout                   ;/                              ;
 mov  r0,r5                         ;\  ;\                              ;
 bl   sgIP_IntrUnprotect            ;/  ;                               ;
 bl   sgIP_WaitEvent                ;-  ; wait                          ;
 bl   sgIP_IntrReprotect            ;\  ;                               ;
;mov  r5,r0                         ;/  ;/                              ;
 b    @@wait_for_reply_lop                                              ;/
;---
@@reply_timeout:   ;no reply, retry...
 add  r9,1   ;num_retries               ;\
 cmp  r9,SGIP_DNS_MAXRETRY              ; retry (resend the request)
 blo  @@retry_send_lop                  ;/
;XXX could try another server, for now just quit...
 mov  r10,0  ;reply_len (0=failed)      ;\fail
 b    @@return_r10                      ;/
;---
@@got_reply:  ;in: r0=reply_len  ;got something, check if it it is what we want
 mov    r10,r0  ;reply_len
 cmp    r10,12  ;reply_len           ;\ ;\
 blo    @@retry_recv_lop             ;/ ; check if response is at least big
 ldr    r0,[r11,sgSoin_sin_addr]     ;\ ; enough to contain the response header,
 cmp    r0,r6  ;dns_ip               ;  ; and that addr/port are as expected,
 ldreqh r0,[r11,sgSoin_sin_port]     ;  ; otherwise go back and see if we can
 cmpeq  r0,DNS_PORT                  ;  ; get a more official response
 bne    @@retry_recv_lop             ;/ ;/
 ldr  r1,=responsedata               ;\ ;\
 ldrh r0,[r1],2                      ;  ;
 ldr  r2,=last_id                    ;  ; want response_header[0] = ID
 ldrh r2,[r2]                        ;  ;
 cmp  r0,r2                          ;  ;
 bne  @@retry_recv_lop ;bad, retry   ;/ ;/
;- - -
@@return_r10:
 mov  r0,r7  ;dns_socket                ;\close socket
 bl   closesocket                       ;/
 mov  r0,-1                             ;\
 ldr  r1,=dns_sock                      ; dns_sock = -1
 str  r0,[r1]                           ;/
@@return_r10_raw:
 mov  r0,r10   ;out: r0=reply_len (or 0=failed)
 add  sp,sgSoin_size            ;-dealloc sockaddr
 pop  r4-r11,pc
;------------------
sgIP_DNS_parse_reply_to_record:  ;in: r0=name, out: r0=DnsRec (or 0=fail)
 push r4-r12,lr
 mov  r4,r0     ;name
 ldr  r1,=responsedata
;- - - parse response header (12 bytes, aka six halfwords)...
 ldrh r0,[r1],2                 ;-skip response_header[0] = ID (already checked to be same as query ID)
 ldrh r0,[r1],2                 ;-skip response_header[1] = flags (?)
 ldrh r0,[r1],2                 ;\
 push r1                        ;
 bl   ntohs                     ; get response_header[2] = num questions
 pop  r1                        ;
 mov  r5,r0 ;num_questions      ;/
 ldrh r0,[r1],2                 ;\
 push r1                        ;
 bl   ntohs                     ; get response_header[3] = num answers
 pop  r1                        ; (if zero --> no answer --> exit/fail)
 movs r6,r0 ;num_answers        ;
 beq  @@return_r0  ;fail, r0=0  ;/
 ldrh r0,[r1],2                 ;-skip response_header[4] = nameservers (?)
 ldrh r0,[r1],2                 ;-skip response_header[5] = extras (?)
;- - - - alloc record
 push r1
 bl   sgIP_DNS_GetUnusedRecord  ;\alloc record
 mov  r7,r0  ;DnsRec            ;/
 pop  r1
 mov  r0,SGIP_DNS_FLAG_ACTIVE+SGIP_DNS_FLAG_BUSY        ;\
 str  r0,[r7,sgDnsRec_flags]                            ;/
 mov  r8,0  ;num_aliases
 mov  r9,0  ;num_addrs
;- - - skip/ignore questions...
 cmp  r5,0   ;num_questions
 beq  @@num_questions_done
@@num_questions_lop:
@@skip_question_lop:                                    ;\
 ldrb r0,[r1],1              ;-get NN                   ;
 cmp  r0,63                  ;\when indirect GOTO ptr,  ;
 addhi r1,1  ;skip ptr lsb   ; just skip ptr & done     ; skip question
 movhi r0,0  ;force done     ;/                         ;
 add  r1,r0  ;skip NN bytes  ;\skip NN bytes,           ;
 cmp  r0,0   ;0=end          ; done when NN=0           ;
 bne  @@skip_question_lop    ;/                         ;/
 add  r1,4                      ;-skip 4-byte footer (within question)
 subs r5,1   ;num_questions     ;\lop next question (if any)
 bne  @@num_questions_lop       ;/
@@num_questions_done:
;- - - process answers...
@@num_answer_lop:
 cmp  r8,SGIP_DNS_MAXALIASES  ;num_aliases      ;\      ;\
 bhs  @@skip_answer                             ;/      ;
 push r1  ;-->                                          ;
 mov  r0,r1   ;src                                      ;
 add  r1,r7,sgDnsRec_aliases            ;\dest          ;
 add  r1,r1,r8,lsl 8  ;+num_aliases*256 ;/alias[N]      ;
 mov  r3,0  ;dot_flag                                   ;
@@copy_alias_lop:                                       ;
 ldrb r2,[r0],1                         ;-len           ; copy answer
 cmp  r2,63                             ;\              ; to alias[N]
 ldrhib r0,[r0],1 ;lsb                  ;               ;
 andhi  r2,63     ;msb                  ; indirect      ; (answer may consist
 addhi  r2,r0,r2,lsl 8  ;lsb+msb*100h   ; GOTO ptr      ; of several sub-strings
 ldrhi  r0,=responsedata ;base          ;               ; which get merged here
 addhi  r0,r0,r2   ;base+lsb+msb*100h   ;               ; with dots inserted)
 bhi    @@copy_alias_lop                ;/              ;
 cmp  r2,0                         ;len ;\check end     ;
 beq  @@copy_alias_done                 ;/              ;
;mov  r0,r0                        ;src ;\              ;
;mov  r1,r1                        ;dst ; copy string   ;
;mov  r2,r2                        ;len ;               ;
 bl   memcopy_bytewise                  ;/              ;
 mov  r3,'.'                            ;\append dot    ;
 strb r3,[r1],1  ;dst                   ; and set flag  ;
;mov  r3,'.'     ;dot_flag              ;/              ;
 b    @@copy_alias_lop                  ;-lop more      ;
@@copy_alias_done:                                      ;
 cmp  r3,0       ;dot_flag              ;\stepback last ;
 subne r1,1      ;dst                   ;/dot (if any)  ;
 mov  r2,0                              ;\append EOL    ;
 strb r2,[r1],1  ;dst                   ;/              ;
 add  r8,1   ;num_aliases                               ;
 pop  r1  ;<--                                          ;
@@skip_answer:                                          ;/
@@skip_answer_lop:                                      ;\
 ldrb r0,[r1],1              ;-get NN                   ; skip answer
 cmp  r0,63                  ;\when indirect GOTO ptr,  ; (unlike as above
 addhi r1,1  ;skip ptr lsb   ; just skip ptr & done     ; "copy answer",
 movhi r0,0  ;force done     ;/                         ; without following
 add  r1,r0  ;skip NN bytes  ;\skip NN bytes,           ; GOTO's)
 cmp  r0,0   ;0=end          ; done when NN=0           ;
 bne  @@skip_answer_lop      ;/                         ;/
;- - - process footer (WITHIN answers)...
 ldrb r10,[r1],1  ;CNAME?               ;\type/cname (CNAME=5, A=1)
 ldrb r11,[r1],1  ;TYPE "A" ?           ;/
 bl   ldrh_16bit_r0_from_r1             ;\
 push r1                                ;
 bl   ntohs                             ; addrclass
 pop  r1                                ;
 strh r0,[r7,sgDnsRec_addrclass]        ;/
 bl   ldr_32bit_r0_from_r1              ;\
 push r1                                ;
 bl   ntohl                             ; time-to-live
 pop  r1                                ;
 str  r0,[r7,sgDnsRec_TTL]              ;/
 bl   ldrh_16bit_r0_from_r1             ;\
 push r1                                ;
 bl   ntohs                             ; addrlen (should be 4 for 4-byte IPs)
 pop  r1                                ;
 mov  r12,r0  ;addrlen                  ;/
 cmp  r12,4   ;addrlen          ;\uh, better skip address if ADDRLEN<>4 (?)
 bne  @@skip_addr               ;/    (original code doesn't do so)
 cmp  r11,01h ;TYPE "A" ;Type=A (host address)? ;\
 bne  @@skip_addr                               ;
 cmp  r9,SGIP_DNS_MAXRECORDADDRS  ;num_addrs    ;
 bhs  @@skip_addr                               ; address
 bl   ldr_32bit_r0_from_r1   ;get addr          ;
 add  r2,r7,sgDnsRec_addrdata                   ;
 str  r0,[r2,r9,lsl 2]  ;addrdata[N]            ;
 add  r9,1      ;num_addrs                      ;
 sub  r1,4 ;stepback, instead use below "ADD"   ;
@@skip_addr:                                    ;
 add  r1,r12  ;addrlen                          ;/
 subs r6,1   ;num_answers               ;\lop next answer (if any)
 bne  @@num_answer_lop                  ;/
;- - - likely we have all the data we care for now...
 mov  r0,4                              ;\force addrlen=4
 strh r0,[r7,sgDnsRec_addrlen]          ;/
 str  r9,[r7,sgDnsRec_numaddr]          ;\apply num_addrs & num_aliases
 str  r8,[r7,sgDnsRec_numalias]         ;/
 mov  r0,r4   ;name         ;src        ;\apply original incoming name parameter
 add  r1,r7,sgDnsRec_name   ;dst        ; (as opposed to received aliases)
 bl   copy_asciz                        ;/
 mov  r0,SGIP_DNS_FLAG_ACTIVE+SGIP_DNS_FLAG_RESOLVED    ;\flag active+resolved
 str  r0,[r7,sgDnsRec_flags]                            ;/
;- - - we got our answer
 mov  r0,r7     ;out: r0=DnsRec (okay)
@@return_r0:    ;out: r0=DnsRec (or 0=failed, no answer)
 pop  r4-r12,pc
;------------------
sgIP_DNS_gethostbyname:  ;in: r0=name, out: r0=DnsHst
 push r4-r5,lr
 mov  r4,r0   ;name             ;-memorize name
 bl   sgIP_IntrProtect          ;\
 mov  r5,r0                     ;/
 mov  r0,r4   ;name                 ;\          ;\
 sub  sp,4    ;alloc ip_dest        ;           ;
 mov  r1,sp   ;ip_dest              ;           ;
 bl   sgIP_DNS_isipaddress          ;           ; check if numeric IP address
 cmp  r0,0                     ;zf  ;           ; if so, handle it directly,
 ldr  r0,[sp] ;IP=[ip_dest]    ;    ;           ; without needing DNS
 add  sp,4    ;dealloc ip_dest ;    ;           ;
 beq  @@not_numeric_ip         ;zf  ;/          ;
;mov  r0,r0   ;IP                   ;\          ;
 bl   sgIP_DNS_GenerateHostentIP    ;           ;
 b    @@return_r0   ;out: r0=DnsHst ;/          ;
@@not_numeric_ip:                               ;/
 mov  r0,r4  ;name                  ;\          ;\
 bl   sgIP_DNS_FindDNSRecord        ;           ;
 cmp  r0,0   ;DnsRec (0=not found)  ;           ; check if name already cached
 beq  @@not_cached                  ;/          ; if so, handle by using the
;mov  r0,r0  ;DnsRec                ;\          ; cached DNS record
 bl   sgIP_DNS_GenerateHostent      ;           ;
 b    @@return_r0   ;out: r0=DnsHst ;/          ;
@@not_cached:                                   ;/
;- - -  above cases didn't work out, so send a query to the name server...
 mov  r0,r4  ;name                  ;\          ;\
 mov  r1,r5  ;old Intr state        ;           ;
 bl   sgIP_DNS_send_recv_query      ;           ; send query to name server,
 cmp  r0,0   ;reply_len (0=fail)    ;           ; wait for response,
 beq  @@return_r0  ;out: r0=0       ;/          ; parse response, and add
 mov  r0,r4  ;name                  ;\          ; it to cached DNS records,
 bl   sgIP_DNS_parse_reply_to_record;           ; and return the info
 cmp  r0,0   ;DnsRec (or 0=fail)    ;           ;
 beq  @@return_r0  ;out: r0=0       ;/          ;
;mov  r0,r0  ;DnsRec                ;\          ;
 bl   sgIP_DNS_GenerateHostent      ;           ;
;b    @@return_r0  ;out: r0=DnsHst  ;/          ;/
@@return_r0:
 mov  r4,r0  ;return value (DnsHst, or 0=failed)
 mov  r0,r5                             ;\
 bl   sgIP_IntrUnprotect                ;/
 mov  r0,r4  ;return value (DnsHst, or 0=failed)
 pop  r4-r5,pc
;------------------
inet_addr:  ;in: r0=numeric_string(cp), out: r0
 push lr
 sub  sp,4   ;alloc ip_dest
;mov  r0,r0  ;numeric_string (aka "cp")         ;\
 mov  r1,sp  ;ip_dest                           ; convert numeric string to IP
 bl   sgIP_DNS_isipaddress                      ;
 cmp  r0,0                                      ;/
 ldrne r0,[sp]       ;okay, return IP=[ip_dest]
 moveq r0,0ffffffffh ;fail, return FFFFFFFFh
 add  sp,4   ;dealloc ip_dest
 pop  pc
;------------------
inet_aton:  ;in: r0=numeric_string(cp), r1=in_addr_dest, out: r0
 push r4,lr
 sub  sp,4   ;alloc ip_dest
 mov  r4,r1  ;memorize in_addr_dest
;mov  r0,r0  ;numeric_string (aka "cp")         ;\
 mov  r1,sp  ;ip_dest                           ; convert numeric string to IP
 bl   sgIP_DNS_isipaddress                      ;
 cmp  r0,0                                      ;/
 ldrne r1,[sp]       ;okay, get IP=[ip_dest]
 strne r1,[r4]       ;okay, apply [in_addr_dest]=IP
 movne r0,1          ;okay, return 1
;moveq r0,0          ;fail, return 0
 add  sp,4   ;dealloc ip_dest
 pop  pc
;------------------
inet_ntoa:  ;in: r0=in_addr_src, out: r0=ipaddr_alias (ptr to numeric ASCIZ string)
 push lr
 ldr  r0,[r0]    ;IP=[in_addr_src]              ;\
 bl   sgIP_ntoa  ;out: [ipaddr_alias]           ;/
 ldr  r0,=ipaddr_alias  ;return ptr to ipaddr_alias
 pop  pc
;------------------
.endif ;with_dns
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_Hub.c
;------------------
;BLAH: the "Hub" software layer would be useful ONLY when supporting
;      multiple hardware ports (eg. ethernet AND wifi)
;      however, the NDS uses ONLY wifi (and SGIP_HUB_MAXPROTOCOLINTERFACES
;      and SGIP_HUB_MAXHWINTERFACES are both set to "1"), so most of the
;      "Hub" code could be replaced by directly accessing wifi functions)
;------------------
.data?
NumHWInterfaces       dd 0  ;int   ;\kinda BLAH (used only for some weird
NumProtocolInterfaces dd 0  ;int   ;/unreliable & useless error checking)
ProtocolInterfaces:   defs sgHubPrt_size*SGIP_HUB_MAXPROTOCOLINTERFACES ;sgIP_Hub_Protocol
HWInterfaces:         defs sgHubHwi_size*SGIP_HUB_MAXHWINTERFACES       ;sgIP_Hub_HWInterface
.code
;------------------
sgIP_Hub_Init:  ;in/out: none
 mov  r0,0
 ldr  r1,=NumHWInterfaces       ;\NumHWInterfaces=0
 str  r0,[r1]                   ;/
 ldr  r1,=NumProtocolInterfaces ;\NumProtocolInterfaces=0
 str  r0,[r1]                   ;/
 bx   lr
;------------------
sgIP_Hub_AddProtocolInterface:  ;in: r0=protocolID, r1=RxProc, r2=InitProc, out: r0=HubPrt (or 0=failed)
 push r4-r5,lr
 ;BLAH: if(NumProtocolInterfaces>=SGIP_HUB_MAXPROTOCOLINTERFACES) return 0;
 ldr  r4,=ProtocolInterfaces            ;\
 mov  r5,SGIP_HUB_MAXPROTOCOLINTERFACES ;
@@lop:                                  ;
 ldrh r3,[r4,sgHubPrt_flags]            ; search free entry
 tst  r3,SGIP_FLAG_PROTOCOL_IN_USE      ;
 beq  @@found_free                      ;
 add  r4,sgHubPrt_size                  ;
 subs r5,1                              ;
 bne  @@lop                             ;/
 mov  r4,0    ;fail (return value)      ;\none found
 b    @@return_r4                       ;/
;---
@@found_free:
 ldr  r3,=SGIP_FLAG_PROTOCOL_IN_USE+SGIP_FLAG_PROTOCOL_ENABLED  ;\init flags
 strh r3,[r4,sgHubPrt_flags]                                    ;/
 strh r0,[r4,sgHubPrt_protocol]       ;-protocol ID                   ;\apply params
 str  r1,[r4,sgHubPrt_ReceivePacket]  ;-RxProc ;sgIP_IP_ReceivePacket ;/
 cmp  r2,0                                                      ;\call InitProc
 movne r0,r4  ;new entry                                        ; (if any)
 blxne r2     ;init proc                                        ;/
 ldr  r1,=NumProtocolInterfaces ;\
 ldr  r0,[r1]                   ; increase num protocol's
 add  r0,1                      ;
 str  r0,[r1]                   ;/
;- - -
@@return_r4:
 mov  r0,r4   ;return new enty (not actually useful though), or 0=error
 pop  r4-r5,pc
;------------------
sgIP_Hub_AddHardwareInterface:  ;in: r0=TxProc, r1=InitProc, out: HubHwi (or 0=failed)
 push r4-r5,lr
 ;BLAH: if(NumHWInterfaces>=SGIP_HUB_MAXHWINTERFACES) return 0;
 ldr  r4,=HWInterfaces                  ;\
 mov  r5,SGIP_HUB_MAXHWINTERFACES       ;
@@lop:                                  ;
 ldrh r3,[r4,sgHubHwi_flags]            ; search free entry
 tst  r3,SGIP_FLAG_HWINTERFACE_IN_USE   ;
 beq  @@found_free                      ;
 add  r4,sgHubHwi_size                  ;
 subs r5,1                              ;
 bne  @@lop                             ;/
 mov  r4,0    ;fail (return value)      ;\none found
 b    @@return_r4                       ;/
;---
@@found_free:
 ldr  r3,=SGIP_FLAG_HWINTERFACE_IN_USE+SGIP_FLAG_HWINTERFACE_ENABLED;\init flags
 strh r3,[r4,sgHubHwi_flags]                                        ;/
 str  r0,[r4,sgHubHwi_TransmitFunction] ;arm9_Wifi_TransmitFunction ;-apply TxProc
 cmp  r1,0                                                        ;\call InitProc
 movne r0,r4  ;new entry                                          ; (if any)
 blxne r1     ;init proc                ;arm9_Wifi_Interface_Init ;/
 ldr  r1,=NumHWInterfaces       ;\
 ldr  r0,[r1]                   ; increase num hw's
 add  r0,1                      ;
 str  r0,[r1]                   ;/
;- - -
@@return_r4:
 mov  r0,r4   ;return new enty (not actually useful though), or 0=error
 pop  r4-r5,pc
;------------------
sgIP_Hub_RemoveProtocolInterface:  ;in: r0=HubPrt, out: none
 ldr  r1,=ProtocolInterfaces            ;\
 mov  r2,SGIP_HUB_MAXPROTOCOLINTERFACES ;
@@lop:                                  ; search (rather nonsense to do this,
 cmp  r0,r1     ;ptr to protocol        ; the result will be ALWAYS "r0",
 beq  @@found                           ; unless it isn't found, which could be
 add  r1,sgHubPrt_size                  ; checked via MATHS instead of searching)
 subs r2,1                              ;
 bne  @@lop                             ;/
 b    @@not_found                       ;-oops, not found
;---
@@found:
 mov  r0,0                      ;\mark not in use anymore
 strh r0,[r1,sgHubPrt_flags]    ;/
 ldr  r1,=NumProtocolInterfaces ;\
 ldr  r0,[r1]                   ; decrease num protocol's
 sub  r0,1                      ;
 str  r0,[r1]                   ;/
@@not_found:
 bx   lr
;------------------
sgIP_Hub_RemoveHardwareInterface:  ;in: r0=HubHwi, out: none
 ldr  r1,=HWInterfaces                  ;\
 mov  r2,SGIP_HUB_MAXHWINTERFACES       ;
@@lop:                                  ; search (rather nonsense to do this,
 cmp  r0,r1     ;ptr to hw              ; the result will be ALWAYS "r0",
 beq  @@found                           ; unless it isn't found, which could be
 add  r1,sgHubHwi_size                  ; checked via MATHS instead of searching)
 subs r2,1                              ;
 bne  @@lop                             ;/
 b    @@not_found                       ;-oops, not found
;---
@@found:
 mov  r0,0                      ;\mark not in use anymore
 strh r0,[r1,sgHubHwi_flags]    ;/
 ldr  r1,=NumHWInterfaces       ;\
 ldr  r0,[r1]                   ; decrease num hw's
 sub  r0,1                      ;
 str  r0,[r1]                   ;/
@@not_found:
 bx   lr
;------------------
sgIP_Hub_ReceiveHardwarePacket:  ;in: r0=HubHwi, r1=MemBlk, out: r0
 ;uh, original code is obtaining the protocol via NUMERIC index "short [6]",
 ;which seems to be actually referring to "sgEthHdr_protocol" in Ethernet Hdr.
 ;- - -
 push r4-r6,lr
 movs r5,r1  ;MemBlk    ;\
 beq  @@fail            ; reject if incoming value(s) are zero
 movs r4,r0  ;HubHwi    ;
 beq  @@fail_dealloc    ;/
 ldrh r2,[r4,sgHubHwi_flags]            ;\
 tst  r2,SGIP_FLAG_HWINTERFACE_ENABLED  ; reject if not enabled
 beq  @@fail_dealloc                    ;/
;- - -
       .if 0      ;XNAY
        push r0
        mov r0,12h // bl wrchr_r0
        mov r0,'1' // bl wrchr_r0
        mov r0,11h // bl wrchr_r0
        pop r0
       .endif

 ldr  r3,[r5,sgMemBlk_datastart]        ;\get protocol from MemBlk's EthHdr
 ldrh r6,[r3,sgEthHdr_protocol]         ;/

       .if 0       ;XNAY
        push r0-r3
        bl   wrspc
        mov r0,12h // bl wrchr_r0
        mov r0,'P' // bl wrchr_r0
        mov r0,'=' // bl wrchr_r0
        mov  r0,r6 ;protocol
        bl   wrhex16bit
        mov r0,10h // bl wrchr_r0
        bl   wrspc
        pop  r0-r3
       .endif

;SGIP_DEBUG_MESSAGE(("hub: rx packet %04X %X",protocol,packet->totallength));
 ldr  r2,=PROTOCOL_ETHER_ARP            ;\
 cmp  r6,r2   ;protocol                 ;
 bne  @@not_ether_arp                   ; Ether ARP
;mov  r0,r0/r4  ;HubHwi                 ;
;mov  r1,r1/r5  ;MemBlk                 ;
 bl   sgIP_ARP_ProcessARPFrame          ;
 b    @@done_arp                        ;/
;---
@@not_ether_arp:  ;otherwise it's supposedly ETHER_IP...

       .if 0       ;XNAY
        mov r0,12h // bl wrchr_r0
        mov r0,'2' // bl wrchr_r0
        mov r0,11h // bl wrchr_r0
       .endif

 mov  r0,r5  ;MemBlk                    ;\hide ethernet header for
 mov  r1,-14                            ; higher-level protocols
 bl   sgIP_memblock_exposeheader        ;/
 ldr  r1,=ProtocolInterfaces            ;\
 mov  r2,SGIP_HUB_MAXPROTOCOLINTERFACES ; search matching protocol
@@lop:                                  ;
 ldrh r0,[r1,sgHubPrt_flags]            ; ;\
 tst  r0,SGIP_FLAG_PROTOCOL_ENABLED     ; ; want enabled
 beq  @@not_this                        ; ;/
 ldrh r0,[r1,sgHubPrt_protocol]         ; ;\want protocol match
 cmp  r0,r6  ;protocol                  ; ; (aka usually ETHER_IP)
 bne  @@not_this                        ; ;/

       .if 0       ;XNAY
        mov r0,12h // bl wrchr_r0
        mov r0,'3' // bl wrchr_r0
        mov r0,11h // bl wrchr_r0
       .endif

 ldr  r3,[r1,sgHubPrt_ReceivePacket]    ; ;\
 mov  r0,r5  ;MemBlk  ;\                ; ; okay, pass on to RxProc
 bl   bx_r3  ;RxProc  ;/                ; ; (aka "sgIP_IP_ReceivePacket")
 b    @@return_r0                       ; ;/
@@not_this:                             ;
 add  r1,sgHubPrt_size                  ;
 subs r2,1                              ;
 bne  @@lop                             ;/
;- - -
;hrmm, packet is unhandled, ignore it for now...

       .if 0       ;XNAY
        mov r0,12h // bl wrchr_r0
        mov r0,'I' // bl wrchr_r0
        mov r0,'G' // bl wrchr_r0
        mov r0,'N' // bl wrchr_r0
        mov r0,'O' // bl wrchr_r0
        mov r0,11h // bl wrchr_r0
       .endif

;- - -
@@fail_dealloc:
 mov  r0,r5  ;MemBlk            ;\dealloc
 bl   sgIP_memblock_free        ;/
@@fail:     ;return 0

       .if 0       ;XNAY
        mov r0,12h // bl wrchr_r0
        mov r0,'N' // bl wrchr_r0
        mov r0,'O' // bl wrchr_r0
        mov r0,'T' // bl wrchr_r0
        mov r0,'T' // bl wrchr_r0
        mov r0,11h // bl wrchr_r0
       .endif

@@done_arp: ;return 0, too
 mov  r0,0
@@return_r0:
 pop  r4-r6,pc
;------------------
sgIP_Hub_SendProtocolPacket:  ;in: r0=protocol, r1=MemBlk, r2=DestAddr, r3=SrcAddr, out: r0
 ;send packet from a protocol interface, resolve the requisite hardware
 ;interface addresses and send it.
 push r4-r6,lr
 cmp  r1,0   ;MemBlk            ;\reject if packet=0
 beq  @@fail                    ;/
 ldr  r4,=HWInterfaces                  ;\
 mov  r5,SGIP_HUB_MAXHWINTERFACES       ;
@@lop:                                  ;
 ldr  r6,[r4,sgHubHwi_ipaddr]           ; search SrcAddr
 cmp  r6,r3   ;SrcAddr                  ; (aka figure out what hardware
 beq   @@found_ip                       ; interface is in use)
@@lop1_next:                            ;
 add  r4,sgHubHwi_size                  ;
 subs r5,1                              ;
 bne  @@lop                             ;/
 mov  r0,r1  ;MemBlk      ;\dealloc     ;\
 bl   sgIP_memblock_free  ;/            ; not found
@@fail:                                 ;
 mov  r0,0  ;fail         ;\fail        ;
 b    @@return_r0         ;/            ;/
;---
@@found_ip:
 ldr  r5,[r4,sgHubHwi_snmask]           ;\
 eor  r3,r2  ;SrcAddr XOR DestAddr      ; check if Src/Dest are on SAME network
 tst  r3,r5  ;subnet mask               ;/
 cmpne r2,0ffffffffh   ;dest,broadcast  ;-or if Dest is broadcast
 moveq r3,r2  ;Dest = Dest              ;-if either one of that, use DestAddr
 ldrne r3,[r4,sgHubHwi_gateway]         ;-otherwise, use Gateway instead of Dest
;mov  r3,r3  ;Dest (or gateway)         ;\
 mov  r2,r0  ;protocol                  ;
;mov  r1,r1  ;MemBlk                    ; send on to ARP layer
 mov  r0,r4  ;HubHwi                    ;
 bl   sgIP_ARP_SendProtocolFrame        ;
;mov  r0,r0  ;return value              ;/
;- - -
@@return_r0:
 pop  r4-r6,pc
;------------------
sgIP_Hub_SendRawPacket:  ;in: r0=HubHwi, r1=MemBlk, out: r0
 ;send packet on a hardware interface.
 cmp  r1,0   ;MemBlk    ;\
 beq  @@fail            ; reject if param(s) are zero
 cmp  r0,0   ;HubHwi    ;
 beq  @@fail_dealloc    ;/
 ldrh r3,[r0,sgHubHwi_flags]                    ;\reject if not enabled

       .if show_tx_info
        push r0,lr
        mov r0,13h // bl wrchr_r0
        mov r0,'H' // bl wrchr_r0
        mov r0,'U' // bl wrchr_r0
        mov r0,'B' // bl wrchr_r0
        mov r0,'T' // bl wrchr_r0
        mov r0,'X' // bl wrchr_r0
        ldr  r0,[r1,sgMemBlk_thislength]
        bl wrhex8bit
        mov r0,10h // bl wrchr_r0
       ;and r0,r3,SGIP_FLAG_HWINTERFACE_ENABLED
       ;bl wrhex16bit
       ;bl wrdot
        pop r0,lr
       .endif

 tst  r3,SGIP_FLAG_HWINTERFACE_ENABLED          ;/
 ldrne r2,[r0,sgHubHwi_TransmitFunction]           ;\
;movne r0,r0  ;HubHwi                              ; okay, pass on to TxFunc
;movne r1,r1  ;MemBlk                              ; (and EXIT this function)
 bxne  r2 ;--> TxFunc (arm9_Wifi_TransmitFunction) ;/
;- - -
@@fail_dealloc:
 push lr  ;-->
 mov  r0,r1  ;MemBlk            ;\dealloc packet
 bl   sgIP_memblock_free        ;/
 pop  lr  ;<--
@@fail:
 mov  r0,0   ;fail
 bx   lr
;------------------
sgIP_Hub_IPMaxMessageSize:  ;in: r0=ipaddr, out: r0=maxsize
 ldr  r0,=SGIP_MTU_OVERRIDE     ;hack - should make this more accurate soon!
 bx   lr                        ;uh, soon?
;------------------
sgIP_Hub_GetCompatibleIP:  ;in: r0=destIP, out: r0=IP (or 0=none)
 push r4,lr
 ldr  r1,=HWInterfaces                  ;\
 mov  r2,SGIP_HUB_MAXHWINTERFACES       ; search
@@lop1:                                 ;
 ldrh r3,[r1,sgHubHwi_flags]            ; ;\
 tst  r3,SGIP_FLAG_HWINTERFACE_IN_USE   ; ; want USED entry
 bne  @@lop1_next  ;--> not used        ; ;/
 ldr  r3,[r1,sgHubHwi_ipaddr]           ; ;\
 eor  r3,r0   ;XOR destIP               ; ; and want it to match incoming destIP
 ldr  r4,[r1,sgHubHwi_snmask]           ; ;
 tst  r4,r3   ;subnet mask              ; ;
 ldreq r0,[r1,sgHubHwi_ipaddr]          ; ;
 beq   @@return_r0  ;--> found match    ; ;/
@@lop1_next:                            ;
 add  r1,sgHubHwi_size                  ;
 subs r2,1                              ;
 bne  @@lop1                            ;/
 ldr  r1,=HWInterfaces                  ;\
 mov  r2,SGIP_HUB_MAXHWINTERFACES       ; search
@@lop2:                                 ;
 ldrh r3,[r1,sgHubHwi_flags]            ; ;\
 tst  r3,SGIP_FLAG_HWINTERFACE_IN_USE   ; ; want USED entry
 ldrne r0,[r1,sgHubHwi_ipaddr]          ; ; (but ignore incoming destIP)
 bne   @@return_r0  ;--> found          ; ;/
 add  r1,sgHubHwi_size                  ;
 subs r2,1                              ;
 bne  @@lop2                            ;/
 mov  r0,0    ;not found                ;-none found
@@return_r0:
 pop  r4,pc   ;out: r0
;------------------
sgIP_Hub_GetDefaultInterface:  ;in: none, out: HubHwi (or 0=none)
 ldr  r1,=HWInterfaces                  ;\
 mov  r2,SGIP_HUB_MAXHWINTERFACES       ;
@@lop:                                  ;
 ldrh r3,[r1,sgHubHwi_flags]            ; search USED entry
 tst  r3,SGIP_FLAG_HWINTERFACE_IN_USE   ;
 bne  @@return_r1  ;--> found           ;
 add  r1,sgHubHwi_size                  ;
 subs r2,1                              ;
 bne  @@lop                             ;/
 mov  r1,0    ;not found                ;-none found
@@return_r1:
 mov  r0,r1   ;return value
 bx   lr
;------------------
htons:  ;adjust byte-order for "Host-to-Network" (short/16bit) ;in/out: r0
.if SGIP_LITTLEENDIAN  ;0000aabb
 orr  r0,r0,r0,lsl 16  ;aabbaabb
 mov  r0,r0,lsr 8      ;00aabbaa
 bic  r0,0ff0000h      ;0000bbaa
.endif
 bx   lr
;------------------
htonl:  ;adjust byte-order for "Host-to-Network" (long/32bit) ;in/out: r0
.if SGIP_LITTLEENDIAN  ;aabbccdd
 mov  r1,r0,lsl 24     ;dd000000
 orr  r1,r1,r0,lsr 24  ;dd0000aa
 and  r2,r0,0ff00h     ;0000cc00
 and  r0,r0,0ff0000h   ;00bb0000
 orr  r0,r1,r0,lsr 8   ;dd00bbaa
 orr  r0,r0,r2,lsl 8   ;ddccbbaa
.endif
 bx   lr
;------------------
ntohs equ htons ;\aliases for Host-to-Network and Network-to-Host
ntohl equ htonl ;/(both are same because they just reverse byte order if needed)
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_ICMP.c
;------------------
sgIP_ICMP_Init:  ;in/out: none
 bx   lr
;------------------
sgIP_ICMP_ReceivePacket:  ;in: r0=MemBlk, r1=srcip, r2=destip, out: r0
 push r4-r6,r8,lr
 mov  r4,r0  ;memblock
 mov  r5,r1  ;srcIP
 mov  r6,r2  ;destIP
 cmp  r4,0   ;memblock                  ;\exit if memblock=0
 beq  @@exit                            ;/
 ldr  r8,[r4,sgMemBlk_datastart]        ;-get ptr to IcmpHdr
 ldrh r0,[r8,sgIcmpHdr_checksum]   ;\   ;\
 cmp  r0,0                         ;    ;
 beq  @@no_chksum                  ;/   ; verify chksum (if any)
 mov  r0,r4  ;memblock             ;\   ;
 mov  r1,0   ;skip_len             ;    ; bad: "ICMP receive checksum incorrect"
 ldr  r2,[r4,sgMemBlk_totallength] ;    ;
 bl   sgIP_memblock_IPChecksum     ;    ;
 ldr  r1,=0ffffh                   ;    ;
 cmp  r0,r1                        ;    ;
 bne  @@fail                       ;/   ;
@@no_chksum:                            ;/
;- - -
 ldrb r0,[r8,sgIcmpHdr_type]            ;\
 cmp  r0,08h // beq @@echo_request      ; check type
;cmp  r0,00h // beq @@echo_reply        ;
;cmp  r0,xxh // beq @@other             ;/
;- - -
@@fail:
 mov  r0,r4  ;memblock                  ;\free
 bl   sgIP_memblock_free                ;/
@@exit:
 mov  r0,0                              ;-return 0
 pop  r4-r6,r8,pc
;---
@@echo_request:
 mov  r0,00h
 strb r0,[r8,sgIcmpHdr_type]     ;=00h          ;-change type to echo reply
 strh r0,[r8,sgIcmpHdr_checksum] ;=0000h        ;\
 mov  r0,r4  ;memblock                          ;
 mov  r1,0   ;skip_len                          ;
 ldr  r2,[r4,sgMemBlk_totallength]              ; adjust chksum for reply
 bl   sgIP_memblock_IPChecksum                  ;
 mvn  r0,r0     ;invert                         ;
 strh r0,[r8,sgIcmpHdr_checksum] ;=chksum       ;/
 mov  r0,r4  ;memblock                          ;\
 mov  r1,PROTOCOL_IP_ICMP                       ;
 mov  r2,r6  ;destIP                            ; send echo reply
 mov  r3,r5  ;srcIP                             ;
 bl   sgIP_IP_SendViaIP   ;out: r0              ;/
 pop  r4-r6,r8,pc         ;out: r0
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_IP.c
;------------------
.data?
idnum_count     dd 0
.code
;------------------
sgIP_IP_ReceivePacket:  ;in: r0=MemBlk, out: r0
 push r4-r6,r8,lr
;unsigned short * chksum_calc;                   ;BLAH
;chksum_calc=(unsigned short *)mb->datastart;    ;BLAH
 mov  r4,r0     ;memblock
        .if with_listen_log
        mov r0,13h // bl wrchr_r0
        mov r0,'R' // bl wrchr_r0
        mov r0,'X' // bl wrchr_r0
        mov r0,10h // bl wrchr_r0
        .endif
 ldr  r8,[r4,sgMemBlk_datastart] ;sgIpHdr=data  ;---get ptr to iphdr
 ldrb r5,[r8,sgIpHdr_version_ihl]               ;\get header len
 and  r5,0fh                                    ; (usually 5 words, 20 bytes)
 mov  r5,r5,lsl 2   ;words to bytes             ;/
 ldrh r0,[r8,sgIpHdr_tot_length]                ;\
 bl   htons                                     ; get total len
 mov  r6,r0  ;tot_length                        ;/
 ldr  r0,[r4,sgMemBlk_totallength]              ;\
 cmp  r0,r6                                     ; fail if "IP: bad length!"
 blo  @@fail                                    ;/
 mov  r0,r4  ;memblock                          ;\
 mov  r1,r6  ;tot_length                        ; trim size
 bl   sgIP_memblock_trimsize                    ;/
 ldrb r0,[r8,sgIpHdr_version_ihl]               ;\
 and  r0,0f0h                                   ; fail if "IP: bad version!"
 cmp  r0,040h                                   ;
 bne  @@fail                                    ;/
 mov  r0,r4  ;memblock                          ;\
 mov  r1,0   ;skip_len                          ;
 mov  r2,r5  ;hdrlen                            ;
 bl   sgIP_memblock_IPChecksum                  ; fail if "IP: bad checksum!"
 ldr  r1,=0ffffh                                ;
 cmp  r1,r0                                     ;
 bne  @@fail                                    ;/
 ldrh r0,[r8,sgIpHdr_fragment_offset]           ;\
 bl   htons                                     ; fail if "IP: fragmented!"
 bics r0,0c000h  ;aka "AND 3FFFh"               ; oh noes! We can't deal with this!
 bne  @@fail                                    ;/
 mov  r0,r4    ;memblock                        ;\
 rsb  r1,r5,0  ;0-hdrlen                        ;
 bl   sgIP_memblock_exposeheader                ;/
 ldrb r3,[r8,sgIpHdr_protocol]                  ;-get protocol
 cmp  r3,PROTOCOL_IP_ICMP                       ;\
 ldreq r3,=sgIP_ICMP_ReceivePacket              ; protocol = ICMP
 beq  @@this                                    ;/
.if with_tcp
 cmp  r3,PROTOCOL_IP_TCP                        ;\
 ldreq r3,=sgIP_TCP_ReceivePacket               ; protocol = TCP
 beq  @@this                                    ;/
.endif
 cmp  r3,PROTOCOL_IP_UDP                        ;\
 ldreq r3,=sgIP_UDP_ReceivePacket               ; protocol = UDP
 beq  @@this                                    ;/
 b    @@fail                                    ;-protocol = other (fail)
;---
@@this:
 mov  r0,r4  ;memblock                          ;\
 ldr  r1,[r8,sgIpHdr_src_address]               ; pass on to receive by protocol
 ldr  r2,[r8,sgIpHdr_dest_address]              ;
 bl   bx_r3     ;------> protocol/receive       ;/
 mov  r0,0      ;uh, return 0 here, too? (not return value from above bx_r3?)
 pop  r4-r6,r8,pc
;---
@@fail:

        .if with_listen_log
        mov r0,10h // bl wrchr_r0
        mov r0,'E' // bl wrchr_r0
        mov r0,'R' // bl wrchr_r0
        mov r0,'R' // bl wrchr_r0
        mov r0,11h // bl wrchr_r0
        .endif


 mov  r0,r4  ;memblock                          ;\
 bl   sgIP_memblock_free                        ;/
 mov  r0,0                                      ;-return 0
 pop  r4-r6,r8,pc
;------------------
sgIP_IP_MaxContentsSize:  ;in: r0=destIP, out: r0=size
 push r4,lr
;mov  r0,r0                                     ;\
 bl   sgIP_Hub_IPMaxMessageSize  ;in: r0=destIP ;
 mov  r4,r0                                     ;/
 bl   sgIP_IP_RequiredHeaderSize                ;\
 sub  r0,r4,r0    ;size = max-hdr               ;/
 pop  r4,pc
;------------------
sgIP_IP_RequiredHeaderSize:   ;out: r0
 ;uh, should be better to define that as CONSTANT instead of this function
 mov  r0,5*4    ;we'll not include zeroed options.      ;aka 20 aka sgXXX_size-4   ?
 bx   lr
;------------------
sgIP_IP_SendViaIP:  ;in: r0=MemBlk, r1=protocol, r2=srcIP, r3=destIP, out: r0
 push r4-r8,lr
 mov  r4,r0     ;memblock
 mov  r5,r1     ;protocol
 mov  r6,r2     ;srcIP
 mov  r7,r3     ;destIP
 mov  r0,r4     ;memblock                       ;\
 mov  r1,20                                     ;
 bl   sgIP_memblock_exposeheader                ;/
 ldr  r8,[r4,sgMemBlk_datastart] ;sgIpHdr=data  ;---get ptr to iphdr
 strb r5,[r8,sgIpHdr_protocol]        ;protocol ;\
 str  r6,[r8,sgIpHdr_src_address]     ;srcIP    ; params
 str  r7,[r8,sgIpHdr_dest_address]    ;destIP   ;/
 mov  r0,0                                      ;\
 strh r0,[r8,sgIpHdr_fragment_offset] ;0000h    ; zeroes
 strb r0,[r8,sgIpHdr_type_of_service] ;00h      ;/
 ldr  r1,=idnum_count  ;\                       ;\
 ldr  r0,[r1]          ; get/raise              ;
 add  r0,1             ; count                  ; id/count
 str  r0,[r1]          ;/                       ;
 strh r0,[r8,sgIpHdr_identification]  ;count    ;/
 ldr  r0,[r4,sgMemBlk_totallength]              ;\
 bl   htons                                     ; length
 strh r0,[r8,sgIpHdr_tot_length]      ;len      ;/
 mov  r0,SGIP_IP_TTL                            ;\time-to-live
 strb r0,[r8,sgIpHdr_TTL]                       ;/
 mov  r0,45h                                    ;\version (4), and
 strb r0,[r8,sgIpHdr_version_ihl]               ;/headerlen (5 words)
 mov  r0,0     ;chksum.initial                  ;\
 strh r0,[r8,sgIpHdr_header_checksum] ;0000h    ;
 mov  r2,10    ;chksum.lopcount                 ;  ;<-- uh, is that "(sgIpHdr_size-4)/2" ???
 mov  r3,r8    ;chksum.start                    ;
@@chksum_lop:                                   ;
 ldrh r1,[r3],2                                 ; checksum on 20 bytes
 add  r0,r1    ;chksum                          ; (aka 10 halfwords)
 subs r2,1     ;chksum.lopcount                 ;
 bne  @@chksum_lop                              ;
 adds r0,r0,r0,lsl 16  ;msw+lsw                 ;
  addcss r0,10000h        ;plus CY               ;
  addcss r0,10000h        ;plus CY on CY         ;
        ;BUGGED: probably should add CY on CY (as done in other checksum funcs?)
        ;and 'unclean' in original code: variable is named "chksum_temp" here
        ;  (whilst most other/similar functions have it named "checksum")
        ;and a general issue for all those checksum functions:
        ;  the checksum is defined as (signed?) "int", so the right-shifting
        ;  would sign-extended "negative" checksums? (though the sign in bit31
        ;  will be probably usually zero, unless for very large packets)
 mvn  r0,r0            ;invert                  ;
 movs r0,r0,lsr 16     ;isolate 16bit           ;
 ldreq r0,=0ffffh      ;uh, so? (condition in original C code was BUGGED: set MSW=0, then MSW=(not 0), then checking if value=0... which cannot ever happen due to MSW=FFFFh)
 strh r0,[r8,sgIpHdr_header_checksum] ;chksum   ;/
 mov  r0,PROTOCOL_ETHER_IP                      ;\
 mov  r1,r4     ;-memblock                      ;
 mov  r2,r7     ;-destIP                        ; send
 mov  r3,r6     ;-srcIP                         ;
 bl   sgIP_Hub_SendProtocolPacket  ;out: r0     ;/
 pop  r4-r8,pc
;------------------
sgIP_IP_GetLocalBindAddr:  ;in:r0=srcIP, r1=destIP, out: r0=IP
 cmp  r0,0  ;srcIP              ;\if srcIP<>0 then return srcIP
 bxne lr    ;out: r0=srcIP      ;/
 mov  r0,r1 ;destIP             ;\else get compatible IP for destIP
 b    sgIP_Hub_GetCompatibleIP  ;/
;------------------
.pool
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_memblock.c
;------------------
.data?
.ifndef SGIP_MEMBLOCK_DYNAMIC_MALLOC_ALL
 .ifndef SGIP_USEDYNAMICMEMORY
   memblock_pool: defs sgMemBlk_size*SGIP_MEMBLOCK_BASENUM   ;MemBlk's
 .else
   ;memblock_pool dd 0  ;<-- BLAH ptr to allocated memory (but no longer needed after adding that memory to the "memblock_poolfree" chain)
 .endif
 ;---
 memblock_poolfree dd 0   ;chain entry for list of free MemBlk's
 ;---
 ;int numused, numfree;  ;<-- BLAH that are used only for debug messages
 ;void * pool_link;      ;<-- BLAH that's initialized, but NOT USED elsewhere
.endif
.code
;------------------
.ifndef SGIP_MEMBLOCK_DYNAMIC_MALLOC_ALL
sgIP_memblock_getunused:  ;in: none, out: r0=MemBlk (or 0=none)
 push r4,lr
 bl   sgIP_IntrProtect                          ;\
;mov  r0,r0                                     ;/
 ldr  r1,=memblock_poolfree                     ;\get 1st free MemBlk (0=one)
 ldr  r4,[r1]   ;first=[memblock_poolfree]      ;/
 cmp   r4,0                                     ;\if got okay, then mark the
 ldrne r2,[r4,sgMemBlk_next]                    ; next memblk as 1st-free one
 strne r2,[r1]  ;[memblock_poolfree]=next       ;/
;mov  r0,r0                                     ;\
 bl   sgIP_IntrUnprotect                        ;/
 mov  r0,r4     ;return r0=MemBlk (or 0=none/failed)
 pop  r4,pc
.endif  ;SGIP_MEMBLOCK_DYNAMIC_MALLOC_ALL
;------------------
sgIP_memblock_Init:  ;in/out: none
 .ifndef SGIP_MEMBLOCK_DYNAMIC_MALLOC_ALL
   .ifdef SGIP_USEDYNAMICMEMORY
     push lr  ;-->                                      ;\
     mov  r0,(sgMemBlk_size*SGIP_MEMBLOCK_BASENUM)      ; alloc memory
     bl   sgIP_malloc                                   ;
     pop  lr  ;<--                                      ;
    ;mov  r0,r0 ;allocated  ;array start (first block)  ;/
   .else
     ldr  r0,=memblock_pool ;array start (first block)  ;-pre-allocated memory
   .endif
   mov  r1,0                ;previous block (none for first block)   ;\
   mov  r2,SGIP_MEMBLOCK_BASENUM    ;-lopcount                       ; put all
  @@lop:                                                             ; memblk's
   mov  r3,0                            ;\clear length               ; into
   str  r3,[r0,sgMemBlk_totallength]    ;/                           ; list of
   str  r1,[r0,sgMemBlk_next]           ;-chain prev (if any)        ; EMPTY
   mov  r1,r0                           ;-prev = current             ; memblk's
   add  r0,sgMemBlk_size            ;\                               ;
   subs r2,1                        ; lop next memblk                ;
   bne  @@lop                       ;/                               ;
   ldr  r3,=memblock_poolfree   ;\store entry to free-block-chain    ;
   str  r0,[r3]  ;=prev/last    ;/(starting with last added memblk)  ;/
 .endif ;SGIP_MEMBLOCK_DYNAMIC_MALLOC_ALL
 bx   lr
;------------------
sgIP_memblock_alloc:  ;in: r0=packetsize, out: r0=MemBlk
 mov  r1,r0  ;packet.size       ;\
 mov  r0,0   ;hdr.size          ; redirect (with extra param: hdr.size=0)
 b    sgIP_memblock_allocHW     ;/
;------------------
sgIP_memblock_allocHW:  ;in: r0=headersize, r1=packetsize, out: r0=MemBlk (or 0=none)
 push r4-r8,lr
 mov  r4,r0  ;headersize
 mov  r5,r1  ;packetsize
 .ifdef SGIP_MEMBLOCK_DYNAMIC_MALLOC_ALL
   add  r0,r5,SGIP_MEMBLOCK_HEADERSIZE+SGIP_MAXHWHEADER ;\
   bl   sgIP_malloc     ;alloc(packetsize+CONSTANTS)    ; alloc all at once
   cmp  r0,0                                            ;
   beq  @@failed    ;out: r0=0=failed                   ;/
   add  r2,r4,r5  ;headersize+packetsize ;\             ;\
   str  r2,[r0,sgMemBlk_totallength]     ;              ;
   str  r2,[r0,sgMemBlk_thislength]      ;/             ;
   add  r1,r0,sgMemBlk_reserved          ;\             ; init
   add  r1,SGIP_MAXHWHEADER              ;              ;
   sub  r1,r4  ;sub used "headersize"    ;              ;
   str  r1,[r0,sgMemBlk_datastart]       ;/             ;
   mov  r1,0                             ;\             ;
   str  r1,[r0,sgMemBlk_next]            ;/             ;/
 .else ;- - - - - - - SGIP_MEMBLOCK_DYNAMIC_MALLOC_ALL=0 ...
   bl   sgIP_memblock_getunused                         ;\
   cmp  r0,0                                            ; alloc first part
   beq  @@failed    ;out: r0=0=failed                   ;/
   add  r2,r4,r5  ;headersize+packetsize ;\             ;\
   str  r2,[r0,sgMemBlk_totallength]     ;              ;
   str  r2,[r0,sgMemBlk_thislength]      ;/             ;
   add  r1,r0,sgMemBlk_reserved          ;\             ; init
   add  r1,SGIP_MAXHWHEADER              ;              ;
   sub  r1,r4  ;sub used "headersize"    ;              ;
   str  r1,[r0,sgMemBlk_datastart]       ;/             ;
   mov  r1,0                             ;\             ;
   str  r1,[r0,sgMemBlk_next]            ;/             ;/
   add  r3,r4,SGIP_MEMBLOCK_FIRSTINTERNALSIZE   ;max    ;\
  ;ldr  r2,[r0,sgMemBlk_totallength]            ;total  ; done if not exceeding
   cmp  r3,r2          ;compare max,totel_len   ;       ; max length limit
   bhs  @@done                                  ;       ;/
   str  r3,[r0,sgMemBlk_thislength]             ;max    ;-
;- - - need more blocks (these WITHOUT header, unlike as FIRST part)
   mov  r6,r0   ;memorize FIRST memblock (as return value)
   mov  r8,0    ;index
  @@lop:
   mov  r7,r0   ;memorize PREV memblock
   ldr  r1,[r7,sgMemBlk_thislength]             ;\raise index
   add  r8,r1     ;index+thislen                ;/by prev len
   bl   sgIP_memblock_getunused                         ;\
   cmp  r0,0                                            ; alloc NEXT part
   beq  @@failed_dealloc_all                            ;/
   str  r0,[r7,sgMemBlk_next]       ;-append to PREV memblk
   mov  r1,0                        ;\chain end here
   str  r1,[r0,sgMemBlk_next]       ;/
  ;- - -
  ;BUGGED: original code points "CURR memblk's datastart to FIRST memblk"
  ;FIX:    below bugfix points "CURR memblk's datastart to CURR memblk"
   add  r1,r0,sgMemBlk_reserved         ;\  ;<-- bugfixed
   str  r1,[r0,sgMemBlk_datastart]      ;/
  ;- - -
   mov  r1,SGIP_MEMBLOCK_INTERNALSIZE   ;\
   str  r1,[r0,sgMemBlk_thislength]     ;/
   ldr  r1,[MB,sgMemBlk_totallength]    ;\
   str  r1,[r0,sgMemBlk_totallength] ;\ ;/
   sub  r1,r8  ;remain = total-index ;/;\   ;\
   cmp  r1,SGIP_MEMBLOCK_INTERNALSIZE  ;    ; lop if needing YET more blocks
   bhi  @@lop                          ;    ;/
   str  r1,[r0,sgMemBlk_thislength]    ;/   ;-apply remain as last size
  ;SGIP_DEBUG_MESSAGE(("memblock_alloc: %i free, %i used",numfree,numused));
   mov  r0,r6   ;\return r0 = FIRST memblock of chain
   b    @@done  ;/
  ;---
  @@failed_dealloc_all:  ;we're skrewed, delloc whole chain (from FIRST memblock and up)
   mov  r0,r6                   ;\
   bl   sgIP_memblock_free      ;/
   mov  r0,0  ;out: r0=0 (none/failed)
   b    @@failed
  ;---
 .endif ;SGIP_MEMBLOCK_DYNAMIC_MALLOC_ALL
@@done:       ;out: r0=MemBlk
@@failed:     ;out: r0=0 (none/failed)
 pop  r4-r8,pc
;------------------
sgIP_memblock_free:  ;in: r0=MemBlk, out: none
 push r4-r5,lr
 mov  r4,r0  ;MemBlk    ;-first memblk (of chain)
 bl   sgIP_IntrProtect          ;\
 mov  r5,r0                     ;/
@@lop:
 cmp  r4,0   ;MemBlk    ;\until last memblk (of chain)
 beq  @@done            ;/
 mov  r0,0                                      ;\
 str  r0,[r4,sgMemBlk_totallength]              ; clear length entries
 str  r0,[r4,sgMemBlk_thislength]               ;/
 mov  r0,r4                  ;old MemBlk        ;\
 ldr  r4,[r0,sgMemBlk_next]  ;next MemBlk       ;/
 .ifdef SGIP_MEMBLOCK_DYNAMIC_MALLOC_ALL
    ;mov  r0,r0   ;old MemBlk                   ;\dealloc old MemBlk
     bl   sgIP_free                             ;/
 .else
     ldr  r1,=memblock_poolfree                 ;\move the old MemBlk
     ldr  r2,[r1]  ;old first free memblk       ; to begin of the
     str  r0,[r1]  ;new first free memblk       ; free-pool-chain
     str  r2,[r0,sgMemBlk_next]                 ;/
 .endif
 b    @@lop                                     ;-next MemBlk (if any)
@@done:
;SGIP_DEBUG_MESSAGE(("memblock_free: %i free, %i used",numfree,numused));
 mov  r0,r5                     ;\
 bl   sgIP_IntrUnprotect        ;/
 pop  r4-r5,pc
;------------------
sgIP_memblock_exposeheader:  ;in: r0=MemBlk, r1=offset, out: none
;positive offset to expose, negative to hide
 cmp  r0,0   ;MemBlk            ;\exit if MemBlk is zero
 bxeq lr                        ;/
 ldr  r3,[r0,sgMemBlk_datastart]        ;\
 sub  r3,r1                             ; decrease datastart
 str  r3,[r0,sgMemBlk_datastart]        ;/
 ldr  r3,[r0,sgMemBlk_thislength]       ;\
 add  r3,r1                             ; raise thislength
 str  r3,[r0,sgMemBlk_thislength]       ;/
 ldr  r3,[r0,sgMemBlk_totallength]      ;\
 add  r3,r1                             ; raise totallength
@@lop:                                  ;   (of current memblk,
 str  r3,[r0,sgMemBlk_totallength]      ;   and also of all following
 ldr  r0,[r0,sgMemBlk_next]  ;\         ;   chained memblk's)
 cmp  r0,0                   ; next     ;
 bne  @@lop                  ;/         ;/
 bx   lr
;------------------
sgIP_memblock_trimsize:  ;in: r0=MemBlk, r1=newsize, out: none
 cmp  r0,0              ;\exit if memblk is zero
 bxeq lr                ;/
 str  r1,[r0,sgMemBlk_totallength]      ;-apply newsize
;BUGGED: should "sgMemBlk_totallength" be also adjusted in below @@lop entries?
;        (ie. similar as done in the "sgIP_memblock_exposeheader" function?)
 mov  r2,0      ;lentot=0                                       ;\
@@lop:                                                          ;
 ldr  r3,[r0,sgMemBlk_thislength]                               ;
 add  r2,r3  ;lentot+thislen    ;-raise                         ;
 cmp  r2,r1  ;lentot,newsize    ;\check if exceeding new size   ;
 bhi  @@truncate                ;/                              ;
 ldr  r0,[r0,sgMemBlk_next]     ;\                              ;
 cmp  r0,0                      ; next chained memblk (if any)  ;
 bne  @@lop                     ;/                              ;/
 bx   lr
;---
@@truncate:
 sub  r2,r1  ;lentot-newsize            ;\
 ldr  r3,[r0,sgMemBlk_thislength]       ; decrease thislen of CURRENT memblk
 sub  r3,r2                             ;
 str  r3,[r0,sgMemBlk_thislength]       ;/
 ldr  r2,[r0,sgMemBlk_next]             ;-get next memblk (if any)
 mov  r1,0                              ;\remove next memblk from chain
 str  r1,[r0,sgMemBlk_next]             ;/
 movs r0,r2  ;next (if any)             ;\dealloc next memblk (if any)
 bne  sgIP_memblock_free                ;/(and return there)
 bx   lr                                ;-return here
;------------------
sgIP_memblock_with_faux_header_IPChecksum:  ;in: r0=MemBlk, r1=srcip, r2=destip, r3=protocol
 push r4-r5,lr
 mov  r4,r0  ;MemBlk
 add  r5,r3,r1,lsr 16  ;add MSW(srcip)+protocol ;\
 add  r5,r5,r2,lsr 16  ;add MSW(destip)         ;
 mov  r1,r1,lsl 16     ;isolate LSW(srcip)      ;
 mov  r2,r2,lsl 16     ;isolate LSW(destip)     ; checksum on "faux header"
 add  r5,r5,r1,lsr 16  ;add LSW(srcip)          ;
 add  r5,r5,r2,lsr 16  ;add LSW(destip)         ;
 ldr  r0,[r4,sgMemBlk_totallength]              ;
 bl   htons            ;16bit(len)              ;
 add  r5,r5,r0         ;add htons(len)          ;/
 ldr  r2,[r4,sgMemBlk_totallength]              ;\
 tst  r2,1                                      ; if data has ODD length,
 ldrne  r1,[r4,sgMemBlk_datastart]              ; append a zero-padding byte
 movne  r0,00h                                  ;   ;uh, why/what for?
 strneb r0,[r1,r2]  ;[datastart+totallength]    ;/
 mov  r0,r4  ;MemBlk                            ;\
 mov  r1,0   ;skip_len                          ;
 ldr  r2,[r4,sgMemBlk_totallength]              ; plus IPchecksum on MemBlk
 bl   sgIP_memblock_IPChecksum                  ;
 add  r0,r5              ;add IPchecksum        ;/
 adds   r0,r0,r0,lsl 16  ;MSW+LSW               ;\
 addcss r0,10000h        ;plus CY               ; checksum MSW+LSW
 addcss r0,10000h        ;plus CY on CY         ;
 mov    r0,r0,lsr 16     ;back to LSW           ;/
 pop  r4-r5,pc
;------------------
sgIP_memblock_IPChecksum:  ;in: r0=MemBlk, r1=skip_len, r2=chk_len, out: r0
 push  r4-r8,lr
;BLAH: incoming "skip_len" is ALWAYS zero
 mov   r4,r0  ;MemBlk                   ;\
 mov   r5,0   ;checksum=0               ; memorize params and set checksum=0
 mov   r6,r1  ;skip_len                 ;/
 subs  r7,r2,0;copy_len (aka check_len) ;\abort if copy_len<=0
 ble   @@abort                          ;/
 ldr   r0,[r4,sgMemBlk_totallength]     ;\
 sub   r0,r6  ;total-skip               ; clip copy_len to MAX=(total-skip_len)
 cmp   r7,r0  ;copy_len,max             ; (note: not handled in original code)
 movhi r7,r0  ;copy_len=max             ;/
@@pre_skip_lop:                                 ;\
 cmp   r4,0   ;MemBlk              ;\check mb=0 ;
 beq   @@abort ;out: num_copied=0  ;/           ; skip MemBlk's until "skip_len"
 ldr   r0,[r4,sgMemBlk_thislength] ;\check skip ; is within current MemBlk
 cmp   r6,r0  ;skip,thislen        ;/           ; (or until no more MemBlk's
 subhs r6,r0  ;skip-thislen        ;\           ; exist in chain)
 ldrhs r4,[r4,sgMemBlk_next]       ; next       ;
 bhs   @@pre_skip_lop              ;/           ;/
;- - -
 mov   r3,0    ;shift amount (0 or 8, for even/odd bytes)
@@check_lop:
 ldr   r0,[r4,sgMemBlk_datastart]       ;\src (MemBlk)  ;\
 add   r0,r6     ;start+skip_len        ;/              ;
 ldr   r2,[r4,sgMemBlk_thislength]      ;\              ; compute src/len
 cmp   r2,r7    ;thislen,copy_len       ; len           ;
 movhi r2,r7    ;len=copy_len           ;/              ;
 sub   r7,r2  ;decrease copy_len        ;-decrease      ;/
 tst   r0,1      ;want src=even         ;\              ;\
 tsteq r2,1      ;want len=even         ; use QUICK lop ;
 tsteq r3,8      ;want shift=even       ; if all even   ;
 beq   @@quick_halfword_lop             ;/              ;
@@slow_8bit_lop:                        ;\              ; do checksumming
 ldrb  r1,[r0],1           ;src ;\      ;               ;
 add   r5,r5,r1,lsl r3     ;chk ; 8bit  ; slow 8bit     ;
 eor   r3,8 ;toggle shift  ;shf ;       ;               ;
 subs  r2,1                ;len ;/      ;               ;
 bne   @@slow_8bit_lop                  ;/              ;
 b     @@check_next                                     ;
;---                                                    ;
@@quick_halfword_lop:                   ;\              ;
 ldrh  r1,[r0],2           ;src ;\      ;               ;
 add   r5,r1               ;chk ; 16bit ; quick 16bit   ;
 subs  r2,2                ;len ;/      ;               ;
 bne   @@quick_halfword_lop             ;/              ;/
;- - -
@@check_next:
 ;BUGGED: original code DOES ONLY CONTINUE at next memblk (via "mb=mb->next")
 ;        in ODD cases (when a halfword wraps last/first bytes of two memblk's),
 ;        whilst NORMAL cases (without wrap) do simply ABORT checksumming, outch
;- - -
 ;below check MSW+LSW merging is done INSIDE of @@check_lop to avoid overflows,
 ;(which could otherwise happen when checksumming more than 128Kbytes at once)
 adds   r5,r5,r5,lsl 16  ;MSW+LSW               ;\
 addcss r5,10000h        ;plus CY               ; checksum MSW+LSW
 addcss r5,10000h        ;plus CY on CY         ;
 mov    r5,r5,lsr 16     ;back to LSW           ;/
 mov   r6,0   ;skip_len=0 (for next memblk's)
 cmp   r7,0   ;copy_len                 ;\
 ldrne r4,[r4,sgMemBlk_next]            ; lop next, until copy_len=0
 cmpne r4,0   ;MemBlk                   ; (or until no more memblk's)
 bne   @@check_lop                      ;/
;- - - done
@@abort:
 mov  r0,r5     ;out: r0=checksum
 pop  r4-r8,pc
;------------------
sgIP_memblock_CopyToLinear:  ;in: r0=MemBlk.src, r1=dest_buf, r2=skip_len, r3=copy_len, out: r0
 ;same as "sgIP_memblock_CopyFromLinear" (but with memcopy's src/dest swapped)
 push  r4-r8,lr
 mov   r8,0   ;num_copied=0             ;-
 mov   r4,r0  ;MemBlk                   ;\
 mov   r5,r1  ;buf                      ; memorize params
 mov   r6,r2  ;skip_len                 ;/
 subs  r7,r3,0;copy_len                 ;\abort if copy_len<=0
 ble   @@abort                          ;/
 ldr   r0,[r4,sgMemBlk_totallength]     ;\
 sub   r0,r6  ;total-skip               ; clip copy_len to MAX=(total-skip_len)
 cmp   r7,r0  ;copy_len,max             ;
 movhi r7,r0  ;copy_len=max             ;/
@@pre_skip_lop:                                 ;\
 cmp   r4,0   ;MemBlk              ;\check mb=0 ;
 beq   @@abort ;out: num_copied=0  ;/           ; skip MemBlk's until "skip_len"
 ldr   r0,[r4,sgMemBlk_thislength] ;\check skip ; is within current MemBlk
 cmp   r6,r0  ;skip,thislen        ;/           ; (or until no more MemBlk's
 subhs r6,r0  ;skip-thislen        ;\           ; exist in chain)
 ldrhs r4,[r4,sgMemBlk_next]       ; next       ;
 bhs   @@pre_skip_lop              ;/           ;/
;- - -
        .if 0       ;XNAY
        mov r0,'-' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
        mov r0,'C' // bl wrchr_r0
        mov r0,'O' // bl wrchr_r0
        mov r0,'P' // bl wrchr_r0
        mov r0,'Y' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
        .endif
@@copy_lop:
 ldr   r0,[r4,sgMemBlk_datastart]       ;\src (MemBlk)  ;\
 add   r0,r6     ;start+skip_len        ;/              ;
 mov   r1,r5     ;buf                   ;-dst (linear)  ;
 ldr   r2,[r4,sgMemBlk_thislength]      ;\              ; copy fragment
 cmp   r2,r7    ;thislen,copy_len       ; len           ; (and adjust
 movhi r2,r7    ;len=copy_len           ;/              ; length counters)
 sub   r7,r2  ;decrease copy_len   ;\increase/decrease  ;
 add   r8,r2  ;increase num_copied ;/length counters    ;
 bl    memcopy_bytewise                                 ;/
 mov   r6,0   ;skip_len=0 (for next memblk's)
 cmp   r7,0   ;copy_len                 ;\
 ldrne r4,[r4,sgMemBlk_next]            ; lop next, until copy_len=0
 cmpne r4,0   ;MemBlk                   ; (or until no more memblk's)
 bne   @@copy_lop                       ;/
@@abort:
 mov  r0,r8     ;out: r0=num_copied (should be same as incoming copy_len,
 pop  r4-r8,pc  ;     but CAN be LESS than copy_len if memblock was smaller)
;------------------
sgIP_memblock_CopyFromLinear:  ;in: r0=MemBlk.dest, r1=src_buf, r2=skip_len, r3=copy_len, out: r0
 ;same as "sgIP_memblock_CopyToLinear" (but with memcopy's src/dest swapped)
 push  r4-r8,lr
 mov   r8,0   ;num_copied=0             ;-
 mov   r4,r0  ;MemBlk                   ;\
 mov   r5,r1  ;buf                      ; memorize params
 mov   r6,r2  ;skip_len                 ;/
 subs  r7,r3,0;copy_len                 ;\abort if copy_len<=0
 ble   @@abort                          ;/
 ldr   r0,[r4,sgMemBlk_totallength]     ;\
 sub   r0,r6  ;total-skip               ; clip copy_len to MAX=(total-skip_len)
 cmp   r7,r0  ;copy_len,max             ;
 movhi r7,r0  ;copy_len=max             ;/
@@pre_skip_lop:                                 ;\
 cmp   r4,0   ;MemBlk              ;\check mb=0 ;
 beq   @@abort ;out: num_copied=0  ;/           ; skip MemBlk's until "skip_len"
 ldr   r0,[r4,sgMemBlk_thislength] ;\check skip ; is within current MemBlk
 cmp   r6,r0  ;skip,thislen        ;/           ; (or until no more MemBlk's
 subhs r6,r0  ;skip-thislen        ;\           ; exist in chain)
 ldrhs r4,[r4,sgMemBlk_next]       ; next       ;
 bhs   @@pre_skip_lop              ;/           ;/
;- - -
@@copy_lop:
 mov   r0,r5     ;buf                   ;-src (linear)  ;\
 ldr   r1,[r4,sgMemBlk_datastart]       ;\dst (MemBlk)  ;
 add   r1,r6     ;start+skip_len        ;/              ;
 ldr   r2,[r4,sgMemBlk_thislength]      ;\              ; copy fragment
 cmp   r2,r7    ;thislen,copy_len       ; len           ; (and adjust
 movhi r2,r7    ;len=copy_len           ;/              ; length counters)
 sub   r7,r2  ;decrease copy_len   ;\increase/decrease  ;
 add   r8,r2  ;increase num_copied ;/length counters    ;
 bl    memcopy_bytewise                                 ;/
 mov   r6,0   ;skip_len=0 (for next memblk's)
 cmp   r7,0   ;copy_len                 ;\
 ldrne r4,[r4,sgMemBlk_next]            ; lop next, until copy_len=0
 cmpne r4,0   ;MemBlk                   ; (or until no more memblk's)
 bne   @@copy_lop                       ;/
@@abort:
 mov  r0,r8     ;out: r0=num_copied (should be same as incoming copy_len,
 pop  r4-r8,pc  ;     but CAN be LESS than copy_len if memblock was smaller)
;------------------
;sgIP_memblock_CopyBlock:  ;in: r0=MemBlk.src, r1=MemBlk.dst, r2=start_src, r3=start_dest, r4=copy_length), out: r0
; return 0;
;BLAH: this function is UNUSED and NONFUNCTIONAL - it doesn't copy anything!
;------------------
.pool
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_sockets.c
;------------------
;note: original code uses "socket" values in range "N=1..SGIP_SOCKET_MAXSOCKETS"
;as parameters/return values for socket functions, the a22i code does instead
;use pointers to the corresponding socket entry, ie. "socketlist[N-1]".
;------------------
;BUGGED: original code does "return -1" (without "errno") in several "socket.c"
;functions; in some cases. And, the SAME functions do "return SGIP_ERROR(xx)"
;(with "errno") in other cases. The uninitialized "errno" cases could result in
;very weird effects (when user code is actually handling the "errno" values).
;- - -
;also odd: some socket functions return EBADF (instead EINVAL) is that wanted?
;------------------
.data?
socketlist:     defs sgSockDta_size*SGIP_SOCKET_MAXSOCKETS
.code
;------------------
sgIP_sockets_Init:  ;in/out: none
 mov  r2,SGIP_SOCKET_MAXSOCKETS
 ldr  r1,=socketlist
 mov  r0,0
@@lop:
 str  r0,[r1,sgSockDta_conn_ptr]  ;=0
 str  r0,[r1,sgSockDta_flags]     ;=0
 add  r1,sgSockDta_size         ;\
 subs r2,1                      ; lop next
 bne  @@lop                     ;/
 bx   lr
;------------------
sgIP_sockets_Timer1000ms:  ;in/out: none
;Additional timer routine that cleans up after half-closed sockets.
 push r4-r6,lr
.if with_tcp
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 ldr  r5,=socketlist
 mov  r6,SGIP_SOCKET_MAXSOCKETS
@@lop:
 ldr  r0,[r5,sgSockDta_flags]           ;\check if closing
 tst  r0,SGIP_SOCKET_FLAG_CLOSING       ; (this can occur for TCP only,
 beq  @@lop_next                        ;/never for UDP)
 ldr  r1,[r5,sgSockDta_conn_ptr]        ;\
 ldr  r2,[r1,sgTcpRec_tcpstate]         ; check if finally fully closed,
 cmp  r2,SGIP_TCP_STATE_CLOSED          ; if so, clean up
 beq  @@forceclose                      ;/
;ldr  r0,[r5,sgSockDta_flags]           ;\
 ldr  r1,=SGIP_SOCKET_MASK_CLOSE_COUNT  ; check if closing timed out,
 tst  r0,r1   ;test mask                ; if so, clean up
 beq  @@forceclose                      ;/
 sub  r0,1 shl SGIP_SOCKET_SHIFT_CLOSE_COUNT    ;\decrement close timeout
 str  r0,[r5,sgSockDta_flags]                   ;/for future reference
 b    @@lop_next
;---
@@forceclose:

        .if 0       ;XNAY
        mov r0,10h // bl wrchr_r0
        mov r0,'S' // bl wrchr_r0
        mov r0,'O' // bl wrchr_r0
        mov r0,'C' // bl wrchr_r0
        mov r0,'K' // bl wrchr_r0
        mov r0,'D' // bl wrchr_r0
        mov r0,'E' // bl wrchr_r0
        mov r0,'A' // bl wrchr_r0
        mov r0,'D' // bl wrchr_r0
        mov r0,11h // bl wrchr_r0
       .endif


 mov  r0,r5  ;socket
 bl   forceclosesocket
@@lop_next:
 add  r5,sgSockDta_size         ;\
 subs r6,1                      ; lop next
 bne  @@lop                     ;/
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
.endif ;with_tcp
 pop  r4-r6,pc
;------------------
socket:  ;in: r0=domain, r1=type, r2=protocol, out: r0
 push r4-r9,lr
 mov  r5,r0  ;domain
 mov  r6,r1  ;type
 mov  r7,r2  ;protocol
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp   r6,SOCK_DGRAM  ;type ;\  ;\
.if with_tcp
 cmpne r6,SOCK_STREAM ;type ;/  ;
.endif
 cmpeq r5,AF_INET     ;domain   ; verify params
 cmpeq r7,0           ;protocol ;
 bne   @@error_incoming_value   ;/
 ldr  r8,=socketlist                            ;\
 mov  r9,SGIP_SOCKET_MAXSOCKETS                 ;
@@lop:                                          ;
 ldr  r0,[r8,sgSockDta_flags]                   ; search a free socket
 tst  r0,SGIP_SOCKET_FLAG_ALLOCATED             ;
 beq  @@found_free_socket   ;-->                ;
 add  r8,sgSockDta_size         ;\              ;
 subs r9,1                      ; lop next      ;
 bne  @@lop                     ;/              ;/

        .if 0       ;XNAY
        mov r0,'-' // bl wrchr_r0
        mov r0,'N' // bl wrchr_r0
        mov r0,'O' // bl wrchr_r0
        mov r0,'S' // bl wrchr_r0
        mov r0,'O' // bl wrchr_r0
        mov r0,'C' // bl wrchr_r0
        mov r0,'K' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
       .endif

;- - -
@@error_no_memory:
 bl   sgIP_error_nomem  ;out: r0
 b    @@return_r0
;---
@@error_incoming_value:
 bl   sgIP_error_inval  ;out: r0
 b    @@return_r0
;---
@@found_free_socket:
 mov  r9,SGIP_SOCKET_FLAG_ALLOCATED+SGIP_SOCKET_FLAG_VALID
 .ifdef SGIP_SOCKET_DEFAULT_NONBLOCK    ;\
   orr  r9,SGIP_SOCKET_FLAG_NONBLOCKING ; optional: default=nonblocking
 .endif                                 ;/
.if with_tcp
 cmp   r6,SOCK_STREAM ;type                     ;\      ;\
 orreq r9,SGIP_SOCKET_FLAG_TYPE_TCP             ; TCP   ;
 bleq  sgIP_TCP_AllocRecord  ;out: r0=record    ;/      ; alloc
.endif
 cmp   r6,SOCK_DGRAM  ;type                     ;\      ; TCP or UDP
 orreq r9,SGIP_SOCKET_FLAG_TYPE_UDP             ; UDP   ; record
 bleq  sgIP_UDP_AllocRecord  ;out: r0=record    ;/      ;
 cmp  r0,0  ;record                                     ;
 beq  @@error_no_memory                                 ;/
 str  r0,[r8,sgSockDta_conn_ptr]        ;-link socket to that TCP/UDP record
 str  r9,[r8,sgSockDta_flags]           ;-mark socket allocated and apply flags
 mov  r0,r8  ;okay, return socket       ;-done okay
@@return_r0:
 mov  r5,r0  ;return value (socket, or -1 = bad, with [errno])
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5    ;out: r0
 pop  r4-r9,pc
;------------------
spawn_socket:  ;in: r0=flags, out: r0
;spawn socket (and kill socket) for internal use ONLY.
 push r4-r7,lr
 orr  r5,r0,SGIP_SOCKET_FLAG_ALLOCATED+SGIP_SOCKET_FLAG_VALID   ;flags
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 ldr  r6,=socketlist                            ;\
 mov  r7,SGIP_SOCKET_MAXSOCKETS                 ;
@@lop:                                          ;
 ldr  r0,[r6,sgSockDta_flags]                   ; search a free socket
 tst  r0,SGIP_SOCKET_FLAG_ALLOCATED             ;
 beq  @@found_free_socket   ;-->                ;
 add  r6,sgSockDta_size         ;\              ;
 subs r7,1                      ; lop next      ;
 bne  @@lop                     ;/              ;/

        .if 0       ;XNAY
        mov r0,'-' // bl wrchr_r0
        mov r0,'N' // bl wrchr_r0
        mov r0,'O' // bl wrchr_r0
        mov r0,'S' // bl wrchr_r0
        mov r0,'O' // bl wrchr_r0
        mov r0,'C' // bl wrchr_r0
        mov r0,'K' // bl wrchr_r0
        mov r0,'X' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
       .endif

;- - -
@@error_no_memory:
 bl   sgIP_error_nomem  ;out: r0=-1 = bad, with [errno]
 b    @@return_r0
;---
@@found_free_socket:
 str  r5,[r6,sgSockDta_flags]     ;=flags       ;\mark allocated & apply flags,
 mov  r0,0                                      ; but no record connected yet
 str  r0,[r6,sgSockDta_conn_ptr]  ;=0           ;/
 mov  r0,r6  ;return value (socket)
@@return_r0:
 mov  r5,r0  ;return value (socket, or -1 = bad, with [errno])
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5    ;out: r0
 pop  r4-r7,pc
;------------------
kill_socket:  ;in: r0=socket, out: r0
 push r4-r5,lr
 mov  r5,r0  ;socket
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp  r5,0                              ;\exit if no socket
 beq  @@return_error_einval             ;/
 mov  r0,0                              ;\
 str  r0,[r5,sgSockDta_conn_ptr] ;=0    ; kill socket
 str  r0,[r5,sgSockDta_flags]    ;=0    ;/
;mov  r0,0  ;out: 0=okay                ;-okay
 b    @@return_r0
;---
@@return_error_einval:
 bl   sgIP_error_inval  ;out: r0
@@return_r0:
 mov  r5,r0     ;out: r0=0=okay (unless socket=bad)
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5     ;out: r0=0=okay (unless socket=bad)
 pop  r4-r5,pc
;------------------
forceclosesocket:  ;in: r0=socket, out: r0
 push r4-r5,lr
 mov  r5,r0  ;socket
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp  r5,0                              ;\exit if no socket
 beq  @@return_error_einval             ;/
 ldr  r0,[r5,sgSockDta_flags]           ;\
 tst  r0,SGIP_SOCKET_FLAG_ALLOCATED     ; exit if not allocated
 beq  @@return_zero                     ;/    ;uh, return 0=okay ?
 and  r0,SGIP_SOCKET_FLAG_TYPEMASK      ;\
.if with_tcp
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_TCP      ;
 beq  @@close_tcp                       ; handle type
.endif
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_UDP      ;
 beq  @@close_udp                       ;/
@@return_error_einval:
 bl   sgIP_error_inval  ;out: r0
 b    @@return_r0
;---
@@return_zero:
 mov  r0,0
 b    @@return_r0
;---
@@close_done:
 mov  r0,0
 str  r0,[r5,sgSockDta_conn_ptr] ;=0
 str  r0,[r5,sgSockDta_flags]    ;=0
;mov  r0,0  ;out: 0=okay                ;-okay
@@return_r0:
 mov  r5,r0     ;out: r0=0=okay (unless socket=bad)
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5     ;out: r0=0=okay (unless socket=bad)
 pop  r4-r5,pc
;---
.if with_tcp
@@close_tcp:
 ldr  r0,[r5,sgSockDta_conn_ptr]
 bl   sgIP_TCP_FreeRecord
 b    @@close_done
.endif
;---
@@close_udp:
 ldr  r0,[r5,sgSockDta_conn_ptr]
 bl   sgIP_UDP_FreeRecord
 b    @@close_done
;------------------
closesocket:  ;in: r0=socket, out: r0
 push r4-r5,lr
 mov  r5,r0  ;socket
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp  r5,0                              ;\exit if no socket
 beq  @@return_error_einval             ;/
 ldr  r0,[r5,sgSockDta_flags]           ;\
 tst  r0,SGIP_SOCKET_FLAG_VALID         ; exit if not valid
 beq  @@return_zero                     ;/   uh, return ZERO if not valid (?) (maybe meant as "already closed/closing"?)
 and  r0,SGIP_SOCKET_FLAG_TYPEMASK      ;\
.if with_tcp
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_TCP      ;
 beq  @@close_tcp                       ; handle type
.endif
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_UDP      ;
 beq  @@close_udp                       ;/
@@return_error_einval:
 bl   sgIP_error_inval  ;out: r0
 b    @@return_r0
;---
@@return_zero:
 mov  r0,0
 b    @@return_r0
;---
@@close_done:
 mov  r0,0                              ;\
 str  r0,[r5,sgSockDta_conn_ptr] ;=0    ; mark socket closed
 str  r0,[r5,sgSockDta_flags]    ;=0    ;/
;mov  r0,0  ;out: 0=okay                ;-okay
@@return_r0:
 mov  r5,r0  ;return value
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5     ;out: r0=0=okay (unless socket=bad)
 pop  r4-r5,pc
;---
.if with_tcp
@@close_tcp:     ;TCP is special...
 ldr  r0,[r5,sgSockDta_conn_ptr]        ;-get tcp record
 ldr  r2,[r0,sgTcpRec_tcpstate]         ;-get tcp state
 cmp   r2,SGIP_TCP_STATE_CLOSED         ;\
 cmpne r2,SGIP_TCP_STATE_UNUSED         ;
 cmpne r2,SGIP_TCP_STATE_NODATA         ; if already closed/unused/etc.
 cmpne r2,SGIP_TCP_STATE_LISTEN         ; then free record right now,
 bne   @@cannot_free_yet                ; and, close socket right now
;ldr  r0,[r5,sgSockDta_conn_ptr]  ;\    ;
 bl   sgIP_TCP_FreeRecord         ;/    ;
 b    @@close_done ;okay, closed & free ;/
;---
@@cannot_free_yet:
 mov  r0,r5  ;socket                                            ;\
 mov  r1,0   ;type                                              ; shutdown
 bl   shutdown                                                  ;/
 ldr  r0,[r5,sgSockDta_flags]                                   ;\
 ldr  r1,=SGIP_SOCKET_FLAG_VALID  +SGIP_SOCKET_MASK_CLOSE_COUNT ; mark invalid,
 bic  r0,r1                                                     ; closing, and
 ldr  r1,=SGIP_SOCKET_FLAG_CLOSING+SGIP_SOCKET_VALUE_CLOSE_COUNT; init timeout
 orr  r0,r1                                                     ;
 str  r0,[r5,sgSockDta_flags]                                   ;/
 mov  r0,0          ;out: r0=okay (although notyet fully closed)
 b    @@return_r0   ;don't return to "@@close_done" here! (notyet fully closed)
.endif
;---
@@close_udp:     ;UDP is simple...
 ldr  r0,[r5,sgSockDta_conn_ptr]  ;\
 bl   sgIP_UDP_FreeRecord         ;/
 b    @@close_done ;okay, closed & free
;------------------
bind:  ;in: r0=socket, r1=const struct sockaddr * addr, r2=addr_len, out: r0
 push r4-r7,lr
 mov  r5,r0  ;socket
 mov  r6,r1  ;sockaddr
 mov  r7,r2  ;addr_len
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp  r5,0                              ;\exit if no socket
 beq  @@return_error_einval             ;/
 cmp  r7,sgSoin_size                    ;\exit if wrong addr_len
 bne  @@return_error_einval             ;/
 ldr  r0,[r5,sgSockDta_flags]           ;\
 tst  r0,SGIP_SOCKET_FLAG_VALID         ; exit if not valid
 beq  @@return_error_einval             ;/
 and  r0,SGIP_SOCKET_FLAG_TYPEMASK      ;\
.if with_tcp
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_TCP      ;
 beq  @@bind_tcp                        ; handle type
.endif
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_UDP      ;
 beq  @@bind_udp                        ;/
@@return_error_einval:
 bl   sgIP_error_inval  ;out: r0
@@bind_done:  ;r0=return value
 mov  r5,r0  ;return value
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5     ;out: r0
 pop  r4-r7,pc
;---
.if with_tcp
@@bind_tcp:
 ldr  r0,[r5,sgSockDta_conn_ptr]
 ldrh r1,[r6,sgSoin_sin_port]
 ldr  r2,[r6,sgSoin_sin_addr]
 bl   sgIP_TCP_Bind
 b    @@bind_done    ;out: r0
.endif
;---
@@bind_udp:
 ldr  r0,[r5,sgSockDta_conn_ptr]
 ldrh r1,[r6,sgSoin_sin_port]
 ldr  r2,[r6,sgSoin_sin_addr]
 bl   sgIP_UDP_Bind
 b    @@bind_done    ;out: r0
;------------------
.if with_tcp
connect:  ;in: r0=socket, r1=const struct sockaddr * addr, r2=addr_len, out: r0
 push r4-r7,lr
 mov  r5,r0  ;socket
 mov  r6,r1  ;sockaddr
 mov  r7,r2  ;addr_len
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp  r5,0                              ;\exit if no socket
 beq  @@return_error_einval             ;/
 cmp  r7,sgSoin_size                    ;\exit if wrong addr_len
 bne  @@return_error_einval             ;/
 ldr  r0,[r5,sgSockDta_flags]           ;\
 tst  r0,SGIP_SOCKET_FLAG_VALID         ; exit if not valid
 beq  @@return_error_einval             ;/
 and  r0,SGIP_SOCKET_FLAG_TYPEMASK      ;\handle type (TCP only, not UDP)
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_TCP      ;   (XXXX: should be also implemented
 beq  @@connect_tcp                     ;/  for UDP, but isn't done yet)
@@return_error_einval:
 bl   sgIP_error_inval  ;out: r0
 b    @@connect_done
@@return_error_inprogress:
 bl   sgIP_error_inprogress  ;out: r0
@@connect_done:  ;r0=return value
 mov  r5,r0  ;return value
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5     ;out: r0
 pop  r4-r7,pc
;---
@@connect_tcp:
 ldr  r0,[r5,sgSockDta_conn_ptr]                ;\
 ldr  r1,[r6,sgSoin_sin_addr]                   ;
 ldrh r2,[r6,sgSoin_sin_port]                   ; try connect
 bl   sgIP_TCP_Connect  ;out: r0                ;
 cmp  r0,0                                      ;
 bne  @@connect_done  ;---> done/okay right now ;/
;- - -
@@connect_tcp_lop:  ;not yet connected... wait until ready, or handle errors...
 ldr  r1,[r5,sgSockDta_conn_ptr]  ;record       ;-get tcp record
 ldr  r0,[r1,sgTcpRec_tcpstate]                 ;-get tcp state
 cmp   r0,SGIP_TCP_STATE_ESTABLISHED            ;\
 cmpne r0,SGIP_TCP_STATE_CLOSE_WAIT             ; done once when established
 moveq r0,0                                     ; (or close_wait)
 beq   @@connect_done ;--> done/okay NOW        ;/
 cmp   r0,SGIP_TCP_STATE_CLOSED                 ;\
 cmpne r0,SGIP_TCP_STATE_UNUSED                 ;
 cmpne r0,SGIP_TCP_STATE_LISTEN                 ; fail if closed/unused/etc.
 cmpne r0,SGIP_TCP_STATE_NODATA                 ; (and return TCP's errorcode
;ldreq r1,[r5,sgSockDta_conn_ptr]  ;record      ; as "errno")
 ldreq r2,[r1,sgTcpRec_errorcode]               ;
 ldreq r1,=errno                                ;
 streq r2,[r1]                                  ;
 moveq r0,-1                                    ;
 beq   @@connect_done ;--> fail                 ;/
 ldr  r0,[r5,sgSockDta_flags]                   ;\
 tst  r0,SGIP_SOCKET_FLAG_NONBLOCKING           ; fail if nonblocking requested
 bne  @@return_error_inprogress  ;--> fail      ;/
 mov  r0,r4                                     ;\
 bl   sgIP_IntrUnprotect                        ;
 bl   sgIP_WaitEvent                            ; wait
 bl   sgIP_IntrReprotect                        ;
;mov  r4,r0                                     ;/
 b    @@connect_tcp_lop
.endif
;------------------
.if with_tcp
send:  ;in: r0=socket, r1=data, r2=sendlength, r3=flags, out: r0
 push r4-r8,lr
 mov  r5,r0  ;socket
 mov  r6,r1  ;data
 mov  r7,r2  ;length
 mov  r8,r3  ;flags
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp  r5,0                              ;\exit if no socket
 beq  @@return_error_einval             ;/
 ldr  r0,[r5,sgSockDta_flags]           ;\
 tst  r0,SGIP_SOCKET_FLAG_VALID         ; exit if not valid
 beq  @@return_error_einval             ;/
 and  r0,SGIP_SOCKET_FLAG_TYPEMASK      ;\
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_TCP      ; handle type (TCP only, not UDP)
 beq  @@send_tcp                        ;/
@@return_error_einval:
 bl   sgIP_error_inval  ;out: r0
@@send_done:  ;r0=return value
 mov  r5,r0  ;return value
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5     ;out: r0
 pop  r4-r8,pc
;---
@@send_tcp:
@@send_tcp_lop:
 ldr  r0,[r5,sgSockDta_conn_ptr]        ;\
 mov  r1,r6  ;data                      ;
 mov  r2,r7  ;length                    ; try send TCP
 mov  r3,r8  ;flags                     ;
 bl   sgIP_TCP_Send                     ;/
 cmp  r0,-1                             ;\done if okay
 bne  @@send_done  ;out: r0             ;/
 ldr  r1,=errno                         ;\
 ldr  r1,[r1]                           ; done if error (or keep waiting)
 cmp  r1,EWOULDBLOCK  ;aka busy         ;
 bne  @@send_done  ;out: r0             ;/
 ldr  r1,[r5,sgSockDta_flags]           ;\
 tst  r1,SGIP_SOCKET_FLAG_NONBLOCKING   ; done if no wait desired
 bne  @@send_done  ;out: r0             ;/
 mov  r0,r4                             ;\
 bl   sgIP_IntrUnprotect                ;
 bl   sgIP_WaitEvent                    ; wait
 bl   sgIP_IntrReprotect                ;
;mov  r4,r0                             ;/
 b    @@send_tcp_lop
.endif
;------------------
.if with_tcp
recv:  ;in: r0=socket, r1=data, r2=recvlength, r3=flags, out: r0
 push r4-r8,lr
 mov  r5,r0  ;socket
 mov  r6,r1  ;data
 mov  r7,r2  ;length
 mov  r8,r3  ;flags
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp  r5,0                              ;\exit if no socket
 beq  @@return_error_einval             ;/
 ldr  r0,[r5,sgSockDta_flags]           ;\
 tst  r0,SGIP_SOCKET_FLAG_VALID         ; exit if not valid
 beq  @@return_error_einval             ;/
 and  r0,SGIP_SOCKET_FLAG_TYPEMASK      ;\
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_TCP      ; handle type (TCP only, not UDP)
 beq  @@recv_tcp                        ;/
@@return_error_einval:
 bl   sgIP_error_inval  ;out: r0
@@recv_done:  ;r0=return value
 mov  r5,r0  ;return value
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5     ;out: r0
 pop  r4-r8,pc
;---
@@recv_tcp:
@@recv_tcp_lop:
 ldr  r0,[r5,sgSockDta_conn_ptr]        ;\
 mov  r1,r6  ;data                      ;
 mov  r2,r7  ;length                    ; try recv TCP
 mov  r3,r8  ;flags                     ;
 bl   sgIP_TCP_Recv                     ;/
 cmp  r0,-1                             ;\done if okay
 bne  @@recv_done  ;out: r0             ;/
 ldr  r1,=errno                         ;\
 ldr  r1,[r1]                           ; done if error (or keep waiting)
 cmp  r1,EWOULDBLOCK  ;aka busy         ;
 bne  @@recv_done  ;out: r0             ;/
 ldr  r1,[r5,sgSockDta_flags]           ;\
 tst  r1,SGIP_SOCKET_FLAG_NONBLOCKING   ; done if no wait desired
 bne  @@recv_done  ;out: r0             ;/
 mov  r0,r4                             ;\
 bl   sgIP_IntrUnprotect                ;
 bl   sgIP_WaitEvent                    ; wait
 bl   sgIP_IntrReprotect                ;
;mov  r4,r0                             ;/
 b    @@recv_tcp_lop
.endif
;------------------
sendto:  ;in: r0=socket, r1=data, r2=sendlength, r3=flags, r4=sockaddr, r5=addr_len, out: r0
 push r4-r10,lr
 mov  r10,r5 ;addr_len
 mov  r5,r0  ;socket
 mov  r6,r1  ;data
 mov  r7,r2  ;length
 mov  r8,r3  ;flags
 mov  r9,r4  ;sockaddr
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp  r5,0   ;socket                    ;\
 cmpne r9,0  ;sockaddr                  ; exit if no socket, or no sockaddr
 beq   @@return_error_einval            ;/
 ldr  r0,[r5,sgSockDta_flags]           ;\
 tst  r0,SGIP_SOCKET_FLAG_VALID         ; exit if not valid
 beq  @@return_error_einval             ;/
 and  r0,SGIP_SOCKET_FLAG_TYPEMASK      ;\
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_UDP      ; handle type (UDP only, not TCP)
 beq  @@send_udp                        ;/
@@return_error_einval:
 bl   sgIP_error_inval  ;out: r0
@@send_done:  ;r0=return value
 mov  r5,r0  ;return value
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5     ;out: r0
 pop  r4-r10,pc
;---
@@send_udp:
 push r4-r5                             ;\
 ldr  r0,[r5,sgSockDta_conn_ptr]        ;
 mov  r1,r6  ;data                      ;
 mov  r2,r7  ;length                    ; try send UDP
 mov  r3,r8  ;flags                     ;
 ldr  r4,[r9,sgSoin_sin_addr]           ;
 ldrh r5,[r9,sgSoin_sin_port]           ;
 bl   sgIP_UDP_SendTo                   ;
 pop  r4-r5                             ;/
 b    @@send_done  ;out: r0
;------------------
recvfrom:  ;in: r0=socket, r1=data, r2=recvlength, r3=flags, r4=sockaddr, r5=ptr_to_addr_len, out: r0
 ;uh, incoming [ptr_to_addr_len] SHOULD be probably AT LEAST "sgSoin_size"
 ;(original code is just simply IGNORING the incoming value though; and the
 ;functions that DO USE "recvfrom" are passing UNINITIALIZED incoming values)
 ;- - -
 push r4-r10,lr
 mov  r10,r5 ;ptr to addr_len
 mov  r5,r0  ;socket
 mov  r6,r1  ;data
 mov  r7,r2  ;length
 mov  r8,r3  ;flags
 mov  r9,r4  ;sockaddr
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp  r5,0   ;socket                    ;\
 cmpne r9,0  ;sockaddr                  ; exit if no socket, or no sockaddr
 beq   @@return_error_einval            ;/
 ldr  r0,[r5,sgSockDta_flags]           ;\
 tst  r0,SGIP_SOCKET_FLAG_VALID         ; exit if not valid
 beq  @@return_error_einval             ;/
 and  r0,SGIP_SOCKET_FLAG_TYPEMASK      ;\
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_UDP      ; handle type (UDP only, not TCP)
 beq  @@recv_udp                        ;/
@@return_error_einval:
 bl   sgIP_error_inval  ;out: r0
@@recv_done:  ;r0=return value
 mov  r5,r0  ;return value
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5     ;out: r0
 pop  r4-r10,pc
;---
@@recv_udp:
 mov  r0,sgSoin_size                    ;\return actual/used addr_len
 str  r0,[r10]  ;addr_len               ;/
@@recv_udp_lop:
 push r4-r5                             ;\
 ldr  r0,[r5,sgSockDta_conn_ptr]        ;
 mov  r1,r6  ;data                      ;
 mov  r2,r7  ;length                    ; try recv UDP
 mov  r3,r8  ;flags                     ;
 add  r4,r9,sgSoin_sin_addr ;ptr to addr;
 add  r5,r9,sgSoin_sin_port ;ptr to port;
 bl   sgIP_UDP_RecvFrom                 ;
 pop  r4-r5                             ;/
 cmp  r0,-1                             ;\done if okay
 bne  @@recv_done  ;out: r0             ;/
 ldr  r1,=errno                         ;\
 ldr  r1,[r1]                           ; done if error (or keep waiting)
 cmp  r1,EWOULDBLOCK  ;aka busy         ;
 bne  @@recv_done  ;out: r0             ;/
 ldr  r1,[r5,sgSockDta_flags]           ;\
 tst  r1,SGIP_SOCKET_FLAG_NONBLOCKING   ; done if no wait desired
 bne  @@recv_done  ;out: r0             ;/
 mov  r0,r4                             ;\
 bl   sgIP_IntrUnprotect                ;
 bl   sgIP_WaitEvent                    ; wait
 bl   sgIP_IntrReprotect                ;
;mov  r4,r0                             ;/
 b    @@recv_udp_lop
;------------------
.if with_tcp
listen:  ;in: r0=socket, r1=max_connections, out: r0
 push r4-r6,lr
 mov  r5,r0  ;socket
 mov  r6,r1  ;max_connections
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp  r5,0                              ;\exit if no socket
 beq  @@return_error_einval             ;/
 ldr  r0,[r5,sgSockDta_flags]           ;\
 tst  r0,SGIP_SOCKET_FLAG_VALID         ; exit if not valid
 beq  @@return_error_einval             ;/
 and  r0,SGIP_SOCKET_FLAG_TYPEMASK      ;\
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_TCP      ; handle type (TCP only, not UDP)
 beq  @@listen_tcp                      ;/
@@return_error_einval:
 bl   sgIP_error_inval  ;out: r0
@@listen_done:  ;r0=return value
 mov  r5,r0  ;return value
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5     ;out: r0
 pop  r4-r6,pc
;---
@@listen_tcp:
 ldr  r0,[r5,sgSockDta_conn_ptr]        ;\
 mov  r1,r6  ;max_connections           ; try listen TCP
 bl   sgIP_TCP_Listen                   ;/
 b    @@listen_done  ;out: r0
.endif
;------------------
.if with_tcp
accept:  ;in: r0=socket, r1=sockaddr, r2=ptr_to_addr_len, out: r0=2nd_socket
 push r4-r8,lr
 mov  r5,r0  ;socket
 mov  r6,r1  ;sockaddr
 mov  r7,r2  ;ptr_to_addr_len
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp   r5,0  ;socket                    ;\
 cmpne r6,0  ;sockaddr                  ; exit if no socket (or no sockaddr,
 cmpne r7,0  ;ptr_to_addr_len           ; or no ptr_to_addr_len)
 beq   @@return_error_einval            ;/
 ldr  r0,[r5,sgSockDta_flags]           ;\
 tst  r0,SGIP_SOCKET_FLAG_VALID         ; exit if not valid
 beq  @@return_error_einval             ;/
 and  r0,SGIP_SOCKET_FLAG_TYPEMASK      ;\
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_TCP      ; handle type (TCP only, not UDP)
 beq  @@accept_tcp                      ;/
@@return_error_einval: @@no_2nd_socket:
 bl   sgIP_error_inval  ;out: r0
@@accept_done:  ;r0=return value (2nd_socket, or -1=error)
 mov  r5,r0  ;return value
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5     ;out: r0
 pop  r4-r8,pc
;---
@@accept_tcp:
 ldr  r0,[r5,sgSockDta_flags]           ;\
 and  r0,SGIP_SOCKET_FLAG_NONBLOCKING   ;
 orr  r0,SGIP_SOCKET_FLAG_TYPE_TCP      ; try to alloc 2nd socket
 bl   spawn_socket                      ;
 cmp  r0,-1                             ;
 beq  @@no_2nd_socket                   ;
 mov  r8,r0     ;2nd_socket             ;/
@@accept_tcp_lop:
 ldr  r0,[r5,sgSockDta_conn_ptr]        ;\try accept
 bl   sgIP_TCP_Accept                   ;/
 cmp  r0,0   ;sgTcpRec                  ;\done if okay
 bne  @@accept_tcp_done_okay            ;/
 ldr  r1,=errno                         ;\
 ldr  r1,[r1]                           ; done if error (or keep waiting)
 cmp  r1,EWOULDBLOCK  ;aka busy         ;
 bne  @@accept_tcp_fail                 ;/
 ldr  r1,[r5,sgSockDta_flags]           ;\
 tst  r1,SGIP_SOCKET_FLAG_NONBLOCKING   ; done if no wait desired
 bne  @@accept_tcp_fail                 ;/
 mov  r0,r4                             ;\
 bl   sgIP_IntrUnprotect                ;
 bl   sgIP_WaitEvent                    ; wait
 bl   sgIP_IntrReprotect                ;
;mov  r4,r0                             ;/
 b    @@accept_tcp_lop
;---
@@accept_tcp_fail:
 mov  r0,r8                             ;\
 bl   kill_socket                       ;/
 mov  r0,-1          ;fail              ;-fail
 b    @@accept_done  ;out: r0
;---
@@accept_tcp_done_okay:  ;in: r0=sgTcpRec
 mov  r1,sgSoin_size                    ;\return actual/used addr_len
 str  r1,[r7]   ;addr_len               ;/
 mov  r1,AF_INET                        ;\set sockaddr family
 strh r1,[r6,sgSoin_sin_family]         ;/
 ldr  r1,[r0,sgTcpRec_destip]           ;\
 str  r1,[r6,sgSoin_sin_addr]           ; apply addr/port from TCP record
 ldrh r1,[r0,sgTcpRec_destport]         ; to sockaddr
 strh r1,[r6,sgSoin_sin_port]           ;/
 str  r0,[r8,sgSockDta_conn_ptr]        ;-apply TCP record to 2nd socket
 mov  r0,r8     ;2nd_socket             ;-okay, return 2nd socket
 b    @@accept_done  ;out: r0
.endif
;------------------
.if with_tcp
shutdown:  ;in: r0=socket, r1=shutdown_type, out: r0
 push r4-r6,lr
 mov  r5,r0  ;socket
 mov  r6,r1  ;shutdown_type (unused/ignored) (see unused "SHUT_xxx" constants)
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp  r5,0                              ;\exit if no socket
 beq  @@return_error_einval             ;/
 ldr  r0,[r5,sgSockDta_flags]           ;\
 tst  r0,SGIP_SOCKET_FLAG_VALID         ; exit if not valid
 beq  @@return_error_einval             ;/
 and  r0,SGIP_SOCKET_FLAG_TYPEMASK      ;\
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_TCP      ; handle type (TCP only, not UDP)
 beq  @@shutdown_tcp                    ;/
@@return_error_einval:
 bl   sgIP_error_inval  ;out: r0
@@shutdown_done:  ;r0=return value
 mov  r5,r0  ;return value
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5     ;out: r0
 pop  r4-r6,pc
;---
@@shutdown_tcp:
 ldr  r0,[r5,sgSockDta_conn_ptr]
 bl   sgIP_TCP_Close
 b    @@shutdown_done    ;out: r0
.endif
;------------------
ioctl:  ;in: r0=socket, r1=cmd, r2=arg, out: r0   ;aka "ioctlsocket" in windows
 push r4-r7,lr
 mov  r5,r0  ;socket
 mov  r6,r1  ;cmd
 mov  r7,r2  ;arg
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp  r5,0                              ;\exit if no socket
 beq  @@return_error_ebadf              ;/
 ldr  r0,[r5,sgSockDta_flags]           ;\
 tst  r0,SGIP_SOCKET_FLAG_VALID         ; exit if not valid
 beq  @@return_error_einval             ;/
 cmp  r6,FIONBIO                        ;\
 beq  @@ioctl_fionbio                   ; handle cmd
 cmp  r6,FIONREAD                       ;
 beq  @@ioctl_fionread                  ;/
;BUGGED: original code returns 0=okay upon unsupported cmd's, better do this...
@@return_error_einval:
 bl   sgIP_error_inval  ;out: r0
 b    @@ioctl_done
@@return_error_ebadf:
 bl   sgIP_error_badf   ;out: r0
;b    @@ioctl_done
@@ioctl_done:  ;r0=return value
 mov  r5,r0  ;return value
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5     ;out: r0
 pop  r4-r7,pc
;---
@@ioctl_fionbio:    ;enable/disable Blocking I/O
 cmp  r7,0   ;arg               ;\want argument
 beq  @@return_error_einval     ;/
 ldr  r1,[r5,sgSockDta_flags]                           ;\
 ldr  r0,[r7]  ;[arg]  ;0=blocking, 1=nonblocking       ;
 cmp  r0,0                                              ; forward argument
 biceq r1,SGIP_SOCKET_FLAG_NONBLOCKING  ;blocking       ; to flags
 orrne r1,SGIP_SOCKET_FLAG_NONBLOCKING  ;nonblocking    ;
 str  r1,[r5,sgSockDta_flags]                           ;/
 mov  r0,0            ;okay, return zero
 b    @@ioctl_done    ;out: r0
;---
@@ioctl_fionread:  ;get amount of data that can be read atomically from socket
 cmp  r7,0   ;arg               ;\want argument
 beq  @@return_error_einval     ;/
 and  r0,SGIP_SOCKET_FLAG_TYPEMASK      ;\
.if with_tcp
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_TCP      ;
 beq  @@ioctl_fionread_tcp              ; handle type
.endif
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_UDP      ;
 beq  @@ioctl_fionread_udp              ;/
 b    @@return_error_einval
;---
.if with_tcp
@@ioctl_fionread_tcp:
 ldr  r0,[r5,sgSockDta_conn_ptr]  ;record       ;-get tcp record
 ldr  r1,[r0,sgTcpRec_buf_rx_out]               ;\
 ldr  r2,[r0,sgTcpRec_buf_rx_in]                ;
 subs r0,r1,r2  ;len = out-in                   ; return [arg]=len
 addlo r0,SGIP_TCP_RECEIVEBUFFERLENGTH  ;wrap   ;
 str  r0,[r7]   ;[arg] = len                    ;/
 mov  r0,0            ;okay, return zero (and [arg]=len)
 b    @@ioctl_done    ;out: r0
.endif
;---
@@ioctl_fionread_udp:
 ldr  r0,[r5,sgSockDta_conn_ptr]  ;record       ;-get udp record
 ldr  r0,[r0,sgUdpRec_incoming_queue]           ;-get MemBlk
 cmp  r0,0   ;0=none (no MemBlk)                ;\
 ldrne r0,[r0,sgMemBlk_totallength]             ; return [arg]=len
 subne r0,12 ;len=total-12                      ;
 str  r0,[r7]   ;[arg]=len (or 0 if no MemBlk)  ;/
 mov  r0,0            ;okay, return zero (and [arg]=len)
 b    @@ioctl_done    ;out: r0
;------------------
.if with_gimmicks
setsockopt:  ;in: r0=socket, r1=level, r2=option_name, r3=data, r4=data_len, out: r0
;dummy, not really implemented (related to unused "SO_xxx" and "SOL_xxx" values)
 mov  r0,0
 bx   lr
.endif
;------------------
.if with_gimmicks
getsockopt:  ;in: r0=socket, r1=level, r2=option_name, r3=data, r4=data_len, out: r0
;dummy, not really implemented (related to unused "SO_xxx" and "SOL_xxx" values)
 mov  r0,0
 bx   lr
.endif
;------------------
.if with_gimmicks
getpeername:  ;in: r0=socket, r1=sockaddr *addr, r2=ptr_to_addr_len, out: r0
 push r4-r7,lr
 mov  r5,r0  ;socket
 mov  r6,r1  ;sockaddr
 mov  r7,r2  ;ptr_to_addr_len
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp  r5,0                              ;\exit if no socket
 beq  @@return_error_ebadf              ;/
 cmp   r6,0  ;sockaddr                  ;\exit if no sockaddr,
 cmpne r7,0  ;ptr_to_addr_len           ; or no ptr_to_addr_len
 beq   @@return_error_efault            ;/
 ldrne r0,[r7]      ;addr_len           ;\exit if incoming
 cmp   r0,sgSoin_size                   ; "addr_len" is to small
 blo   @@return_error_efault            ;/
 ldr  r0,[r5,sgSockDta_flags]           ;\
 tst  r0,SGIP_SOCKET_FLAG_VALID         ; exit if not valid
 beq  @@return_error_einval             ;/
 and  r0,SGIP_SOCKET_FLAG_TYPEMASK      ;\
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_TCP      ; handle type (TCP only, not UDP)
 beq  @@getpeer_tcp                     ;/
 bl   sgIP_error_opnotsupp ;out: r0
 b    @@get_done
@@return_error_efault:
 bl   sgIP_error_fault     ;out: r0
 b    @@get_done
@@return_error_ebadf:
 bl   sgIP_error_badf      ;out: r0
 b    @@get_done
@@return_error_notconn:
 bl   sgIP_error_notconn   ;out: r0
 b    @@get_done
@@return_error_einval:
 bl   sgIP_error_inval     ;out: r0
@@get_done:  ;r0=return value
 mov  r5,r0  ;return value
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5     ;out: r0
 pop  r4-r7,pc
;---
@@getpeer_tcp:
 ldr  r1,[r5,sgSockDta_conn_ptr]  ;record
 ldr  r0,[r1,sgTcpRec_tcpstate]         ;\
 cmp  r0,SGIP_TCP_STATE_ESTABLISHED     ;
 bne  @@return_error_notconn            ;/
 mov  r0,AF_INET                    ;\  ;\
 strh r0,[r6,sgSoin_sin_family]     ;/  ;
 ldr  r0,[r1,sgTcpRec_destip]       ;\  ; return DEST port/addr/family
 str  r0,[r6,sgSoin_sin_addr]       ;/  ; (from tcp record)
 ldrh r0,[r1,sgTcpRec_destport]     ;\  ;
 strh r0,[r6,sgSoin_sin_port]       ;/  ;/
 mov  r0,sgSoin_size                    ;\return addr_len
 str  r0,[r7]  ;[ptr_to_addr_len]       ;/
 mov  r0,0          ;out: r0=okay
 b    @@get_done    ;out: r0
.endif
;------------------
.if with_gimmicks
getsockname:  ;in: r0=socket, r1=sockaddr *addr, r2=ptr_to_addr_len, out: r0
;same as "getpeername", but retrieving SOURCE addr (instead DEST), and working
;for both TCP and UDP (instead TCP only)
;- - -
 push r4-r7,lr
 mov  r5,r0  ;socket
 mov  r6,r1  ;sockaddr
 mov  r7,r2  ;ptr_to_addr_len
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp  r5,0                              ;\exit if no socket
 beq  @@return_error_ebadf              ;/
 cmp   r6,0  ;sockaddr                  ;\exit if no sockaddr,
 cmpne r7,0  ;ptr_to_addr_len           ; or no ptr_to_addr_len
 beq   @@return_error_efault            ;/
 ldrne r0,[r7]      ;addr_len           ;\exit if incoming
 cmp   r0,sgSoin_size                   ; "addr_len" is to small
 blo   @@return_error_efault            ;/
 ldr  r0,[r5,sgSockDta_flags]           ;\
 tst  r0,SGIP_SOCKET_FLAG_VALID         ; exit if not valid
 beq  @@return_error_einval             ;/
 and  r0,SGIP_SOCKET_FLAG_TYPEMASK      ;\
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_TCP      ;
 beq  @@getsock_tcp                     ; handle type (TCP or UDP)
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_UDP      ;
 beq  @@getsock_udp                     ;/
 bl   sgIP_error_opnotsupp ;out: r0
 b    @@get_done
@@return_error_ebadf:
 bl   sgIP_error_badf      ;out: r0
 b    @@get_done
@@return_error_efault:
 bl   sgIP_error_fault     ;out: r0
 b    @@get_done
@@return_error_einval:
 bl   sgIP_error_inval     ;out: r0
@@get_done:  ;r0=return value
 mov  r5,r0  ;return value
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5     ;out: r0
 pop  r4-r7,pc
;---
@@getsock_tcp:
 ldr  r1,[r5,sgSockDta_conn_ptr]  ;record
 ldr  r0,[r1,sgTcpRec_tcpstate]         ;\
 cmp   r0,SGIP_TCP_STATE_UNUSED         ; reject if unused or closed
 cmpne r0,SGIP_TCP_STATE_CLOSED         ;
 beq   @@return_error_einval            ;/
 mov  r0,AF_INET                    ;\  ;\
 strh r0,[r6,sgSoin_sin_family]     ;/  ;
 ldr  r0,[r1,sgTcpRec_srcip]        ;\  ; return SOURCE port/addr/family
 str  r0,[r6,sgSoin_sin_addr]       ;/  ; (from tcp record)
 ldrh r0,[r1,sgTcpRec_srcport]      ;\  ;
 strh r0,[r6,sgSoin_sin_port]       ;/  ;/
 mov  r0,sgSoin_size                    ;\return addr_len
 str  r0,[r7]  ;[ptr_to_addr_len]       ;/
 mov  r0,0          ;out: r0=okay
 b    @@get_done    ;out: r0
;---
@@getsock_udp:
 ldr  r1,[r5,sgSockDta_conn_ptr]  ;record
 ldr  r0,[r1,sgUdpRec_state]            ;\
 cmp   r0,SGIP_UDP_STATE_UNUSED         ; reject if unused
 beq   @@return_error_einval            ;/
 mov  r0,AF_INET                    ;\  ;\
 strh r0,[r6,sgSoin_sin_family]     ;/  ;
 ldr  r0,[r1,sgUdpRec_srcip]        ;\  ; return SOURCE port/addr/family
 str  r0,[r6,sgSoin_sin_addr]       ;/  ; (from UDP record)
 ldrh r0,[r1,sgUdpRec_srcport]      ;\  ;
 strh r0,[r6,sgSoin_sin_port]       ;/  ;/
 mov  r0,sgSoin_size                    ;\return addr_len
 str  r0,[r7]  ;[ptr_to_addr_len]       ;/
 mov  r0,0          ;out: r0=okay
 b    @@get_done    ;out: r0
.endif
;------------------
.if with_dns
gethostbyname:  ;in: r0=name, out: r0=DnsHst (aka hostent)
 b    sgIP_DNS_gethostbyname
.endif
;------------------
.if with_gimmicks
select:  ;in: r0=nfds, r1=readfds, r2=writefds, r3=errorfds, r4=timeout, out: r0  ;uh, "extern"
 ;this is intended to wait for events on select'ed sockets (via "fds" sets)
 ;- - - -
 ;BLAH: the function is rather weird & crude, apparently dating back to some
 ;old "Berkeley" standard, using weird bit-arrays with hardcoded size, and
 ;a weird timeout structure with second and microsecond entries.
 ;even if that crap is still used by some programs, it's rather unlikely to
 ;be used in normal cases, especially not by smaller programs with few sockets.
 ;- - - -
 ;BUGGED: the "writefds" stuff should compare "buf_tx_in" with "buf_tx_out"
 ;(or maybe vice versa) (instead of comparing "buf_tx_in" with itself)
 ;- - - -
 ;BUGGED: original code does do the "sgIP_WaitEvent" delay even AFTER sensing
 ;a socket event, that final extra delay is just wasting time.
 ;- - - -
;@@max equ 28de80h ;aka 2678400 decimal (2678400s = 31 days)
 @@max equ 290000h ;aka 2786975 decimal (more than 31 days)
 ;- - - -
 push r4-r12,lr
;mov  r5,r0  ;nfds (ignored, instead uses SGIP_SOCKET_MAXSOCKETS)
 mov  r6,r1  ;readfds
 mov  r7,r2  ;writefds
 mov  r8,r3  ;errorfds (not implemented, mostly ignored, cleared on exit)
 mov  r9,r4  ;timeout
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp  r9,0                              ;\
 mov  r3,@@max   ;about 31 days         ;
 moveq r2,r3           ;seconds=max     ;
 moveq r0,0            ;microseconds    ; translate the weird timeout
 ldrne r2,[r9,sgTimeval_tv_sec]         ; "timeval" structure to a
 ldrne r0,[r9,sgTimeval_tv_usec]        ; normal "millisecond" value
 cmp  r1,r3            ;seconds>max     ;
 movhs r2,r3           ;seconds=max     ; (ptr to structure is ZERO would
 movhs r0,0            ;microseconds    ; would be mean "infinite, which
 mov  r1,1000                           ; is handled as max "31 days" here)
 mul  r9,r1,r2         ;seconds*1000    ;
;mov  r1,1000                           ;
 swi  swi_div          ;usec/1000       ;
 add  r9,r0            ;timeout merged  ;/
;- - - - - - - - -
 ;below huge loop is usually executed at least TWICE (unless incoming
 ;timeout value is 0 ms):
 ;the FIRST PASS(es), without timeout=NONZERO, are checking if any events occur
 ;  (and if so, forces timeout=0 to enter the LAST pass)
 ;the LAST PASS, without timeout=ZERO, is checking for events too, and,
 ;  clears any flags that don't have events triggered
 ;return value is the number of detected events (and the flags for those
 ;  sockets are kept set, all other flags are cleared upon return)
;- - - - - - - - -
 ldr  r5,=sgIP_timems           ;\get initial start time
 ldr  r5,[r5]   ;lasttime       ;/
@@huge_wait_lop:   ;check all fd sets...
 ldr  r10,=socketlist
 mov  r11,1  ;index (1..MAX)
 mov  r12,0  ;num_events
@@lookup_socket_lop:
;- - - -
 cmp  r6,0   ;readfds                   ;\readfds check if any
 beq  @@lookup_readfds_next             ;/
 mov  r0,r11 ;index                     ;\
 mov  r1,r6  ;readfds                   ;
 bl   FD_ISSET                          ; readfds check flag
 cmp  r0,0                              ;
 beq  @@lookup_readfds_next             ;/
 ldr  r0,[r10,sgSockDta_flags]          ;\
 and  r0,SGIP_SOCKET_FLAG_TYPEMASK      ;
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_TCP      ; readfds check if TCP or UDP
 beq  @@lookup_readfds_tcp              ;
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_UDP      ;
 beq  @@lookup_readfds_udp              ;
 b    @@lookup_readfds_next             ;/
@@lookup_readfds_tcp:
 ldr  r0,[r10,sgSockDta_conn_ptr]  ;record      ;\
 ldr  r3,[r0,sgTcpRec_tcpstate]    ;state       ; readfds TCP...
 cmp  r3,SGIP_TCP_STATE_LISTEN     ;state       ; ;\
 bne  @@lookup_not_listen                       ; ; event if LISTEN, and
 ldr  r1,[r0,sgTcpRec_listendata]  ;ptr         ; ; ptr-to-ptr-to-listendata
 cmp   r1,0     ;listendata                     ; ; and ptr-to-listendata
 ldrne r1,[r1]  ;listendata[0]                  ; ; present
 cmpne r1,0     ;listendata[0]                  ; ;
 bne   @@lookup_readfds_got_event               ; ;
@@lookup_not_listen:                            ; ;/
 cmp  r3,SGIP_TCP_STATE_CLOSE_WAIT ;state       ; ;\
 ldreq r1,[r0,sgTcpRec_want_shutdown]           ; ; event if CLOSE WAIT, and
 cmpeq r1,0                                     ; ; want_shutdown=0, or
 cmpne r3,SGIP_TCP_STATE_CLOSED    ;state       ; ; event if CLOSED
 beq   @@lookup_readfds_got_event               ; ;/
 ldr  r1,[r0,sgTcpRec_buf_rx_in]                ; ;\
 ldr  r2,[r0,sgTcpRec_buf_rx_out]               ; ; event if buf_rx not empty
 cmp  r1,r2                                     ; ;
 bne  @@lookup_readfds_got_event                ;/;/
@@lookup_readfds_no_event:
 cmp  r9,0      ;timeout (0=last pass)          ;\
 moveq r0,r11 ;index    ;\                      ; no event, lop next, and
 moveq r1,r6  ;readfds  ; clr flag              ; in LAST pass: clear flag
 bleq  FD_CLR           ;/                      ;
 b    @@lookup_readfds_next                     ;/
@@lookup_readfds_udp:
 ldr  r0,[r10,sgSockDta_conn_ptr]  ;record      ;\
 ldr  r0,[r0,sgUdpRec_incoming_queue]           ; readfds UDP...
 cmp  r0,0                                      ; event if incoming queue data
 beq  @@lookup_readfds_no_event                 ;/
@@lookup_readfds_got_event:
 add  r12,1  ;num_events                        ;-got event, raise num_events
@@lookup_readfds_next:
;- - - -
 cmp  r7,0   ;writefds                  ;\writefds check if any
 beq  @@lookup_writefds_next            ;/
 mov  r0,r11 ;index                     ;\
 mov  r1,r7  ;writefds                  ;
 bl   FD_ISSET                          ; writefds check flag
 cmp  r0,0                              ;
 beq  @@lookup_writefds_next            ;/
 ldr  r0,[r10,sgSockDta_flags]          ;\
 and  r0,SGIP_SOCKET_FLAG_TYPEMASK      ; writefds check if TCP
 cmp  r0,SGIP_SOCKET_FLAG_TYPE_TCP      ;
 bne  @@lookup_writefds_next            ;/
 ldr  r0,[r10,sgSockDta_conn_ptr]  ;record      ;\
 ldr  r1,[r0,sgTcpRec_buf_tx_in]   ;XXXX        ; writefds TCP...
 ldr  r2,[r0,sgTcpRec_buf_tx_in]   ;uh, BUGGED  ; event if tx buf NOT full
 subs r1,1                                      ; (aka writeable)
 addlo r1,SGIP_TCP_TRANSMITBUFFERLENGTH ;wrap   ;
 cmp  r1,r2   ;check ...                        ;/
 addne r12,1  ;num_events                       ;-got event, raise num_events
 cmpeq r9,0     ;timeout (0=last pass)          ;\
 moveq r0,r11 ;index    ;\                      ; no event, lop next, and
 moveq r1,r7  ;writefds ; clr flag              ; in LAST pass: clear flag
 bleq  FD_CLR           ;/                      ;/
@@lookup_writefds_next:
;- - - -
;ignore incoming errorfds for now, and set errorfds to all zero on last pass
 cmp   r9,0     ;timeout (0=last pass)          ;\
 moveq r0,r11 ;index    ;\                      ; no event, lop next, and
 moveq r1,r8  ;errorfds ; clr flag              ; in LAST pass: clear flag
 bleq  FD_CLR           ;/                      ;/
;- - - -
 add  r10,sgSockDta_size                ;\
 add  r11,1  ;index (1..MAX)            ; lop next
 cmp  r11,SGIP_SOCKET_MAXSOCKETS        ;
 ble  @@lookup_socket_lop               ;/
;- - - -
 cmp  r9,0     ;timeout (0=last pass)           ;\done if it's been LAST pass
 beq  @@done_with_last_pass                     ;/
 cmp  r12,0    ;num_events                      ;\if event(s) were found,
 moveq r9,0    ;timeout (0=last pass)           ; force LAST pass now
 beq   @@huge_wait_lop  ;instantly (no delay)   ;/
 ldr  r1,=sgIP_timems                           ;\
 ldr  r1,[r1]   ;time                           ;
 sub  r0,r1,r5  ;disp=time-lasttime             ; decrease timeout
 mov  r5,r1     ;apply new lasttime             ;
 subs r9,r0     ;decrease timeout by disp       ;
 movls r9,0     ;crop to min zero (last pass)   ;
 bls   @@huge_wait_lop  ;instantly (no delay)   ;/
 mov  r0,r4                                     ;\
 bl   sgIP_IntrUnprotect                        ;
 bl   sgIP_WaitEvent                            ; wait/delay
 bl   sgIP_IntrReprotect                        ;
;mov  r4,r0                                     ;/
 b    @@huge_wait_lop                           ;-loop more...
;--- --- ---
@@done_with_last_pass:   ;out: r12=num_events
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r12    ;out: r0=num_events
 pop  r4-r12,pc
;------------------
;below "FD_xxx" are subfunctions for "select", original source code does
;contain that functions, but they are outcommented (supposedly meant to use
;equivalent functions in "libnds" instead of the outcommented ones)
;---
FD_CLR:  ;in: r0=index, r1=fdset, out: none  ;"extern"
 sub  r0,1
 cmp  r0,FD_SETSIZE
 bxhs lr                ;--> reject
 add  r1,r1,r0,lsr 5
 ldr  r2,[r1,sgFdset_fdbits]
 and  r0,1fh
 mov  r3,1
 bic  r2,r2,r3,lsl r0   ;<-- CLEAR
 str  r2,[r1,sgFdset_fdbits]
 bx   lr
;---
FD_SET:  ;in: r0=index, r1=fdset, out: none  ;"extern"
 sub  r0,1
 cmp  r0,FD_SETSIZE
 bxhs lr                ;--> reject
 add  r1,r1,r0,lsr 5
 ldr  r2,[r1,sgFdset_fdbits]
 and  r0,1fh
 mov  r3,1
 orr  r2,r2,r3,lsl r0   ;<-- SET
 str  r2,[r1,sgFdset_fdbits]
 bx   lr
;---
FD_ISSET:  ;in: r0=index, r1=fdset, out: r0  ;"extern"
 sub  r0,1
 cmp  r0,FD_SETSIZE
 movhs r0,0
 bxhs  lr                ;--> reject (and return zero)
 add  r1,r1,r0,lsr 5
 ldr  r2,[r1,sgFdset_fdbits]
 and  r0,1fh
 mov  r0,r2,lsr r0       ;move to bit0
 and  r0,1               ;isolate bit0
 bx   lr
;---
FD_ZERO:  ;in: r0=fdset, out: none  ;"extern"
;mov  r0,r0
 mov  r1,(FD_SETSIZE+31)/32
 b    zerofill_bytewise
;---
.endif ;with_gimmicks
;------------------
.pool
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_TCP.c - misc
;------------------
.if with_tcp
;------------------
.data?
tcprecords      dd 0    ;ptr to first TcpRec (0=none)
port_counter    dd 0
lasttime        dd 0
synlist:        defs sgTcpSyn_size*SGIP_TCP_MAXSYNS
numsynlist      dd 0    ;number of active entries in synlist (earliest first)
.code
;------------------
sgIP_TCP_Init:  ;in/out: none
 mov  r0,0
 ldr  r1,=tcprecords    ;\
 str  r0,[r1]  ;=0      ;/
 ldr  r1,=numsynlist    ;\
 str  r0,[r1]  ;=0      ;/
 mov  r0,SGIP_TCP_FIRSTOUTGOINGPORT     ;\
 ldr  r1,=port_counter                  ;
 str  r0,[r1]                           ;/
 ldr  r1,=sgIP_timems   ;\
 ldr  r0,[r1]           ;
 ldr  r1,=lasttime      ;
 str  r0,[r1]           ;/
 bx   lr
;------------------
sgIP_TCP_support_seqhash:  ;in: r0=srcip, r1=destip, r2=srcport, r3=destport, out: r0
;compute some "random/checksum" value...
 push r4-r5,lr
 ldr  r5,=sgIP_timems                   ;\get time
 ldr  r5,[r5] ;time                     ;/
 ldr  r4,=48841221h                     ;\
 add  r4,r4,r5,lsl 3  ;plus time*8      ; sum = destip xor srcip...
 mul  r4,r4,r0        ;mul srcip        ;
 eor  r0,r4,r1        ;xor destip       ;/
 ldr  r4,=04020108h                     ;\
 add  r4,r4,r5,lsl 5  ;plus time*20h    ; sum = sum xor destip...
 mul  r4,r4,r1        ;mul destip       ;
 eor  r0,r4           ;xor sum          ;/
 ldr  r4,=80810422h                     ;\
 add  r4,r4,r5,lsl 1  ;plus time*2      ; sum = sum xor srcport...
 mul  r4,r4,r2        ;mul srcport      ;
 eor  r0,r4           ;xor sum          ;/
 ldr  r4,=02041089h                     ;\
 add  r4,r4,r5,lsl 0  ;plus time*1      ; sum = sum xor destport...
 mul  r4,r4,r3        ;mul destport     ;
 eor  r0,r4           ;xor sum          ;/
 pop  r4-r5,pc
;------------------
sgIP_TCP_GetUnusedOutgoingPort:  ;in: none, out: r0=unused port
 ;uh, original code wraps from port>LASTOUTGOINGPORT to port=FIRSTOUTGOINGPORT,
 ;better would be to "port=port-NUMPORTS" (else FIRSTOUTGOINGPORT would be used
 ;ALWAYS when wrapping occurs, which would somewhat negate the "random" effect).
 ;  and, what's that random good for anyways? original code used a 10bit random
 ;step for about 16000 ports, thus risking to reuse the SAME port after only
 ;16 calls, which could probably cause problems, better might be to use a
 ;smaller random step, or to used fixed step +1 instead of random (except,
 ;maybe use random ONLY IF a port is already in use; and of course ensure that
 ;the random value is nonzero).
 ;- - -
 ldr  r1,=port_counter                  ;\
 ldr  r0,[r1]  ;port_counter            ;/
 ldr  r2,=sgIP_timems                   ;\
 ldrb r2,[r2]  ;8bit ("masked")         ; raise by semi-random step
;and  r2,0ffh  ;random mask             ;
 add  r0,r2    ;raise by random         ;/
@@retry_another_port:
 add  r0,1     ;raise by one            ;\raise by one, and
 cmp   r0,SGIP_TCP_LASTOUTGOINGPORT+1   ; wrap if neccessary
 subhs r0,SGIP_TCP_NUMPORTS             ;/
;- - -
 ldr  r2,=tcprecords                                  ;\check if the port number
 ldr  r2,[r2]                                         ; is already in use by any
@@record_lop:                                         ; TCP records
 cmp  r2,0           ;\okay, no more records,         ;  ;\found unused port
 beq  @@found_unused ;/the port is available          ;  ;/
 ldrh  r3,[r2,sgTcpRec_srcport]                       ;  ;\try another port if
 cmp   r3,r0                                          ;  ; already same port
 ldreq r3,[r2,sgTcpRec_tcpstate]                      ;  ; (unless the record
 tsteq r3,SGIP_TCP_STATE_CLOSED+SGIP_TCP_STATE_NODATA ;  ; is CLOSED or NODATA)
 beq   @@retry_another_port  ;port is already used    ;  ;/
 ldr  r2,[r2,sgTcpRec_next]                           ;
 b    @@record_lop                                    ;/
;---
@@found_unused:
 str  r0,[r1]  ;port_counter            ;-memorize port (origin for next call)
;mov  r0,r0  ;out: r0=port
 bx   lr
;------------------
sgIP_TCP_CalcChecksum:  ;in: r0=MemBlk, r1=srcip, r2=destip, r3=totallength, out: r0
;BLAH: incoming "totallength" isn't needed (it's SAME as MemBlk's totallength)
;mov  r0,r0  ;MemBlk                            ;\
;mov  r1,r1  ;srcip                             ;
;mov  r2,r2  ;destip                            ;
 mov  r3,PROTOCOL_IP_TCP*100h  ;protocol        ;
 b    sgIP_memblock_with_faux_header_IPChecksum ;/
;------------------
sgIP_TCP_FixChecksum:  ;in: r0=MemBlk, r1=srcip, r2=destip, out: none
 ;note: original code did have MemBlk in r2 (moved to r0 here)
 ;- - -
 ;BUGGED: this function inverts the 0000xxxxh checksum (to FFFFyyyyh), and then
 ;tries to change the chksum to 0000FFFFh if FFFFyyyyh=ZERO, which CANNOT work
 ;- - -
 ;uh, this function doesn't zeropad MemBlk if totallength is odd (unlike
 ;as "sgIP_TCP_CalcChecksum" and "sgIP_UDP_CalcChecksum", which do zeropad),
 ;though not sure if/why/when the zeropadding is needed anyways...
 ;  the "sgIP_memblock_IPChecksum" subfunction SHOULD be byte-accurate, so
 ;padding shouldn't be needed for checksumming... but maybe padding is needed
 ;for actual transmission or so?
 ;- - -
 push r4-r5,lr
 movs r4,r0  ;MemBlk
 beq  @@exit
 ldr  r5,[r4,sgMemBlk_datastart]  ;TcpHdr
 mov  r3,0                                      ;\initially zero chksum
 strh r3,[r5,sgTcpHdr_checksum]                 ;/
;mov  r0,r0  ;MemBlk                            ;\
;mov  r1,r1  ;srcip                             ;
;mov  r2,r2  ;destip                            ;
 mov  r3,PROTOCOL_IP_TCP*100h  ;protocol        ;
 bl   sgIP_memblock_with_faux_header_IPChecksum ;/
 mvn    r0,r0  ;invert                          ;\checksum isolate LSW
 movs   r0,r0,lsl 16  ;to MSW (isolate LSW)     ; and invert checksum
 mvneq  r0,r0  ;if zero --> invert again        ; (unless result would be zero)
 mov    r0,r0,lsr 16  ;to LSW                   ;/
 strh r0,[r5,sgTcpHdr_checksum]                 ;-apply chksum
@@exit:
 pop  r4-r5,pc
;------------------
sgIP_TCP_GenHeader:  ;in: r0=TcpRec, r1=flags, r2=datalength, out: r0=MemBlk
 push r4-r8,lr
 mov  r4,r0  ;TcpRec
 mov  r5,r1  ;flags
 mov  r6,r2  ;datalen
 bl   sgIP_IP_RequiredHeaderSize  ;hdrsiz       ;\
 add  r0,20  ;hdrsiz+20                         ;
 add  r0,r6  ;hdrsiz+20+datalen                 ; alloc MemBlk
 bl   sgIP_memblock_alloc                       ;
 movs r7,r0  ;MemBlk                            ;
 beq  @@return_r7  ;out: 0=failed               ;/
 bl   sgIP_IP_RequiredHeaderSize  ;hdrsiz       ;\
 rsb  r1,r0,0  ;0-hdrsiz                        ; hide IP header space for later
 mov  r0,r7    ;MemBlk                          ;
 bl   sgIP_memblock_exposeheader                ;/
 ldr  r8,[r7,sgMemBlk_datastart]                ;-TcpHdr.dst = MemBlk.datastart
 ldr  r0,[r4,sgTcpRec_sequence]                 ;\
 bl   htonl                                     ; seqnum
 str  r0,[r8,sgTcpHdr_seqnum]                   ;/
 ldr  r0,[r4,sgTcpRec_ack]                      ;\
 bl   htonl                                     ; acknum
 str  r0,[r8,sgTcpHdr_acknum]                   ;/
 ldrh r0,[r4,sgTcpRec_srcport]                  ;\srcport
 strh r0,[r8,sgTcpHdr_srcport]                  ;/
 ldrh r0,[r4,sgTcpRec_destport]                 ;\destport
 strh r0,[r8,sgTcpHdr_destport]                 ;/
 strb r5,[r8,sgTcpHdr_tcpflags] ;=flags         ;-flags
 mov  r0,0                                      ;\no support for URG data atm
 strh r0,[r8,sgTcpHdr_urg_ptr]  ;=0             ; and init checksum
 strh r0,[r8,sgTcpHdr_checksum] ;=0             ;/
 mov  r0,50h  ;upper bits: 5 words (20 bytes)   ;\dataofs (header length = 20)
 strb r0,[r8,sgTcpHdr_dataofs_]                 ;/
;- - - windowlen...
 ldr  r0,[r4,sgTcpRec_buf_rx_out]               ;\
 ldr  r1,[r4,sgTcpRec_buf_rx_in]                ; calc USED buffer len
 subs r0,r1  ;used.len                          ;
 addlo r0,SGIP_TCP_RECEIVEBUFFERLENGTH ;wrap    ;/
 ldr  r1,=SGIP_TCP_RECEIVEBUFFERLENGTH-1        ;\calc FREE buffer len
 sub  r0,r1,r0                                  ;/
;cmp  r0,0  ;\clip free space to min=0
;movmi r0,0 ;/BLAH, that cannot happen
 cmp  r0,SGIP_TCP_REACK_THRESH                  ;\
 movlo r1,1   ;small windowlen --> want ack     ; indicate an additional ack
 movhs r1,0   ;big windowlen   --> want NO ack  ; should be sent when we have
 tst  r5,SGIP_TCP_FLAG_ACK  ;sgTcpHdr_tcpflags  ; "more space" in the buffer
;XXXX
;;;moveq r1,0   ;flag=off        --> want NO ack  ;   ;uh, "small windowlen"
 strne r1,[r4,sgTcpRec_want_reack] ;<-- TcpRec! ;/  ;    means "more space"???
;cmp  r0,65535  ;\clip windowlen to max 16bit       ;or does it mean "ONCE when we have more space"?
;movhi r0,65535 ;/BLAH, clipped below anyways
 ldr  r1,=1400  ;\                              ;\
 cmp  r0,r1     ; clip windowlen to max 1400    ; don't want to deal with IP fragmentation
 movhi r0,r1    ;/                              ;/uh, is that 1400 some "MTU" related value?
 ldr  r1,[r4,sgTcpRec_ack]                      ;\
 add  r1,r0  ;ack + windowlen                   ; last byte in receive window
 str  r1,[r4,sgTcpRec_rxwindow]                 ;/
 bl   htons   ;windowlen                        ;\apply windowlen
 strh r0,[r8,sgTcpHdr_window]                   ;/
@@return_r7:
 mov  r0,r7  ;MemBlk    ;out: r0=MemBlk (or 0=failed)
 pop  r4-r8,pc
;------------------
sgIP_TCP_SendPacket:  ;in: r0=TcpRec, r1=flags, r2=datalength, out: r0=zero
 ;data sent is taken directly from the TX fifo...
 ;- - -
 ;BUGGED: original code computes the "sgIP_memblock_CopyFromLinear" fragment
 ;length as "SGIP_TCP_TRANSMITBUFFERLENGTH-rec->buf_tx_in" however, it should
 ;actually compute it by subtracting the CURRENT address ("k") instead of the
 ;transfer start address ("rec->buf_tx_in").
 ;the function DOES work somewhat, but only inefficiently (if start is near
 ;buffer end, then it will copy HUNDREDS of small fragements; whilst it should
 ;copy ONE small fragment, followed by ONE large fragment).
 ;uh, also odd: the function doesn't raise "buf_tx_in" after transfer completion
 ;(don't know if/how/why that's working?)
 ;- - -
 push r4-r8,lr
 mov  r5,r0  ;TcpRec
 mov  r6,r1  ;flags
 mov  r7,r2  ;datalength
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp  r5,0   ;TcpRec    ;\
 beq  @@return_zero     ;/
 ldr  r0,[r5,sgTcpRec_buf_tx_out]       ;\
 ldr  r1,[r5,sgTcpRec_buf_tx_in]        ;
 subs r0,r1  ;tx buf size               ; calc how much data is in tx buf,
 addlo r0,SGIP_TCP_TRANSMITBUFFERLENGTH ; and crop datalength to that amount
 cmp   r7,r0 ;datalength                ;
 movhi r7,r0 ;datalength                ;/
 mov  r0,r5  ;TcpRec                    ;\
 mov  r1,r6  ;flags                     ;
 mov  r2,r7  ;datalength                ; get memblock and
 bl   sgIP_TCP_GenHeader                ; generate header
 movs r8,r0  ;MemBlk                    ;
 beq  @@return_zero                     ;/
 ldr  r0,[r5,sgTcpRec_sequence]         ;\
 add  r0,r7  ;datalength                ; seq.next = seq + len
 str  r0,[r5,sgTcpRec_sequence_next]    ;/
 ldr  r1,[r5,sgTcpRec_buf_tx_in]    ;src.index  ;\
 mov  r2,20  ;dst.index in memblk               ;    ;<-- ;uh, what is that?
@@copy_lop:                                     ;         ;"sgTcpHdr_size-4" ???
 cmp  r7,0   ;datalength        ;\              ;
 beq  @@copy_done               ;/              ;
 rsb  r3,r1,SGIP_TCP_TRANSMITBUFFERLENGTH;\     ; copy TX buf to memblk
 cmp  r3,r7  ;disp_to_buf_end, datalen   ; frag ;
 movhi r3,r7 ;fragment.len               ;/     ;
 push r1-r3  ;-->                       ;\      ;
 ldr  r0,=sgTcpRec_buf_tx  ;\      ;src ;       ;
 add  r1,r0  ;index+base   ;       ;src ;       ;
 add  r1,r5  ;+TcpRec      ;/      ;src ; copy  ;
 mov  r0,r8  ;MemBlk               ;dst ;       ;
;mov  r2,r2                        ;skip;       ;
;mov  r3,r3                        ;len ;       ;
 bl   sgIP_memblock_CopyFromLinear      ;       ;
 pop  r1-r3  ;<--                       ;/      ;
 sub  r7,r3    ;decrease datalength     ;\      ;
 add  r2,r3    ;raise dst (aka skiplen) ;       ;
 add  r1,r3    ;raise src               ; next  ;
 cmp  r1,SGIP_TCP_TRANSMITBUFFERLENGTH  ;       ;
 subhs r1,SGIP_TCP_TRANSMITBUFFERLENGTH ;/      ;
 b    @@copy_lop                                ;
@@copy_done:                                    ;/
 ;uh, above doesn't update/advance "sgTcpRec_buf_tx_in" after copying...?
 ;(instead, that's done when receiving an ACK for the packet)
 mov  r0,r8  ;MemBlk                    ;\
 ldr  r1,[r5,sgTcpRec_srcip]            ; fix checksum
 ldr  r2,[r5,sgTcpRec_destip]           ;
 bl   sgIP_TCP_FixChecksum              ;/
 mov  r0,r8  ;MemBlk                    ;\
 mov  r1,PROTOCOL_IP_TCP                ;
 ldr  r2,[r5,sgTcpRec_srcip]            ; send
 ldr  r3,[r5,sgTcpRec_destip]           ;
 bl   sgIP_IP_SendViaIP                 ;/
 ldr  r0,=sgIP_timems                   ;\
 ldr  r0,[r0]                           ; semi-generic timer
 str  r0,[r5,sgTcpRec_time_last_action] ;/
 mov  r0,SGIP_TCP_GENRETRYMS            ;\backoff timer
 str  r0,[r5,sgTcpRec_time_backoff]     ;/
;- - -
@@return_zero:
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,0      ;out: r0=zero (always)
 pop  r4-r8,pc
;------------------
sgIP_TCP_SendSynReply:  ;in: r0=flags, r1=seq, r2=ack, r3=srcip, r4=destip, r5=srcport, r6=destport, r7=windowlen, out: r0=zero
 ;note: windowlen can be "-1", but that's MEANT to MEAN "biggest possible"
 ;ie. windownlen can be treated as UNSIGNED value, with "-1" meaning +FFFFFFFFh
 ;- - -
 push r4-r12,lr
 mov  r8,r0  ;flags
 mov  r9,r1  ;seq
 mov  r10,r2 ;ack
 mov  r11,r3 ;srcip
 bl   sgIP_IntrProtect          ;\
 push r0  ;--->                 ;/
 bl   sgIP_IP_RequiredHeaderSize  ;hdrsiz       ;\
 add  r0,20  ;hdrsiz+20                         ;
 bl   sgIP_memblock_alloc                       ; alloc mem
 movs r12,r0   ;MemBlk                          ;
 beq  @@exit                                    ;/
 bl   sgIP_IP_RequiredHeaderSize  ;hdrsiz       ;\
 rsb  r1,r0,0  ;0-hdrsiz                        ; hide IP header space for later
 mov  r0,r12   ;MemBlk                          ;
 bl   sgIP_memblock_exposeheader                ;/
 mov  r0,r8  ;flags
 ldr  r8,[r12,sgMemBlk_datastart]  ;TcpHdr      ;-get ptr to TcpHdr
 strb r0,[r8,sgTcpHdr_tcpflags] ;flags
 strh r5,[r8,sgTcpHdr_srcport]  ;srcport
 strh r6,[r8,sgTcpHdr_destport] ;destport
 mov  r0,0                                      ;\no support for URG data atm
 strh r0,[r8,sgTcpHdr_urg_ptr]  ;=0             ; and init checksum
 strh r0,[r8,sgTcpHdr_checksum] ;=0             ;/
 mov  r0,50h  ;upper bits: 5 words (20 bytes)   ;\dataofs (header length = 20)
 strb r0,[r8,sgTcpHdr_dataofs_]                 ;/
 ldr  r1,=1400                                  ;\
 cmp  r7,r1     ;windowlen,r1                   ; don't want to deal with IP fragmentation
 movhi r7,r1                                    ;/uh, is that 1400 some "MTU" related value?
 mov  r0,r7                                     ;\
 bl   htons                                     ; apply windowlen
 strh r0,[r8,sgTcpHdr_window]                   ;/
 mov  r0,r9  ;seq                               ;\
 bl   htonl                                     ; apply seqnum
 str  r0,[r8,sgTcpHdr_seqnum]                   ;/
 mov  r0,r10 ;ack                               ;\
 bl   htonl                                     ; apply acknum
 str  r0,[r8,sgTcpHdr_acknum]                   ;/
 mov  r0,r12 ;MemBlk                            ;\
 mov  r1,r11 ;srcip                             ; fix checksum
 mov  r2,r4  ;destip                            ;
 bl   sgIP_TCP_FixChecksum                      ;/
 mov  r0,r12 ;MemBlk                            ;\
 mov  r1,PROTOCOL_IP_TCP                        ;
 mov  r2,r11 ;srcip                             ; send
 mov  r3,r4  ;destip                            ;
 bl   sgIP_IP_SendViaIP                         ;/
@@exit:
 pop  r0  ;<---                 ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,0      ;out: r0=0 (always)
 pop  r4-r12,pc
;------------------
sgIP_TCP_AllocRecord:  ;in: none, out: r0=TcpRec (0=failed)
 push r4-r5,lr
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 ldr  r0,=sgTcpRec_size         ;\
 bl   sgIP_malloc               ; alloc record
 movs r5,r0  ;TcpRec            ;
 beq  @@alloc_failed            ;/
 mov  r0,0                              ;\
 str  r0,[r5,sgTcpRec_buf_oob_in]       ;
 str  r0,[r5,sgTcpRec_buf_oob_out]      ;
 str  r0,[r5,sgTcpRec_buf_rx_in]        ; reset
 str  r0,[r5,sgTcpRec_buf_rx_out]       ; entries
 str  r0,[r5,sgTcpRec_buf_tx_in]        ; to zero
 str  r0,[r5,sgTcpRec_buf_tx_out]       ;
 str  r0,[r5,sgTcpRec_tcpstate]         ;    ;<-- aka SGIP_TCP_STATE_NODATA
 str  r0,[r5,sgTcpRec_maxlisten]        ;
 str  r0,[r5,sgTcpRec_srcip]            ;
;str  rx,[r5,sgTcpRec_destip]           ;
;strh rx,[r5,sgTcpRec_srcport]          ;
;strh rx,[r5,sgTcpRec_destport]         ;
;str  rx,[r5,sgTcpRec_sequence]         ;
;str  rx,[r5,sgTcpRec_ack]              ;
;str  rx,[r5,sgTcpRec_sequence_next]    ;
;str  rx,[r5,sgTcpRec_rxwindow]         ;
;str  rx,[r5,sgTcpRec_txwindow]         ;
;str  rx,[r5,sgTcpRec_time_last_action] ;
;str  rx,[r5,sgTcpRec_time_backoff]     ;
 str  r0,[r5,sgTcpRec_retrycount]       ;
 str  r0,[r5,sgTcpRec_errorcode]        ;
 str  r0,[r5,sgTcpRec_listendata]       ;
 str  r0,[r5,sgTcpRec_want_shutdown]    ;
 str  r0,[r5,sgTcpRec_want_reack]       ;/
 ldr  r1,=tcprecords                    ;\
 ldr  r0,[r1]  ;get old 1st TcpRec      ; add to record chain
 str  r0,[r5,sgTcpRec_next]             ; (as new 1st record)
 str  r5,[r1]  ;apply as new 1st TcpRec ;/
@@alloc_failed:
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5     ;out: r0=TcpRec (or 0=failed)
 pop  r4-r5,pc
;------------------
sgIP_TCP_FreeRecord:  ;in: r0=TcpRec, out: none
 push r4-r10,lr
 movs r5,r0  ;TcpRec            ;\
 beq  @@oops_no_record          ;/
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
;- - -
 mov  r0,0  ;aka SGIP_TCP_STATE_NODATA          ;\reset state
 str  r0,[r5,sgTcpRec_tcpstate]                 ;/
 ldr  r1,=tcprecords      ;ptr to 1st record    ;\
@@chain_lop:                                    ;
 ldr  r0,[r1]             ;ptr to record        ;
;cmp  r0,0         ;\unexpected chain end       ; remove record
;beq  @@chain_oops ;/(shouldn't happen)         ; from chain
 cmp  r0,r5   ;TcpRec  ;<-- search this         ;
 addne r1,r0,sgTcpRec_next ;ptr to next record  ;
 bne   @@chain_lop                              ;
 ldr  r0,[r5,sgTcpRec_next] ;ptr to next record ;
 str  r0,[r1]          ;<-- remove from chain   ;/
 ldr  r7,[r5,sgTcpRec_listendata]       ;\
 cmp  r7,0                              ; check if there's listendata
 beq  @@no_listendata                   ;/
;- - - dealloc child records...
 ldr  r6,[r5,sgTcpRec_maxlisten]        ;\
@@dealloc_child_lop:                    ;
 ldr  r0,[r7],4  ;listendata[N]         ;
 cmp  r0,0                              ; deallocate any child records
 beq  @@dealloc_child_done              ;
;mov  r0,r0                             ;
 bl   sgIP_TCP_FreeRecord  ;recursive!! ;
 subs r6,1                              ;
 bne  @@dealloc_child_lop               ;
@@dealloc_child_done:                   ;/
;- - - kill any possible waiting elements in the SYN chain...
 ldr  r10,=numsynlist                   ;\
 ldr  r6,[r10] ;num.old                 ;
 mov  r7,0     ;num.new                 ; SYN chain...
 ldr  r8,=synlist  ;src                 ;
 ldr  r9,=synlist  ;dst                 ;
@@kill_syn_lop:                         ;
 ldr  r0,[r8,sgTcpSyn_linked] ;src      ;   ;\skip/discard src if it was
 cmp  r0,r5  ;TcpRec                    ;   ; referring to the free'd TcpRec
 beq  @@kill_syn_next                   ;   ;/
 cmp  r8,r9    ;src,dst  ;\             ;   ;\
 movne r0,r8        ;src ; copy         ;   ; preserve src, copy to dst
 movne r1,r9        ;dst ; (unless      ;   ; (unless src=dst, then skip
 movne r2,sgTcpSyn_size  ; src=dst)     ;   ; the copy; for speedup)
 blne  memcopy_bytewise  ;/             ;   ;
 add  r7,1     ;num.new                 ;   ;  ;<-- raise NUM still used
 add  r9,sgTcpSyn_size ;dst             ;   ;/
@@kill_syn_next:                        ;
 add  r8,sgTcpSyn_size ;src             ;
 subs r6,1      ;num.old                ;
 bne  @@kill_syn_lop                    ;
 str  r7,[r10]  ;[numsynlist]=num.new   ;/     ;<-- apply NUM still used
;- - -
 ldr  r0,[r5,sgTcpRec_listendata]       ;\dealloc listendata
 bl   sgIP_free                         ;/
@@no_listendata:
 mov  r0,r5  ;TcpRec            ;\dealloc record
 bl   sgIP_free                 ;/
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
@@oops_no_record:
 pop  r4-r10,pc
;------------------
sgIP_TCP_Bind:  ;in: r0=TcpRec, r1=srcport, r2=srcip, out: r0=zero
 push r4-r7,lr
 mov  r5,r0  ;TcpRec
 mov  r6,r1  ;srcport
 mov  r7,r2  ;srcip
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp  r5,0   ;TcpRec            ;\refuse if no record
 beq  @@return_zero             ;/
 ldr  r0,[r5,sgTcpRec_tcpstate] ;\
 cmp  r0,SGIP_TCP_STATE_NODATA  ; refuse if wrong state
 bne  @@return_zero             ;/
 str  r7,[r5,sgTcpRec_srcip]    ;\apply src port/ip
 strh r6,[r5,sgTcpRec_srcport]  ;/
 mov  r0,SGIP_TCP_STATE_UNUSED  ;\apply new state
 str  r0,[r5,sgTcpRec_tcpstate] ;/
@@return_zero:
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,0      ;out: r0=zero (always)
 pop  r4-r7,pc
;------------------
sgIP_TCP_Listen:  ;in: r0=TcpRec, r1=maxlisten, out: r0=zero (or -1)
 cmp  r0,0  ;TcpRec                     ;\error if rec=0
 beq  sgIP_error_inval                  ;/
 ldr  r2,[r0,sgTcpRec_tcpstate]         ;\
 cmp  r2,SGIP_TCP_STATE_UNUSED          ; error if state isn't UNUSED
 bne  sgIP_error_inval                  ;/
;- - -
 push r4-r6,lr
 mov  r5,r0  ;TcpRec    ;-
 movs r6,r1  ;maxlisten ;\
 moveq r6,1  ;min one   ;/
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 ldr  r0,[r5,sgTcpRec_maxlisten]        ;\
 cmp  r0,0                              ; exit if *already* listening
 bne  @@return_zero                     ;/
 mov  r0,r6,lsl 2  ;maxlisten*4                 ;\
 bl   sgIP_malloc                               ; alloc pointers to TCP records,
 cmp  r0,0           ;\exit if alloc failed     ; 0-terminated list
 beq  @@return_zero  ;/                         ;/
 str  r0,[r5,sgTcpRec_listendata]       ;-apply allocated ptr array
 mov  r1,0                              ;\mark array empty (terminate by zero)
 str  r1,[r0]  ;listendata[0]=0         ;/
 str  r6,[r5,sgTcpRec_maxlisten]        ;-apply maxlisten
 mov  r0,SGIP_TCP_STATE_LISTEN          ;\state
 str  r0,[r5,sgTcpRec_tcpstate]         ;/

        .if with_listen_log
        bl wrcrlf
        mov r0,'L' // bl wrchr_r0
        mov r0,'I' // bl wrchr_r0
        mov r0,'S' // bl wrchr_r0
        mov r0,'T' // bl wrchr_r0
        mov r0,'E' // bl wrchr_r0
        mov r0,'N' // bl wrchr_r0
        .endif

@@return_zero:
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,0      ;out: r0=zero
 pop  r4-r6,pc
;------------------
sgIP_TCP_Accept:  ;in: r0=TcpRec, out: r0=TcpRec (or 0=failed/none)
 push r4-r5,lr
 mov  r5,r0  ;TcpRec
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp  r5,0   ;TcpRec                    ;\error if no record
 beq  @@error_inval                     ;/
 ldr  r0,[r5,sgTcpRec_tcpstate]         ;\
 cmp  r0,SGIP_TCP_STATE_LISTEN          ; error if state isn't LISTEN
 bne  @@error_inval                     ;/
 ldr  r3,[r5,sgTcpRec_listendata]       ;\
 cmp  r3,0                         ;r3  ; error if no listendata array
 beq  @@error_inval                     ;/
 ldr  r0,[r3,0]  ;listendata[0]    ;r3  ;\get first TcpRec from array
 cmp  r0,0       ;TcpRec (0=none)       ; error if listendata array is empty
 beq  @@error_wouldblock                ;/
 ldr  r2,[r5,sgTcpRec_maxlisten]        ;\
@@remove_lop:                           ;
 subs r2,1     ;max                     ; remove the record from the array
 moveq r1,0    ;end code                ; (move next entries down,
 ldrne r1,[r3,4]  ;\move to prev   ;r3  ; and terminate by zero)
 str   r1,[r3],4  ;/entry          ;r3  ;
 cmpne r1,0    ;end code                ;
 bne  @@remove_lop                      ;/

        ;bl wrhex32bit

;mov  r0,r0  ;TcpRec                    ;-return the removed TcpRec
@@return_r0:
 mov  r5,r0  ;return value
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5  ;return value (TcpRec, or 0=failed)
 pop  r4-r5,pc
;---
@@error_inval:
 bl   sgIP_error_inval
 mov  r0,0              ;return ZERO (not -1, unlike as usually for EINVAL)
 b    @@return_r0
;---
@@error_wouldblock:
 bl   sgIP_error_wouldblock
 mov  r0,0              ;return ZERO (not -1, unlike as usually for EWOULDBLOCK)
 b    @@return_r0
;------------------
sgIP_TCP_Close:  ;in: r0=TcpRec, out: r0
 cmp  r0,0 // beq sgIP_error_inval      ;-error if rec=0
 push r4-r5,lr
 mov  r5,r0  ;TcpRec
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 ldr  r0,[r5,sgTcpRec_want_shutdown]    ;\
 cmp  r0,0                              ; if want_shutdown=0
 moveq r0,1                             ; then want_shutdown=1
 streq r0,[r5,sgTcpRec_want_shutdown]   ;/
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,0     ;out: r0=0 (okay)
 pop  r4-r5,pc
;------------------
sgIP_TCP_Connect:  ;in: r0=TcpRec, r1=destip, r2=destport, out: r0
 cmp  r0,0 // beq sgIP_error_inval      ;-error if rec=0
 push r4-r7,lr
 mov  r5,r0  ;TcpRec
 mov  r6,r1  ;destip
 mov  r7,r2  ;destport
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 ldr  r0,[r5,sgTcpRec_tcpstate]                 ;\
 cmp  r0,SGIP_TCP_STATE_NODATA  ;\need to bind  ;
 beq  @@need_to_bind            ;/              ; check state
 cmp  r0,SGIP_TCP_STATE_UNUSED  ;\already bound ;
 beq  @@already_bound           ;/              ;
 bl   sgIP_error_inval          ;\other/error   ;
 b    @@return_r0               ;/              ;/
;---
@@need_to_bind:  ;need to bind a local address
 mov  r0,0   ;srcip (none)              ;\
 mov  r1,r6  ;destip                    ; srcip
 bl   sgIP_IP_GetLocalBindAddr          ;
 str  r0,[r5,sgTcpRec_srcip]            ;/
 bl   sgIP_TCP_GetUnusedOutgoingPort    ;\
;mov  r0,r0                             ; srcport
 bl   htons                             ;
 strh r0,[r5,sgTcpRec_srcport]          ;/
 b    @@finish
;---
@@already_bound:  ;already bound to a local address
 ldr  r0,[r5,sgTcpRec_srcip]  ;old src  ;\
 mov  r1,r6  ;destip                    ; srcip
 bl   sgIP_IP_GetLocalBindAddr          ;
 str  r0,[r5,sgTcpRec_srcip]            ;/
;- - -
@@finish:
 str  r6,[r5,sgTcpRec_destip]           ;-destip
 strh r7,[r5,sgTcpRec_destport]         ;-destport
;send a SYN packet, and advance the state of the connection...
 ldr  r0,[r5,sgTcpRec_srcip]            ;\
 ldr  r1,[r5,sgTcpRec_destip]           ;
 ldrh r2,[r5,sgTcpRec_srcport]          ; make random sequence number
 ldrh r3,[r5,sgTcpRec_destport]         ;
 bl   sgIP_TCP_support_seqhash          ;
 str  r0,[r5,sgTcpRec_sequence]         ;/
 mov  r0,r5  ;TcpRec                    ;\
 mov  r1,SGIP_TCP_FLAG_SYN              ; send
 mov  r2,0                              ;
 bl   sgIP_TCP_SendPacket               ;/
 mov  r0,0                              ;\retrycount=0
 str  r0,[r5,sgTcpRec_retrycount]       ;/
 mov  r0,SGIP_TCP_STATE_SYN_SENT        ;\state SYN SENT
 str  r0,[r5,sgTcpRec_tcpstate]         ;/
 mov  r0,0   ;okay
@@return_r0:
 mov  r5,r0  ;return value
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5  ;return value
 pop  r4-r7,pc
;------------------
sgIP_TCP_Send:  ;in: r0=TcpRec, r1=datatosend, r2=datalength, r3=flags, out: r0
 ;uh, should better skip if incoming datalength is zero (else the function
 ;reports EWOULDBLOCK in that case; because it "couldn't" transfer any bytes)
 ;- - -
 push r4-r10,lr
 mov  r5,r0  ;TcpRec
 mov  r6,r1  ;datatosend
 mov  r7,r2  ;datalength
 mov  r8,r3  ;flags
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp  r5,0   ;TcpRec                    ;\
 cmpne r6,0  ;datatosend                ; error if no record or len=0
 beq   @@error_in_val                   ;/
 ldr  r0,[r5,sgTcpRec_want_shutdown]    ;\
 cmp  r0,0                              ; error if want shutdown
 bne  @@error_shutdown                  ;/
 ldr  r0,[r5,sgTcpRec_buf_tx_out]       ;\
 ldr  r1,[r5,sgTcpRec_buf_tx_in]        ;
 subs r0,r1                         ;zf ; calc how much is already in TX buf
 addlo r0,SGIP_TCP_TRANSMITBUFFERLENGTH ;
 bne  @@tx_buf_not_empty            ;zf ;
 ldr  r1,=sgIP_timems                   ; ;\
 ldr  r1,[r1]                           ; ; if TX buf was empty,
 str  r1,[r5,sgTcpRec_time_last_action] ; ; ie. when sending first byte,
 mov  r1,SGIP_TCP_GENRETRYMS            ; ; set up delay before sending
 str  r1,[r5,sgTcpRec_time_backoff]     ; ;/
@@tx_buf_not_empty:                     ;/
 ldr  r1,=SGIP_TCP_TRANSMITBUFFERLENGTH-1 ;\calc FREE space in TX buf
 sub  r0,r1,r0                            ;/
 cmp  r7,r0  ;datalength                ;\crop datalen to max FREE space
 movhi r7,r0 ;datalength                ;/
;- - -
 ldr  r9,[r5,sgTcpRec_buf_tx_out]  ;dst ;\
 mov  r10,r7 ;buflength                 ;
@@copy_lop:                             ;
 cmp  r10,0  ;len       ;\              ; copy "datatosend" to TX buf
 beq  @@copy_done       ;/              ;
 rsb  r2,r9,SGIP_TCP_TRANSMITBUFFERLENGTH
 cmp  r2,r10  ;disp to buf end          ;
 movhi r2,r10 ;crop len                 ;
 mov  r0,r6  ;datatosend       ;src ;\  ;
 ldr  r1,=sgTcpRec_buf_tx      ;dst ;   ;
 add  r1,r5  ;TcpRec           ;dst ;   ;
 add  r1,r9  ;dst.index        ;dst ;   ;
;mov  r2,r2                    ;len ;   ;
 sub  r10,r2 ;decrease len ;\       ;   ;
 add  r6,r2  ;raise src    ;        ;   ;
 add  r9,r2  ;raise dst    ;/       ;   ;
 bl   memcopy_bytewise              ;/  ;
 cmp  r9,SGIP_TCP_TRANSMITBUFFERLENGTH  ;
 subhs r9,SGIP_TCP_TRANSMITBUFFERLENGTH ;
 b    @@copy_lop                        ;
@@copy_done:                            ;
 str  r9,[r5,sgTcpRec_buf_tx_out]  ;dst ;/
;- - - check for immediate transmit (of new TX data, plus any old TX data)...
 ldr  r2,[r5,sgTcpRec_buf_tx_out]       ;\
 ldr  r3,[r5,sgTcpRec_buf_tx_in]        ; calc how much is now in TX buf
 subs r2,r3    ;buf.len                 ; (old TX data plus newly added TX data)
 addlo r2,SGIP_TCP_TRANSMITBUFFERLENGTH ;/
 ldr  r0,[r5,sgTcpRec_sequence_next]    ;\
 ldr  r1,[r5,sgTcpRec_sequence]         ; calc sequence len
 sub  r0,r1    ;seq.len                 ;/
 sub  r3,r2,r0 ;buf.len - seq.len       ;-uh, subtract what/why?
 cmp  r3,SGIP_TCP_TRANSMIT_IMMTHRESH    ;\
 ble  @@no_immediate_transmit  ;signed! ; no immediate transmit
 ldr  r3,[r5,sgTcpRec_tcpstate]         ; if small len, or
 cmp  r3,SGIP_TCP_STATE_ESTABLISHED     ; if not established, or
 bne  @@no_immediate_transmit           ; if "arbitrary constant" 1000
 cmp  r0,1000 ;seq.len,1000             ;     ;uh, arbitrary what?
 bge  @@no_immediate_transmit  ;signed! ;/
 ldr  r0,[r5,sgTcpRec_txwindow]      ;\ ;\
 ldr  r1,[r5,sgTcpRec_sequence]      ;  ;
 sub  r0,r1  ;window.len ?           ;  ;
 cmp  r2,r0    ;buf.len - window.len ;  ; okay, do immediate transmit...
 movhi r2,r0   ;crop                 ;/ ; (forward TX buf to next layer)
 push r2     ;--> len                ;\ ;
 ldr  r0,[r5,sgTcpRec_destip]        ;  ;
 bl   sgIP_IP_MaxContentsSize        ;  ;   ;BUGGED: this has the "if(j>i) j=i;"
 sub  r0,20   ;maxcontent-20         ;  ;   ;bug that also exist elsewhere,
 pop  r2     ;<-- len                ;  ;   ;see other comment on "if(j>i) j=i;"
 cmp  r2,r0    ;buf.len - maxcontent ;  ;   ;for details.
 movhi r2,r0   ;crop                 ;/ ;
 mov  r0,r5  ;TcpRec            ;\      ;
 mov  r1,SGIP_TCP_FLAG_ACK      ; send  ;
;mov  r2,r2  ;len               ;       ;
 bl   sgIP_TCP_SendPacket       ;/      ;/
 mov  r0,0                              ;\reset retrycount
 str  r0,[r5,sgTcpRec_retrycount]       ;/
@@no_immediate_transmit:
 movs r0,r7  ;datalength  ;return value (num bytes transferred)
 beq  @@error_wouldblock
@@return_r0:
 mov  r5,r0  ;return value
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5  ;return value (num bytes transferred, or -1=error)
 pop  r4-r10,pc
;---
@@error_in_val:
 bl   sgIP_error_inval
 b    @@return_r0
;---
@@error_shutdown:
 bl   sgIP_error_shutdown
 b    @@return_r0
;---
@@error_wouldblock:
 bl   sgIP_error_wouldblock
 b    @@return_r0
;------------------
sgIP_TCP_Recv:  ;in: r0=TcpRec, r1=databuf, r2=buflength, r3=flags, out: r0
 push r4-r10,lr
 mov  r5,r0  ;TcpRec
 mov  r6,r1  ;databuf
 mov  r7,r2  ;buflength
 mov  r8,r4  ;flags
 bl   sgIP_IntrProtect          ;\
 mov  r4,r0                     ;/
 cmp  r5,0   ;TcpRec                    ;\
 cmpne r6,0  ;databuf                   ; error if no record or no data
 beq   @@error_in_val                   ;/


 ldr  r0,[r5,sgTcpRec_buf_rx_out]       ;\
 ldr  r1,[r5,sgTcpRec_buf_rx_in]        ; get rxbuflen, and "buf_rx_in"
 subs r0,r1  ;rxlen                     ; check if empty
 beq   @@rx_buffer_empty                ;
 addlo r0,SGIP_TCP_RECEIVEBUFFERLENGTH  ;/
 cmp  r7,r0  ;buflength,rxlen           ;\crop buflength to rxbuflen
 movhi r7,r0 ;buflength=rxlen           ;/

     .if 0       ;XNAY
         ;;;mov r0,r5
         bl wrhex32bit
         bl wrspc
         ldr  r0,[r5,sgTcpRec_buf_rx_out]
         bl wrhex32bit
         bl wrspc
         ldr  r0,[r5,sgTcpRec_buf_rx_in]
         bl wrhex32bit
         bl wrspc
        mov r0,'R' // bl wrchr_r0
        mov r0,'E' // bl wrchr_r0
        mov r0,'C' // bl wrchr_r0
        mov r0,'V' // bl wrchr_r0
        mov r0,'L' // bl wrchr_r0
        mov r0,'E' // bl wrchr_r0
        mov r0,'N' // bl wrchr_r0
        mov r0,r7 // bl wrhex32bit
         bl wrspc
         ldr  r2,=tcprecords
         ldr  r2,[r2]
        @@record_lop:
         cmp  r2,0           ;\
         beq  @@record_end   ;/
         cmp  r2,r5          ;\
         beq  @@record_found ;/
         ldr  r2,[r2,sgTcpRec_next]
         b    @@record_lop
        ;---
        @@record_found:
        mov r0,'+' // bl wrchr_r0
        @@record_end:
        mov r0,'/' // bl wrchr_r0
     .endif

;- - -
 ldr  r9,[r5,sgTcpRec_buf_rx_in]   ;src ;\
 mov  r10,r7 ;buflength                 ;
@@copy_lop:                             ;
 cmp  r10,0  ;len       ;\              ; copy from RX buf to "databuf"
 beq  @@copy_done       ;/              ;
 rsb  r2,r9,SGIP_TCP_RECEIVEBUFFERLENGTH;
 cmp  r2,r10  ;disp to buf end          ;
 movhi r2,r10 ;crop len                 ;
 add  r0,r5,sgTcpRec_buf_rx    ;src ;\  ;
 add  r0,r9  ;src.index        ;src ;   ;
 mov  r1,r6  ;databuf          ;dst ;   ;
;mov  r2,r2                    ;len ;   ;
 sub  r10,r2 ;decrease len ;\       ;   ;
 add  r9,r2  ;raise src    ;        ;   ;
 add  r6,r2  ;raise dst    ;/       ;   ;
 bl   memcopy_bytewise              ;/  ;
 cmp  r9,SGIP_TCP_RECEIVEBUFFERLENGTH   ;
 subhs r9,SGIP_TCP_RECEIVEBUFFERLENGTH  ;
 b    @@copy_lop                        ;
@@copy_done:                            ;/
;- - -
 tst  r8,MSG_PEEK  ;flags               ;\when PEEKing, skip remaining stuff
 bne  @@just_peeking_do_not_process     ;/
 str  r9,[r5,sgTcpRec_buf_rx_in]   ;src ;-apply new buffer address (unless PEEK)
 ldr  r0,[r5,sgTcpRec_want_reack]       ;\
 cmp  r0,0                              ; check if want reack (unless PEEK)
 beq  @@skip_reack                      ;/
 ldr  r0,[r5,sgTcpRec_buf_rx_out]       ;\
 ldr  r1,[r5,sgTcpRec_buf_rx_in]        ; get rxbuflen
 subs r0,r1  ;rxlen                     ; (used space)
 addlo r0,SGIP_TCP_RECEIVEBUFFERLENGTH  ;/
 ldr  r1,=SGIP_TCP_RECEIVEBUFFERLENGTH-1;\free space
 sub  r0,r1,r0                          ;/
;cmp  r0,0  ;\clip free space to min=0
;movmi r0,0 ;/BLAH, that cannot happen
 cmp  r0,SGIP_TCP_REACK_THRESH          ;\if LITTLE space: keep WANTING reack
 bls  @@keep_wanting_reack              ;/(but can't send it now due to space)
 mov  r0,0                        ;\    ;\
 str  r0,[r5,sgTcpRec_want_reack] ;/    ; enough space:
 mov  r0,r5  ;TcpRec         ;\         ; don't want reack anymore,
 mov  r1,SGIP_TCP_FLAG_ACK   ; send     ; instead, send the ACK right now
 mov  r2,0   ;datalength     ;          ;
 bl   sgIP_TCP_SendPacket    ;/         ;/
@@keep_wanting_reack:
@@skip_reack:
@@just_peeking_do_not_process:
 mov  r0,r7  ;buflength         ;okay, out: r0=buflength (num bytes received)
@@return_r0:
 mov  r5,r0  ;return value
 mov  r0,r4                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5  ;return value (buflength, or -1=failed)
 pop  r4-r10,pc
;---
@@rx_buffer_empty:
 ldr  r0,[r5,sgTcpRec_want_shutdown]            ;\
 ldr  r1,[r5,sgTcpRec_tcpstate]                 ;
 cmp   r0,0    ;want_shutdown           ;\      ; check if shutting down
 cmpeq r1,SGIP_TCP_STATE_CLOSE_WAIT     ;       ;
 beq   @@shutting_down                  ;/      ;
 cmp   r0,2    ;want_shutdown           ;\      ;
 cmpeq r1,SGIP_TCP_STATE_TIME_WAIT      ;       ;
 beq   @@shutting_down                  ;/      ;/
 bl   sgIP_error_wouldblock                     ;-nope, but would block!
 b    @@return_r0
;---
@@shutting_down:
 ldr  r0,[r5,sgTcpRec_errorcode]        ;\check if there's an error code
 cmp  r0,0                              ;/
 ldrne r1,=errno                        ;\
 strne r0,[r1]                          ; if so, return errno=err, and r0=-1
 movne r0,-1                            ;
 bne   @@return_r0  ;-->                ;/
 bl   sgIP_error_shutdown               ;\else return errno=shutdown
 mov  r0,0   ;???                       ;   uh, and r0=0 in this case, not -1?
 b    @@return_r0   ;-->                ;/
;---
@@error_in_val:
 bl   sgIP_error_inval
 b    @@return_r0
;------------------
.pool
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_TCP.c - timer
;------------------
sgIP_TCP_Timer:  ;in/out: none
 ;scan through tcp records and resend anything necessary
 ;- - -
 ;BUGGED: comment in original code says that SGIP_TCP_STATE_CLOSE_WAIT
 ;should "[do nothing]", but actually it DOES the same stuff as what's done
 ;for SGIP_TCP_STATE_ESTABLISHED - dunno if that's correct (maybe required
 ;to clean up?), or not. Anyways, either the CODE or the COMMENT is wrong.
 ;- - -
 push r4-r10,lr
;- - - - process SYN list...
 ldr  r0,=sgIP_timems           ;\
 ldr  r0,[r0]                   ;
 ldr  r1,=lasttime              ; compute time since last SYN lop
 ldr  r2,[r1]  ;old lasttime    ;
 str  r0,[r1]  ;new lasttime    ;
 sub  r10,r0,r2  ;TimeSince     ;/
 ldr  r9,=numsynlist            ;\
 ldr  r9,[r9]                   ;
 ldr  r8,=synlist               ;/
@@syn_lop:
 subs r9,1                      ;\
 blo  @@syn_done                ;/
 ldr  r0,[r8,sgTcpSyn_timenext]                 ;\
 subs r0,r10   ;sub TimeSince               ;r0 ; decrease time, and
 strhi r0,[r8,sgTcpSyn_timenext]            ;r0 ; lop next if notyet ellapsed
 bhi   @@syn_next                               ;/
 ldr  r1,[r8,sgTcpSyn_timebackoff]              ;\
 mov  r1,r1,lsl 1  ;mul2                        ; raise timebackoff
 cmp  r1,SGIP_TCP_BACKOFFMAX                    ; (mul2, clip to max)
 movhi r1,SGIP_TCP_BACKOFFMAX                   ;
 str  r1,[r8,sgTcpSyn_timebackoff]              ;/
 adds r1,r0 ;backoff + (neg)time_underkill  ;r0 ;\apply timebackoff as
 movmi r1,0 ;min zero (if result was negative)  ; new timenext (minus
 str  r1,[r8,sgTcpSyn_timenext]                 ;/the underkill)
 mov  r0,SGIP_TCP_FLAG_SYN+SGIP_TCP_FLAG_ACK    ;\
 ldr  r1,[r8,sgTcpSyn_localseq]                 ;
 ldr  r2,[r8,sgTcpSyn_remoteseq]                ;
 ldr  r3,[r8,sgTcpSyn_localip]                  ; resend SYN
 ldr  r4,[r8,sgTcpSyn_remoteip]                 ;
 ldrh r5,[r8,sgTcpSyn_localport]                ;
 ldrh r6,[r8,sgTcpSyn_remoteport]               ;
 mov  r7,0ffffffffh ;windowlen=biggest possible ;
 bl   sgIP_TCP_SendSynReply                     ;/
@@syn_next:
 add  r8,sgTcpSyn_size          ;\lop next SYN
 b    @@syn_lop                 ;/
@@syn_done:
;- - - - process TCP records...
 ldr  r4,=tcprecords            ;\
 ldr  r4,[r4] ;TcpRec           ;/
@@record_lop:
 cmp  r4,0    ;TcpRec           ;\
 beq  @@record_lop_done         ;/

       .if 0       ;XNAY
              mov r0,'T' // bl wrchr_r0
       .endif

 ldr  r0,=sgIP_timems                           ;\
 ldr  r0,[r0]                                   ; compute TimeSinceLastAction
 ldr  r1,[r4,sgTcpRec_time_last_action]         ;
 sub  r1,r0,r1  ;TimeSinceLastAction            ;/
 ldr   r0,[r4,sgTcpRec_tcpstate]    ;-get state
 cmp   r0,SGIP_TCP_STATE_SYN_SENT            ;\ ;-connect initiated
 moveq r0,SGIP_TCP_FLAG_SYN                  ;  ;---> resend SYN
 beq   @@resend_flag_r0                      ;/
 cmp   r0,SGIP_TCP_STATE_CLOSE_WAIT          ;\ ;-got FIN, wait for user code to close socket & send FIN [do nothing]   ;uh, nothing?
 cmpne r0,SGIP_TCP_STATE_ESTABLISHED         ;  ;-syns have been exchanged
 beq   @@established                         ;/ ;---> check for data in buffer, send
 cmp   r0,SGIP_TCP_STATE_FIN_WAIT_1          ;\ ;-sent a FIN, haven't got FIN or ACK yet
 moveq r0,SGIP_TCP_FLAG_FIN                  ;  ;---> resend FIN
 beq   @@resend_flag_r0                      ;/
 cmp   r0,SGIP_TCP_STATE_CLOSING             ;\ ;-got FIN, waiting for ACK of our FIN
 cmpne r0,SGIP_TCP_STATE_LAST_ACK            ;  ;-wait for ACK of our last FIN
 moveq r0,SGIP_TCP_FLAG_FIN+SGIP_TCP_FLAG_ACK;  ;---> resend FIN+ACK
 beq   @@resend_flag_r0                      ;/
 cmp   r0,SGIP_TCP_STATE_TIME_WAIT           ;\ ;-wait to ensure remote tcp knows it's been terminated
 beq   @@time_wait                           ;/ ;---> reset/shutdown in 2MSL
;cmp   r0,SGIP_TCP_STATE_NODATA              ;\ ;-newly allocated
;cmpne r0,SGIP_TCP_STATE_UNUSED              ;  ;-allocated & BINDed
;cmpne r0,SGIP_TCP_STATE_CLOSED              ;  ;-Block is unused
;cmpne r0,SGIP_TCP_STATE_LISTEN              ;  ;-listening
;cmpne r0,SGIP_TCP_STATE_FIN_WAIT_2          ;  ;-got ACK for our FIN, haven't got FIN yet
;cmpne r0,<other>                            ;  ;-other
;beq   @@next_record                         ;/ ---> do nothing
@@next_record:                  ;\
 ldr   r4,[r4,sgTcpRec_next]    ; lop next record
 b     @@record_lop             ;/
;---
@@record_lop_done:
 pop  r4-r10,pc
;--- --- ---
@@time_wait:  ;in: r1=TimeSinceLastAction
 cmp  r1,SGIP_TCP_TIMEMS_2MSL   ;\exit if time notyet ellapsed
 bls  @@next_record             ;/
 mov  r0,ESHUTDOWN                      ;\shutdown
 str  r0,[r4,sgTcpRec_errorcode]        ;/
 mov  r0,SGIP_TCP_STATE_CLOSED          ;\close
 str  r0,[r4,sgTcpRec_tcpstate]         ;/
 b    @@next_record
;--- --- ---
@@resend_flag_r0:  ;in: r0=flag, r1=TimeSinceLastAction
 ldr  r2,[r4,sgTcpRec_time_backoff]             ;\
 cmp  r1,r2                                     ; exit if no timeout yet
 bls  @@next_record                             ;/
 ldr  r3,[r4,sgTcpRec_retrycount]               ;\
 add  r3,1                                      ; raise retry count,
 str  r3,[r4,sgTcpRec_retrycount]               ; and give up if too high
 cmp  r3,SGIP_TCP_MAXRETRY                      ;
 bhs  @@resend_give_up                          ;/
 ldr  r8,[r4,sgTcpRec_time_backoff]             ;\
 mov  r8,r8,lsl 1  ;mul2                        ; raise backoff
 cmp  r8,SGIP_TCP_BACKOFFMAX                    ; (mul2, clip to max)
 movhi r8,SGIP_TCP_BACKOFFMAX                   ;/
 mov  r2,0   ;datalength                        ;\
 mov  r1,r0  ;flag        ;<-- r0               ; send
 mov  r0,r4  ;TcpRec                            ;
 bl   sgIP_TCP_SendPacket                       ;/
 str  r8,[r4,sgTcpRec_time_backoff]             ;-preserve backoff
 b    @@next_record
;---
@@resend_give_up:  ;in: r0=flag
 cmp  r0,SGIP_TCP_FLAG_SYN ;flag                ;\
 moveq r0,ECONNABORTED  ;for SYN                ; errorcode
 movne r0,ETIMEDOUT     ;for FIN and FIN+ACK    ;
 str  r0,[r4,sgTcpRec_errorcode]                ;/
 mov  r0,SGIP_TCP_STATE_CLOSED                  ;\close
 str  r0,[r4,sgTcpRec_tcpstate]                 ;/
 b    @@next_record
;--- --- ---
@@established:  ;in: r1=TimeSinceLastAction
 ;BUGGED: original code does try to calculate "datalength" (i) as so:
 ;  i=sgIP_IP_MaxContentsSize(rec->destip)-20; // max tcp data size
 ;  if(j>i) j=i;       <--- WRONG, should be vice-versa: "i>j" and "i=j"
 ;that bug exists TWICE (for "never-sent bytes" and for "resend last packet")
 ;and a THIRD, bug ALSO exists for "immediate transmit" (in "sgIP_TCP_Send").
 ;- - -
 ldr  r2,[r4,sgTcpRec_buf_tx_out]               ;\
 ldr  r3,[r4,sgTcpRec_buf_tx_in]                ; calc TX buf size
 subs r2,r3   ;TX buf size  --> flags and -->zf ; exit (or shutdown) if empty
 beq   @@txbuf_empty                            ;
 addlo r2,SGIP_TCP_TRANSMITBUFFERLENGTH         ;/
 ldr  r0,[r4,sgTcpRec_sequence_next]            ;\
 ldr  r3,[r4,sgTcpRec_sequence]                 ; calc num ALREADY sent byes
 sub  r0,r3  ;num sent bytes                    ;/
 cmp  r2,r0  ;txbufsiz,numsent  ;seqlen or so?  ;\send unsent bytes
 cmpls r1,SGIP_TCP_TRANSMIT_DELAY  ;time        ; (if any, and if time>DELAY)
 bhi   @@send_unsent_bytes                      ;/   DELAY: "1000 is an arbitrary constant." uh, what?
 ldr  r8,[r4,sgTcpRec_time_backoff]             ;\resend last packet
 cmp  r1,r8                        ;time        ; (if timeout)
 bhi  @@resend_last_packet                      ;/
 b    @@next_record                             ;-nothing to do
;---
@@resend_last_packet:   ;resend last packet  ;in: r8=backoff
 ;uh, apart from time-related stuff, this is same as "@@send_unsend_bytes",
 ;ie. both cases seem to send data starting at "buf_tx_in",
 ;and, another difference is that "@@send_unsend_bytes" is done ONLY if
 ;txbufsize is BIGGER than the sequencelen... whilst RESENDING is done
 ;regardless of sequencelen... uh, what/why is that good for?
 ;- - -
 ldr  r9,[r4,sgTcpRec_txwindow]                 ;\
 ldr  r3,[r4,sgTcpRec_sequence]                 ;
 sub  r9,r3   ;datalen or so                    ; crop datalen/txbufsiz
 cmp  r9,r2   ;txbufsiz                         ;
 movhi r9,r2                                    ;/
 ldr  r0,[r4,sgTcpRec_destip] ;\max tcp         ;\
 bl   sgIP_IP_MaxContentsSize ; data siz        ;
 sub  r0,20                   ;/                ; crop datalen/maxcontent-20
 cmp  r9,r0   ;maxcontent-20                    ;
 movhi r9,r0                                    ;/
;ldr  r8,[r4,sgTcpRec_time_backoff]             ;\
 mov  r8,r8,lsl 1  ;mul2                        ; raise backoff
 cmp  r8,SGIP_TCP_BACKOFFMAX                    ; (mul2, clip to max)
 movhi r8,SGIP_TCP_BACKOFFMAX                   ;/
 mov  r2,r9  ;datalength                        ;\
 mov  r1,SGIP_TCP_FLAG_ACK                      ; send
 mov  r0,r4  ;TcpRec                            ;
 bl   sgIP_TCP_SendPacket                       ;/
 str  r8,[r4,sgTcpRec_time_backoff]             ;-preserve backoff
 b    @@next_record
;---
@@send_unsent_bytes:   ;never-sent bytes
 ldr  r9,[r4,sgTcpRec_txwindow]                 ;\
 ldr  r3,[r4,sgTcpRec_sequence]                 ;
 sub  r9,r3   ;datalen or so                    ; crop datalen/txbufsiz
 cmp  r9,r2   ;txbufsiz                         ;
 movhi r9,r2                                    ;/
 ldr  r0,[r4,sgTcpRec_destip] ;\max tcp         ;\
 bl   sgIP_IP_MaxContentsSize ; data siz        ;
 sub  r0,20                   ;/                ; crop datalen/maxcontent-20
 cmp  r9,r0   ;maxcontent-20                    ;
 movhi r9,r0                                    ;/
 mov  r2,r9  ;datalength                        ;\
 mov  r1,SGIP_TCP_FLAG_ACK                      ; send
 mov  r0,r4  ;TcpRec                            ;
 bl   sgIP_TCP_SendPacket                       ;/
 b    @@next_record
;---
@@txbuf_empty:
 ldr  r0,[r4,sgTcpRec_want_shutdown]            ;\
 cmp  r0,1   ;check if want shutdown            ; check if want_shutdown = 1
 bne  @@next_record   ;nope, nothing to do      ;/
;- - - oblige & shutdown...
 mov  r0,r4  ;TcpRec                            ;\
 mov  r1,SGIP_TCP_FLAG_FIN+SGIP_TCP_FLAG_ACK    ; send FIN+ACK
 mov  r2,0   ;datalen                           ;
 bl   sgIP_TCP_SendPacket                       ;/
 ldr  r0,[r4,sgTcpRec_tcpstate]         ;\
 cmp  r0,SGIP_TCP_STATE_CLOSE_WAIT      ;
 moveq r0,SGIP_TCP_STATE_LAST_ACK       ; change tcp state
 movne r0,SGIP_TCP_STATE_FIN_WAIT_1     ;
 str  r0,[r4,sgTcpRec_tcpstate]         ;/
 mov  r0,2                              ;\want_shutdown = 2
 str  r0,[r4,sgTcpRec_want_shutdown]    ;/
 b    @@next_record
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_TCP.c - recv packet
;------------------
sgIP_TCP_ReceivePacket:  ;in: r0=MemBlk, r1=srcip, r2=destip, out: r0=zero
 push r4-r12,lr
 movs r4,r0  ;MemBlk
 beq  @@return_zero
 mov  r5,r1  ;srcip
 mov  r6,r2  ;destip
 ldr  r8,[r4,sgMemBlk_datastart]        ;-get TcpHdr
 ldr  r0,[r8,sgTcpHdr_acknum]           ;\
 bl   htonl                             ; tcpack
 mov  r10,r0  ;tcpack                   ;/
 ldr  r0,[r8,sgTcpHdr_seqnum]           ;\
 bl   htonl                             ; tcpseq
 mov  r11,r0  ;tcpseq                   ;/
;SGIP_DEBUG_MESSAGE(("TCP%08X-%08X,%04X-%04X",srcip,destip,tcp->srcport,tcp->destport));
;SGIP_DEBUG_MESSAGE(("-L%04X,C%04X,F%02X,h%X,A%08X",mb->totallength,tcp->checksum,tcp->tcpflags,tcp->dataofs_>>4,tcp->acknum));

        .if with_listen_log     ;die-after-2-minutes: NEVER gets here!
        mov r0,10h // bl wrchr_r0
        mov r0,'*' // bl wrchr_r0
        mov r0,11h // bl wrchr_r0
        .endif

 ldrh r0,[r8,sgTcpHdr_checksum] ;\      ;\
 cmp  r0,0                      ;       ;
 beq  @@no_checksum             ;/      ; ignore MemBlk if bad checksum
 mov  r0,r4  ;MemBlk                ;\  ;
 mov  r1,r5  ;srcip                 ;   ;
 mov  r2,r6  ;destip                ;   ;
 ldr  r3,[r4,sgMemBlk_totallength]  ;   ;
 bl   sgIP_TCP_CalcChecksum         ;   ;
 ldr  r3,=0FFFFh                    ;   ;
 cmp  r0,r3                         ;   ;
 bne  @@ignore_due_to_bad_checksum  ;/  ;
@@no_checksum:                          ;/
;- - - -
        .if with_listen_log
        mov r0,10h // bl wrchr_r0
        mov r0,'F' // bl wrchr_r0
        mov r0,11h // bl wrchr_r0
        .endif

 ldr  r1,=tcprecords                    ;\
 ldr  r9,[r1]  ;TcpRec                  ;
@@find_record_lop:                      ; find associated block
 cmp  r9,0     ;TcpRec          ;\end   ;
 beq  @@find_record_not_found   ;/      ;
 ldrh r0,[r9,sgTcpRec_srcport]  ;\      ;
 ldrh r1,[r8,sgTcpHdr_destport] ; port  ;
 cmp  r0,r1                     ; src   ;
 bne  @@find_record_next        ;/      ;
 ldr  r0,[r9,sgTcpRec_srcip]    ;\      ;
 cmp   r0,r6  ;srcip=destip     ; IP    ;
 cmpne r0,0   ;or srcip=0       ;       ;
 bne   @@find_record_next       ;/      ;

        .if with_listen_log
        mov r0,10h // bl wrchr_r0
        mov r0,'Q' // bl wrchr_r0
        mov r0,11h // bl wrchr_r0
        .endif


;XXXX bugfixed:
;       if((rec->tcpstate==SGIP_TCP_STATE_LISTEN && (tcp->tcpflags&SGIP_TCP_FLAG_SYN))
;         || rec->destport==tcp->srcport) break;


 ldrh r0,[r9,sgTcpRec_destport] ;\      ;
 ldrh r1,[r8,sgTcpHdr_srcport]  ; port  ;
 cmp  r0,r1                     ; dest  ;
 beq  @@found_record  ;------>  ;/      ;
 ldr  r0,[r9,sgTcpRec_tcpstate] ;\      ;
 cmp  r0,SGIP_TCP_STATE_LISTEN  ; or,   ;
 bne  @@find_record_next        ; LISTEN;
 ldrb r0,[r8,sgTcpHdr_tcpflags] ; with  ;
 tst  r0,SGIP_TCP_FLAG_SYN      ; SYN   ;
 bne  @@found_record  ;------>  ;/      ;
@@find_record_next:                     ;
 ldr  r9,[r9,sgTcpRec_next]     ;\      ;
 b    @@find_record_lop         ;/      ;/
;---
@@find_record_not_found:  ;could be completion of an incoming connection?

        .if with_listen_log
        mov r0,11h // bl wrchr_r0
        mov r0,'<' // bl wrchr_r0
        mov r0,'<' // bl wrchr_r0
        mov r0,12h // bl wrchr_r0
         ldrb r0,[r8,sgTcpHdr_tcpflags]     ;=04h (RST) damn!
         bl wrhex32bit
        mov r0,11h // bl wrchr_r0
        mov r0,'>' // bl wrchr_r0
        mov r0,'>' // bl wrchr_r0
        .endif

 ldrb r0,[r8,sgTcpHdr_tcpflags] ;\
 tst  r0,SGIP_TCP_FLAG_ACK      ; want ACK flag
 beq  @@ignore_unresolved_block ;/

        .if with_listen_log
        mov r0,11h // bl wrchr_r0
        mov r0,'*' // bl wrchr_r0
        mov r0,12h // bl wrchr_r0
        mov r0,'G' // bl wrchr_r0
        mov r0,'O' // bl wrchr_r0
        mov r0,'T' // bl wrchr_r0
        mov r0,13h // bl wrchr_r0
        mov r0,'A' // bl wrchr_r0
        mov r0,'C' // bl wrchr_r0
        mov r0,'K' // bl wrchr_r0
        mov r0,11h // bl wrchr_r0
        mov r0,'*' // bl wrchr_r0
        .endif

 ldr  r2,=numsynlist            ;\
 ldr  r2,[r2]                   ; search SYN list...
 ldr  r1,=synlist               ;
@@syn_lop:                      ;
 subs r2,1                      ;  ;\end
 blo  @@ignore_unresolved_block ;  ;/
 ldr  r0,[r1,sgTcpSyn_localseq] ;  ;\
 add  r0,1                      ;  ; want seq+1=ack
 cmp  r0,r10 ;tcpack            ;  ; oki! this is probably legit ;)
 beq  @@syn_found ;--> in: r1,r2;  ;/
 add  r1,sgTcpSyn_size          ;  ;\lop next SYN
 b    @@syn_lop                 ;/ ;/
;- - - -
@@found_record:
        .if with_listen_log
        mov r0,'-' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
        mov r0,'F' // bl wrchr_r0
        mov r0,'O' // bl wrchr_r0
        mov r0,'U' // bl wrchr_r0
        mov r0,'N' // bl wrchr_r0
        mov r0,'D' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
        .endif

 ldrb r0,[r8,sgTcpHdr_tcpflags]         ;\
 tst  r0,SGIP_TCP_FLAG_RST              ; check if RST
 bne  @@got_rst                         ;/
 mov  r12,0  ;shouldReply=0             ;-initially no reply wanted
 ldr  r7,[r4,sgMemBlk_totallength]      ;\
 ldrb r0,[r8,sgTcpHdr_dataofs_]         ; get datalen
 mov  r0,r0,lsr 4 ;num words (bit4-7)   ; (totallen-hdrsiz)
 sub  r7,r7,r0,lsl 2 ;totallen-hdrsiz*4 ;/
 ldrb r0,[r8,sgTcpHdr_tcpflags]              ;\
 and  r0,SGIP_TCP_FLAG_ACK+SGIP_TCP_FLAG_SYN ; check if ACK (but without SYN)
 cmp  r0,SGIP_TCP_FLAG_ACK  ;ACK without SYN ; (doesn't work very well with SYN)
 bne  @@skip_ack_check                       ;/
 ldr  r1,[r9,sgTcpRec_sequence]              ;\
 ldr  r2,[r9,sgTcpRec_txwindow]              ; check ack sequence
 subs  r0,r10,r1 ;tcpack-seq             ;r0 ; vs transmit window,
 movgt r12,1  ;shouldReply=1 if r0>0         ; check if shouldReply,
 cmppl r2,r10    ;txwin-tcpack               ; discard packet if invalid range
 bmi   @@free_memblock_return_zero           ;/
 ldr  r1,[r9,sgTcpRec_buf_tx_in]             ;\
 add  r1,r0  ;ptr + (tcpack-seq)         ;r0 ;
 cmp  r1,SGIP_TCP_TRANSMITBUFFERLENGTH       ; raise buf_tx_in
 subhs r1,SGIP_TCP_TRANSMITBUFFERLENGTH      ;
 str  r1,[r9,sgTcpRec_buf_tx_in]             ;/
 str  r10,[r9,sgTcpRec_sequence]             ;-[seq]=tcpack
@@skip_ack_check:
 ldrh r0,[r8,sgTcpHdr_window]           ;\
 bl   htons          ;window            ;
 ldr  r1,[r9,sgTcpRec_sequence]         ; raise txwindow
 add  r1,r0 ;sequence+window            ;
 str  r1,[r9,sgTcpRec_txwindow]         ;/
;- - - -
;now, decide what to do with our nice new shiny memblock...
;for most states, receive data
 ldr  r3,[r9,sgTcpRec_tcpstate]
 cmp   r3,SGIP_TCP_STATE_SYN_RECEIVED     ;\ spawned from listen socket; or from syn sent.
 cmpne r3,SGIP_TCP_STATE_ESTABLISHED      ;  syns have been exchanged
 cmpne r3,SGIP_TCP_STATE_FIN_WAIT_1       ;  sent a FIN, haven't got FIN or ACK yet.
 cmpne r3,SGIP_TCP_STATE_FIN_WAIT_2       ;  got ACK for our FIN, haven't got FIN yet.
 beq   @@process_record      ;----->      ;/
;cmp  r3,SGIP_TCP_STATE_NODATA     // nop ;\
;cmp  r3,SGIP_TCP_STATE_UNUSED     // nop ;
;cmp  r3,SGIP_TCP_STATE_CLOSED     // nop ;
;cmp  r3,SGIP_TCP_STATE_LISTEN     // nop ; no action for there here
;cmp  r3,SGIP_TCP_STATE_TIME_WAIT  // nop ;
;cmp  r3,SGIP_TCP_STATE_SYN_SENT   // nop ;
;cmp  r3,SGIP_TCP_STATE_CLOSE_WAIT // nop ;
;cmp  r3,SGIP_TCP_STATE_CLOSING    // nop ;
;cmp  r3,SGIP_TCP_STATE_LAST_ACK   // nop ;/
@@process_done:              ;<-----      ;-come back here after processing
;- - - -
;decide what to do with the others...
;uh, "others"? rather: "decide how to respond"...
 bl   @@subfunc_get_deltas  ;out: r1,r2
 ldr  r3,[r9,sgTcpRec_tcpstate]
 ldrb r0,[r8,sgTcpHdr_tcpflags]
 cmp  r3,SGIP_TCP_STATE_LISTEN       // beq @@handle_listen
 cmp  r3,SGIP_TCP_STATE_SYN_SENT     // beq @@handle_syn_sent
 cmp  r3,SGIP_TCP_STATE_SYN_RECEIVED // beq @@handle_syn_received
 cmp  r3,SGIP_TCP_STATE_ESTABLISHED  // beq @@handle_established
 cmp  r3,SGIP_TCP_STATE_FIN_WAIT_1   // beq @@handle_fin_wait_1
 cmp  r3,SGIP_TCP_STATE_FIN_WAIT_2   // beq @@handle_fin_wait_2
 cmp  r3,SGIP_TCP_STATE_CLOSE_WAIT   // beq @@handle_close_wait
 cmp  r3,SGIP_TCP_STATE_CLOSING      // beq @@handle_closing
 cmp  r3,SGIP_TCP_STATE_LAST_ACK     // beq @@handle_last_ack
 cmp  r3,SGIP_TCP_STATE_TIME_WAIT    // beq @@handle_time_wait
;cmp  r3,SGIP_TCP_STATE_NODATA // nop  ;newly allocated     ;\can't do anything
;cmp  r3,SGIP_TCP_STATE_UNUSED // nop  ;allocated & BINDed  ; in these states.
;cmp  r3,SGIP_TCP_STATE_CLOSED // nop  ;Block is unused     ;/
@@handle_done:
;- - - -
@@free_memblock_return_zero:
 mov  r0,r4  ;MemBlk            ;\free memblock
 bl   sgIP_memblock_free        ;/
@@return_zero:
 mov  r0,0      ;out: r0=zero (always)
 pop  r4-r12,pc
;--- --- --- ------
@@handle_listen:  ;SGIP_TCP_STATE_LISTEN: listening
 tst  r0,SGIP_TCP_FLAG_SYN              ;\want SYN, exit otherwise
 beq  @@handle_done   ;nope             ;/
;okay, SYN flag was set, other end requesting a connection...

        .if with_listen_log
        mov r0,10h // bl wrchr_r0
        mov r0,'*' // bl wrchr_r0
        mov r0,12h // bl wrchr_r0
        mov r0,'G' // bl wrchr_r0
        mov r0,'O' // bl wrchr_r0
        mov r0,'T' // bl wrchr_r0
        mov r0,13h // bl wrchr_r0
        mov r0,'S' // bl wrchr_r0
        mov r0,'Y' // bl wrchr_r0
        mov r0,'N' // bl wrchr_r0
        mov r0,10h // bl wrchr_r0
        mov r0,'*' // bl wrchr_r0
               ;b $
        .endif

 ldr  r1,=numsynlist            ;\check         ;\
 ldr  r0,[r1]                   ; if full       ;
 cmp  r0,SGIP_TCP_MAXSYNS       ;/              ; if synlist is FULL then
 subeq r0,1  ;num-1             ;\decrease num  ; remove OLDEST synlist entry
 streq r0,[r1]                  ;/              ;
 ldreq r1,=synlist         ;dst=list[0]     ;\  ;
 addeq r0,r1,sgTcpSyn_size ;src=list[1]     ;   ;
 moveq r2,sgTcpSyn_size*(SGIP_TCP_MAXSYNS-1);   ;
 bleq  memcopy_bytewise                     ;/  ;/

        .if 0 ;XNAY
        mov r0,r5
        bl wrhex32bit
        .endif

 mov  r0,r5                     ;srcip          ;\
 mov  r1,r6                     ;destip         ;
 ldrh r2,[r8,sgTcpHdr_srcport]  ;srcport        ; calc seqhash (random)
 ldrh r3,[r8,sgTcpHdr_destport] ;destport       ;
 bl   sgIP_TCP_support_seqhash                  ;
;mov  r0,r0  ;seqhash                           ;/
 push r0,r4-r7  ;--> (r0=seqhash)               ;\
 mov  r1,r0                     ;seqhash        ;
 add  r2,r11,1                  ;tcpseq+1       ; send relevant synack
 mov  r3,r6                     ;destip         ;
 mov  r4,r5                     ;srcip          ;
 ldrh r5,[r8,sgTcpHdr_destport] ;destport       ;
 ldrh r6,[r8,sgTcpHdr_srcport]  ;srcport        ;
 mov  r7,0ffffffffh ;windowlen=biggest possible ;
 mov  r0,SGIP_TCP_FLAG_SYN+SGIP_TCP_FLAG_ACK    ;
 bl   sgIP_TCP_SendSynReply                     ;

        .if with_listen_log
        mov r0,10h // bl wrchr_r0
        mov r0,'*' // bl wrchr_r0
        mov r0,12h // bl wrchr_r0
        mov r0,'S' // bl wrchr_r0
        mov r0,'Y' // bl wrchr_r0
        mov r0,'N' // bl wrchr_r0
        mov r0,13h // bl wrchr_r0
        mov r0,'A' // bl wrchr_r0
        mov r0,'C' // bl wrchr_r0
        mov r0,'K' // bl wrchr_r0
        mov r0,10h // bl wrchr_r0
        mov r0,'*' // bl wrchr_r0
        .endif

 pop  r0,r4-r7  ;<-- (r0=seqhash)               ;/
 ldr  r1,=synlist                 ;\            ;\
 ldr  r2,=numsynlist              ;             ;
 ldr  r2,[r2]  ;num               ; get synlist ;
 mov  r3,sgTcpSyn_size            ; dest ptr    ;
 mul  r2,r2,r3 ;num*size          ;             ; create NEW synlist entry
 add  r1,r2 ;=synlist[numsynlist] ;/            ;
;mov  r0,r0 ;seqhash                ;\seqhash   ;
 str  r0,[r1,sgTcpSyn_localseq]     ;/          ;
 mov  r0,SGIP_TCP_SYNRETRYMS        ;\backoff   ;
 str  r0,[r1,sgTcpSyn_timebackoff]  ;/          ;
 mov  r0,SGIP_TCP_SYNRETRYMS        ;\timenext  ;
 str  r0,[r1,sgTcpSyn_timenext]     ;/          ;
 mov  r0,r9  ;TcpRec                ;\record    ;
 str  r0,[r1,sgTcpSyn_linked]       ;/          ;
 add  r0,r11,1                      ;\tcpseq+1  ;
 str  r0,[r1,sgTcpSyn_remoteseq]    ;/          ;
 str  r5,[r1,sgTcpSyn_remoteip]     ;-srcip     ;
 ldrh r0,[r8,sgTcpHdr_srcport]      ;\srcport   ;
 strh r0,[r1,sgTcpSyn_remoteport]   ;/          ;
 str  r6,[r1,sgTcpSyn_localip]      ;-destip    ;
 ldrh r0,[r8,sgTcpHdr_destport]     ;\destport  ;
 strh r0,[r1,sgTcpSyn_localport]    ;/          ;
 ldr  r2,=numsynlist              ;\            ;
 ldr  r0,[r2]  ;num               ; raise num   ;
 add  r0,1                        ; synlist     ;
 str  r0,[r2]  ;num               ;/            ;/
 b    @@handle_done
;--- --- ---
@@handle_syn_received:  ;SGIP_TCP_STATE_SYN_RECEIVED: spawned from listen socket; or from syn sent.
 tst  r0,SGIP_TCP_FLAG_ACK              ;\want ACK
 movne r0,SGIP_TCP_STATE_ESTABLISHED    ;  ;\mark established
 strne r0,[r9,sgTcpRec_tcpstate]        ;  ;/
 movne r0,0                             ;  ;\reset retry count
 strne r0,[r9,sgTcpRec_retrycount]      ;/ ;/
 b    @@handle_done
;--- --- ---
@@handle_fin_wait_2:  ;SGIP_TCP_STATE_FIN_WAIT_2: got ACK for our FIN, haven't got FIN yet.
 tst  r0,SGIP_TCP_FLAG_FIN              ;\want FIN
 movne r0,SGIP_TCP_STATE_TIME_WAIT      ;
 bne   @@handle_do_delta1               ;/
 b    @@handle_done
;--- --- ---
@@handle_established:  ;SGIP_TCP_STATE_ESTABLISHED: syns have been exchanged
 tst  r0,SGIP_TCP_FLAG_FIN              ;\want FIN
 movne r0,SGIP_TCP_STATE_CLOSE_WAIT     ; ...this is the end...
 bne   @@handle_do_delta1               ;/
 b    @@handle_done
;--- --- ---
@@handle_close_wait:  ;SGIP_TCP_STATE_CLOSE_WAIT: got FIN, wait for user code to close socket & send FIN
 tst  r0,SGIP_TCP_FLAG_FIN              ;\want FIN
 bne  @@handle_do_delta1_stay_state     ;/
 b    @@handle_done
;--- --- ---
@@handle_time_wait:  ;SGIP_TCP_STATE_TIME_WAIT: wait to ensure remote tcp knows it's been terminated.
 tst  r0,SGIP_TCP_FLAG_FIN              ;\want FIN --> send 'em a grat ACK
 bne  @@handle_both_delta_stay_state    ;/
 b    @@handle_done
;--- --- ---
@@handle_fin_wait_1:  ;SGIP_TCP_STATE_FIN_WAIT_1: sent a FIN, haven't got FIN or ACK yet.
 and  r0,SGIP_TCP_FLAG_FIN+SGIP_TCP_FLAG_ACK
 cmp  r0,SGIP_TCP_FLAG_FIN                      ;\
 moveq r0,SGIP_TCP_STATE_CLOSING                ; FIN --> delta and CLOSING
 beq   @@handle_do_delta1                       ;/
 cmp  r0,SGIP_TCP_FLAG_FIN+SGIP_TCP_FLAG_ACK    ;\  ;already checked ack, check sequence though
 moveq r0,SGIP_TCP_STATE_TIME_WAIT              ; FIN+ACK --> delta & TIME_WAIT
 beq   @@handle_do_delta1                       ;/
 cmp  r0,SGIP_TCP_FLAG_ACK                      ;\  ;already checked ack against appropriate window
 moveq r0,SGIP_TCP_STATE_FIN_WAIT_2             ; ACK --> mark WAIT_2
 streq r0,[r9,sgTcpRec_tcpstate]                ;/
 b    @@handle_done
;--- --- ---
@@handle_closing:  ;SGIP_TCP_STATE_CLOSING: got FIN, waiting for ACK of our FIN
 and  r0,SGIP_TCP_FLAG_FIN+SGIP_TCP_FLAG_ACK
 cmp  r0,SGIP_TCP_FLAG_FIN                      ;\FIN --> resend their ack
 beq  @@handle_both_delta_stay_state            ;/
 cmp  r0,SGIP_TCP_FLAG_FIN+SGIP_TCP_FLAG_ACK    ;\ ;already checked ack, check sequence though
 moveq r0,SGIP_TCP_STATE_TIME_WAIT              ; FIN+ACK -->
 beq   @@handle_both_delta_new_state            ;/
 cmp  r0,SGIP_TCP_FLAG_ACK                      ;\  ;already checked ack against appropriate window
 moveq r0,SGIP_TCP_STATE_TIME_WAIT              ; ACK --> mark TIME_WAIT
 streq r0,[r9,sgTcpRec_tcpstate]                ;/
 b    @@handle_done
;--- --- ---
@@handle_last_ack:  ;SGIP_TCP_STATE_LAST_ACK: wait for ACK of our last FIN
 and  r0,SGIP_TCP_FLAG_FIN+SGIP_TCP_FLAG_ACK
 cmp  r0,SGIP_TCP_FLAG_FIN                      ;\FIN -->  resend their ack
 beq  @@handle_both_delta_stay_state            ;/
 cmp  r0,SGIP_TCP_FLAG_FIN+SGIP_TCP_FLAG_ACK    ;\ ;already checked ack, check sequence though
 moveq r0,SGIP_TCP_STATE_CLOSED                 ; FIN+ACK -->
 beq   @@handle_both_delta_new_state            ;/
 cmp  r0,SGIP_TCP_FLAG_ACK                      ;\ ;already checked ack against appropriate window
 moveq r0,SGIP_TCP_STATE_CLOSED                 ; ACK --> mark CLOSED
 streq r0,[r9,sgTcpRec_tcpstate]                ;/
 b    @@handle_done
;--- --- ---
@@handle_syn_sent:  ;SGIP_TCP_STATE_SYN_SENT: connect initiated
 and  r0,SGIP_TCP_FLAG_SYN+SGIP_TCP_FLAG_ACK  ;<-- SYN here (not FIN)
 cmp  r0,SGIP_TCP_FLAG_SYN+SGIP_TCP_FLAG_ACK    ;\both flags set
 moveq r0,SGIP_TCP_STATE_ESTABLISHED            ; FIXME: shall check ack againts our seq instead.
 beq   @@handle_syn_sent_this                   ;/  ;uh, FIX what/important? (and, uh, "againts" looks misspelled)
 cmp  r0,SGIP_TCP_FLAG_SYN                      ;\
 moveq r0,SGIP_TCP_STATE_SYN_RECEIVED           ; just got a syn...
 beq   @@handle_syn_sent_this                   ;/
 b    @@handle_done                             ;-other --> ignore
;---
@@handle_syn_sent_this:  ;in: r0=new state
 mov  r0,0                              ;\[retrycount]=0
 str  r0,[r9,sgTcpRec_retrycount]       ;/
 add  r0,r11,1   ;tcpseq+1              ;\[ack]=tcpseq+1
 str  r0,[r9,sgTcpRec_ack]              ;/
 str  r10,[r9,sgTcpRec_sequence]        ;-[seq]=tcpack
;- - -
@@handle_done_send_ack_set_state_r0:
 str  r0,[r9,sgTcpRec_tcpstate]         ;-apply new state
;- - -
@@handle_done_send_ack:
 mov  r0,r9  ;TcpRec                    ;\
 mov  r1,SGIP_TCP_FLAG_ACK              ; send ACK
 mov  r2,0   ;len                       ;
 bl   sgIP_TCP_SendPacket               ;/
 b    @@handle_done
;--- --- ---
@@handle_do_delta1_stay_state:
 cmp  r1,0  ;delta1                     ;\want delta1=0
 bne  @@handle_done                     ;/
 b    @@handle_done_send_ack  ;they still don't seem to have got our ack, we'll send it again.
;--- --- ---
@@handle_do_delta1:  ;in: r0=new state (when delta1 okay)
 cmp  r1,0  ;delta1                     ;\want delta1=0
 bne  @@handle_done                     ;/
 add  r3,r11,r7       ;tcpseq+datalen   ;\
 add  r3,1            ;tcpseq+datalen+1 ;
 str  r3,[r9,sgTcpRec_ack]              ;/
 b    @@handle_done_send_ack_set_state_r0
;--- --- ---
@@handle_both_delta_stay_state:
 ldr   r0,[r9,sgTcpRec_tcpstate]         ;-keep OLD state
;- - -
@@handle_both_delta_new_state:
 cmp   r1,1   ;delta1           ;\reject if delta1<1 (one), or
 cmppl r2,0   ;delta2           ; reject if delta1<0 (zero)
 bmi   @@handle_done            ;/
 b     @@handle_done_send_ack_set_state_r0
;--- --- --- ------
@@got_rst:    ;verify if RST is legit, and act on it...
 bl    @@subfunc_get_deltas  ;out: r1,r2
 cmp   r1,0   ;delta1                   ;\reject if delta1<0 (zero), or
 cmppl r2,0   ;delta2                   ; reject if delta1<0 (zero)
 bmi   @@free_memblock_return_zero      ;/
 ldr   r0,[r9,sgTcpRec_tcpstate]        ;\
 cmp   r0,SGIP_TCP_STATE_LISTEN         ; reject if state=LISTEN
 beq   @@free_memblock_return_zero      ;/
 mov   r0,ECONNRESET                ;\  ;\
 str   r0,[r9,sgTcpRec_errorcode]   ;/  ; okay, reset connection
 mov   r0,SGIP_TCP_STATE_CLOSED     ;\  ;
 str   r0,[r9,sgTcpRec_tcpstate]    ;/  ;/
 b     @@free_memblock_return_zero      ;-done
;--- --- --- ------
@@process_record:
        .if 0       ;XNAY
        mov r0,'-' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
        mov r0,'G' // bl wrchr_r0
        mov r0,'O' // bl wrchr_r0
        mov r0,'T' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
        .endif
 ldrb r0,[r8,sgTcpHdr_tcpflags]         ;\
 tst  r0,SGIP_TCP_FLAG_ACK              ; want ACK, exit otherwise
 beq  @@process_done  ;nope             ;/
        .if 0       ;XNAY
        mov r0,'-' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
        mov r0,'G' // bl wrchr_r0
        mov r0,'O' // bl wrchr_r0
        mov r0,'T' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
        mov r0,'-' // bl wrchr_r0
        .endif

 bl   @@subfunc_get_deltas  ;out: r1,r2 ;-get deltas
 ldr   r3,[r9,sgTcpRec_ack]             ;\
 adds  r0,r1,r7       ;delta1+datalen   ; ;-check end of data vs start of window
 cmppl r2,r7          ;delta2-datalen   ; ;-check end of data vs end of window
 cmppl r3,r11         ;rec[ack]-tcpseq  ; ;-check start of data vs start of window
 bmi   @@process_record_bad  ;in: r0    ;/
 ldrb r2,[r8,sgTcpHdr_dataofs_]         ;\
 mov  r2,r2,lsr 4 ;num words (bit4-7)   ; get datastart (aka header size)
 mov  r2,r2,lsl 2 ;num bytes (mul4)     ;/
 cmp  r1,0   ;delta1                                 ;\data is partly ack'd...
 submi r2,r1 ;raise datastart (sub NEGATIVE delta1)  ; just copy what we need
 addmi r7,r1 ;decrease datalen (add NEGATIVE delta1) ;/
;- - - copy data into the fifo...
 ldr   r0,[r9,sgTcpRec_ack]                     ;\
 add   r0,r7 ;ack+datalen                       ;
 str   r0,[r9,sgTcpRec_ack]                     ;/
 cmp  r7,0  ;datalen                            ;\
 bmi  @@process_record_len_negative             ; check len
 mov  r12,1 ;force shouldReply=1 when len>=0    ;/
 ldr  r1,[r9,sgTcpRec_buf_rx_out]  ;dst         ;\
@@process_record_copy_lop:                      ;
 cmp  r7,0  ;datalen             ;\             ; copy data into the fifo...
 beq  @@process_record_copy_done ;/             ;

       ; mov r0,'C' // bl wrchr_r0   ;XNAY XXXXXXXXXXXXXXXXXX

 rsb  r3,r1,SGIP_TCP_RECEIVEBUFFERLENGTH;\      ;  ;"don't actually need to
 cmp  r3,r7  ;disp_to_buf_end, datalen  ; frag  ;  ;check the rx buffer length,
 movhi r3,r7 ;fragment.len              ;/      ;  ;if the ack check approved
 push r1-r3  ;-->                       ;\      ;  ;it, it will be in range
 mov  r0,r4  ;MemBlk               ;src ;       ;  ;(not overflow) by default"
 add  r1,r9  ;index+TcpRec ;\dest+ ;dst ;       ;
 add  r1,sgTcpRec_buf_rx   ;/base  ;dst ; copy  ;
;mov  r2,r2 ;skiplen aka datastart ;skip;       ;
;mov  r3,r3 ;copylen ;fragment.len ;len ;       ;
 bl   sgIP_memblock_CopyToLinear        ;       ;
 pop  r1-r3  ;<--                       ;/      ;
 sub  r7,r3         ;decrease datalen   ;\      ;
 add  r2,r3         ;raise src.skiplen  ;       ;
 add  r1,r3         ;raise destindex    ; next  ;
 cmp  r1,SGIP_TCP_RECEIVEBUFFERLENGTH   ;       ;
 subhs r1,SGIP_TCP_RECEIVEBUFFERLENGTH  ;/      ;
 b     @@process_record_copy_lop                ;
@@process_record_copy_done:                     ;
 str  r1,[r9,sgTcpRec_buf_rx_out]  ;dst         ;/
@@process_record_len_negative:
 ldr   r0,[r9,sgTcpRec_tcpstate]    ;\
 cmp   r0,SGIP_TCP_STATE_FIN_WAIT_1 ; no reply for FIN_WAIT's, ie. reply
 cmpne r0,SGIP_TCP_STATE_FIN_WAIT_2 ; only for SYN_RECEIVED and ESTABLISHED
 cmpne r12,0  ;shouldReply          ; and, never reply if shouldReply=0
 beq   @@process_done               ;/
 ldr  r0,[r9,sgTcpRec_destip]           ;\max tcp   ;\
 bl   sgIP_IP_MaxContentsSize           ; data siz  ;
 sub  r2,r0,20   ;maxcontent-20         ;/          ;
 ldr  r0,[r9,sgTcpRec_buf_tx_out]       ;\          ; send a packet in reply,
 ldr  r1,[r9,sgTcpRec_buf_tx_in]        ; buf siz   ; ha!
 subs r0,r1   ;tx buf size              ;           ;
 addlo r0,SGIP_TCP_TRANSMITBUFFERLENGTH ;/          ;
 cmp  r2,r0   ;maxcontent-20            ;\crop      ;
 movhi r2,r0                            ;/          ;
 ldr  r0,[r9,sgTcpRec_txwindow]         ;\          ;
 ldr  r1,[r9,sgTcpRec_sequence]         ; window    ;
 subs r0,r1   ;tx buf size              ;           ;
 bmi  @@process_done  ;--> reject  -->  ;/  ------> ; --> could be less than 0,
 cmp  r2,r0   ;maxcontent-20            ;\crop      ;     but very odd
 movhi r2,r0                            ;/          ;
 mov  r0,r9  ;TcpRec                    ;\          ;
 mov  r1,SGIP_TCP_FLAG_ACK              ; send      ;
;mov  r2,r2  ;len                       ; ack       ;
 bl   sgIP_TCP_SendPacket               ;/          ;/
 b    @@process_done
;---
@@process_record_bad:  ;in: r0=delta1+datalen
 adds r0,SGIP_TCP_RECEIVEBUFFERLENGTH   ;-check if "near recent" window
 movpl r0,r9  ;TcpRec                   ;\
 movpl r1,SGIP_TCP_FLAG_ACK             ; if so, ack it anyway, they got
 movpl r2,0   ;len                      ; lost on the retard bus
 blpl  sgIP_TCP_SendPacket              ;/
 b    @@process_done
;--- --- --- ------
@@syn_found:  ;in: r1=synlist[N], r2=num further/used synlist entries (r2=0 when r1 is the LAST used entry)
 ;this is getting a "PARENT" record from the synlist, and is then adding
 ;a new "CHILD" record to the listendata of that "PARENT" record.
 ;- - -
 ;uh, BUGGED, original code contains a very weird "i*=3;". that is, when
 ;finding a matching entry at synlist[i], it will remove entry synlist[i*3]
 ;(instead of removing synlist[i]).
 ;  if "i" is the first or last entry (i=0 or i=numsynlist-1), then it will
 ;actually remove the CURRENT synlist entry. otherwise it will somewhat RANDOMLY
 ;remove ANOTHER entry at synlist[i*3] (in case of "i>=numsynlist" it'll
 ;remove the LAST synlist entry, without relocating any other old entries).
 ;  doing that MIGHT make sense if the synlist[i] would have an child entry
 ;at synlist[i*3] (and with new childs moved-in after removing that entry).
 ;  but, the synlist doesn't seem to be organized in that fashion, so the
 ;the "i*3" seems to be just a VERY WEIRD bug.
 ;  not quite clear how anybody could do that "i*3" multiplation unintentionally
 ;by mistake... maybe it's dating back to older code where synlist entries did
 ;have a size of "3 words" (and were relocated word-by-word when removing an
 ;entry).
 ;- - -

        .if 0       ;XNAY
        mov r0,13h // bl wrchr_r0
        mov r0,'S' // bl wrchr_r0
        mov r0,'S' // bl wrchr_r0
        mov r0,'S' // bl wrchr_r0
        mov r0,'S' // bl wrchr_r0
        mov r0,12h // bl wrchr_r0
        .endif

 ldr  r9,[r1,sgTcpSyn_linked]   ;-we have the data we need (get PARENT TcpRec)
 add  r0,r1,sgTcpSyn_size                  ;src ;\
;mov  r1,r1                                ;dst ;
 mov  r3,sgTcpSyn_size                          ; remove entry from synlist
 mul  r2,r2,r3    ;num further entries*siz ;len ;
 bl   memcopy_bytewise  ;reloc further entries  ;
 ldr  r1,=numsynlist            ;\              ;
 ldr  r0,[r1]                   ; decrease      ;
 sub  r0,1                      ; num entries   ;
 str  r0,[r1]                   ;/              ;/
 ldr  r1,[r9,sgTcpRec_listendata]       ;\
 ldr  r2,[r9,sgTcpRec_maxlisten]        ;
@@find_free_listen_entry:               ; find last entry in listen queue
 subs r2,1                              ;   ;uh, "find last"? rather "find free"
 blo  @@ignore_unresolved_block   ;<--  ; <-- discard this connection! we have
 ldr  r0,[r1],4  ;listendata[N]         ;       no space in the listen queue
 cmp  r0,0       ;0=free                ;
 bne  @@find_free_listen_entry          ;/
 cmp  r2,0       ;check if last entry   ;\terminate the listendata list by zero
 movne r2,0                             ; unless the new entry is last
 strne r2,[r1]   ;listendata[N]=0       ;/(the last entry has no terminator)
 sub  r9,r1,4 ;stepback to free entry, listendata[N]
 bl   sgIP_TCP_AllocRecord              ;-allocate a child record
 str  r0,[r9]    ;listendata[N]=CHILD   ;-add child to parent's listendata[N]
 mov  r9,r0      ;TcpRec (CHILD)

        .if 0       ;XNAY
        mov r0,12h // bl wrchr_r0
        mov r0,'!' // bl wrchr_r0
        mov r0,13h // bl wrchr_r0
        mov r0,'!' // bl wrchr_r0
        mov r0,11h // bl wrchr_r0
        mov r0,'!' // bl wrchr_r0
        .endif

;- - - fill in data about the connection into CHILD TcpRec...
 mov  r0,SGIP_TCP_STATE_ESTABLISHED     ;\state
 str  r0,[r9,sgTcpRec_tcpstate]         ;/
 ldr  r0,=sgIP_timems                   ;\
 ldr  r0,[r0]                           ; last action
 str  r0,[r9,sgTcpRec_time_last_action] ;/
 mov  r0,SGIP_TCP_GENRETRYMS            ;\backoff timer
 str  r0,[r9,sgTcpRec_time_backoff]     ;/
 str  r6,[r9,sgTcpRec_srcip]            ;-[srcip]=destip
 str  r5,[r9,sgTcpRec_destip]           ;-[destip]=srcip
 ldrh r0,[r8,sgTcpHdr_destport]         ;\[srcport]=Hdr[destport]
 strh r0,[r9,sgTcpRec_srcport]          ;/
 ldrh r0,[r8,sgTcpHdr_srcport]          ;\[destport]=Hdr[srcport]
 strh r0,[r9,sgTcpRec_destport]         ;/
 str  r10,[r9,sgTcpRec_sequence]        ;-[seq] = tcpack
 str  r11,[r9,sgTcpRec_ack]             ;-[ack] = tcpseq
 str  r10,[r9,sgTcpRec_sequence_next]   ;-[seq_next] = tcpack
 ldrh r0,[r8,sgTcpHdr_window]           ;\
 bl   htons                             ; [txwindow] = tcpack + Hdr[window]
 add  r0,r10  ;add tcpack               ;
 str  r0,[r9,sgTcpRec_txwindow]         ;/
 ldr  r1,=1400                          ;\
 add  r0,r11,r1                         ; [rxwindow] = tcpseq+1400
 str  r0,[r9,sgTcpRec_rxwindow]         ;/  ;<-- "last byte in receive window"
 b    @@free_memblock_return_zero       ;-done
;--- --- --- ------
@@ignore_unresolved_block:
 ;we don't have a clue what this one is...
 ;(it was neither in "tcprecords", nor in "synlist")
 .ifndef SGIP_TCP_STEALTH       ;send a RST (unless "stealth")...
   push r4-r7  ;-->                                     ;\
   mov  r0,SGIP_TCP_FLAG_RST       ;flags               ;
   mov  r1,r10                     ;seq = tcpack        ; send a RST
   mov  r2,0                       ;ack = 0             ;
   mov  r3,r6                      ;srcip = destip      ;
   mov  r4,r5                      ;destip = srcip      ;
   ldrh r5,[r8,sgTcpHdr_destport]  ;srcport = destport  ;
   ldrh r6,[r8,sgTcpHdr_srcport]   ;destport = srcport  ;
   mov  r7,0                       ;windowlen = 0       ;
   bl   sgIP_TCP_SendSynReply                           ;
   pop  r4-r7  ;<--                                     ;/
 .endif
 b    @@free_memblock_return_zero       ;-done
;--- --- --- ------
@@ignore_due_to_bad_checksum:
;SGIP_DEBUG_MESSAGE(("TCP receive checksum incorrect"));
 b    @@free_memblock_return_zero       ;-done
;--- --- --- ------
@@subfunc_get_deltas:   ;out: r1=delta1, r2=delta2, other=SAME
 ldr  r1,[r9,sgTcpRec_ack]
 ldr  r2,[r9,sgTcpRec_rxwindow]
 sub  r1,r11,r1   ;delta1 = tcpseq-Rec[ack]
 sub  r2,r2,r11   ;delta2 = Rec[rxwindow]-tcpseq
 bx   lr
;------------------
.endif ;with_tcp
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\sgIP_UDP.c
;------------------
.data?
udprecords      dd 0  ;UdpRec   ;sgIP_Record_UDP * udprecords;
udpport_counter dd 0  ;int      ;udpport_counter;
.code
;------------------
sgIP_UDP_Init:  ;in/out: none
 mov  r0,0                              ;\
 ldr  r1,=udprecords                    ; udprecords=0
 str  r0,[r1]                           ;/
 mov  r0,SGIP_UDP_FIRSTOUTGOINGPORT     ;\
 ldr  r1,=udpport_counter               ; udpport_counter=SGIP_UDP_FIRSTOUTGOINGPORT
 str  r0,[r1]                           ;/
 bx   lr
;------------------
sgIP_UDP_GetUnusedOutgoingPort:  ;in: none, out: r0=unused port
 ;uh, original code wraps from port>LASTOUTGOINGPORT to port=FIRSTOUTGOINGPORT,
 ;better would be to "port=port-NUMPORTS" (else FIRSTOUTGOINGPORT would be used
 ;ALWAYS when wrapping occurs, which would somewhat negate the "random" effect).
 ;  and, what's that random good for anyways? original code used a 10bit random
 ;step for about 16000 ports, thus risking to reuse the SAME port after only
 ;16 calls, which could probably cause problems, better might be to use a
 ;smaller random step, or to used fixed step +1 instead of random (except,
 ;maybe use random ONLY IF a port is already in use; and of course ensure that
 ;the random value is nonzero).
 ;- - -
 ldr  r1,=udpport_counter               ;\get most-recenty USED port number
 ldr  r0,[r1]                           ;/
 ldr  r2,=sgIP_timems                   ;\
 ldrb r2,[r2]  ;8bit ("masked")         ; raise by semi-random step
;and  r2,0ffh  ;random mask             ;
 add  r0,r2    ;raise by random         ;/
@@retry_another_port:
 add  r0,1     ;raise by one            ;\raise by one, and
 cmp   r0,SGIP_UDP_LASTOUTGOINGPORT+1   ; wrap if neccessary
 subhs r0,SGIP_UDP_NUMPORTS             ;/
;- - -
 ldr  r3,=udprecords                            ;\
 ldr  r3,[r3]                                   ;
@@search_unused_lop:                            ; check if our random value
 cmp  r3,0           ;\okay, no more records,   ; is actually UNUSED
 beq  @@found_unused ;/the port is available    ; (ie. not used by existing
 ldrh r2,[r3,sgUdpRec_srcport]                  ; entries)
 ldr  r3,[r3,sgUdpRec_next]                     ;
 cmp  r2,r0                                     ;
 bne  @@search_unused_lop                       ;/
 b    @@retry_another_port              ;-already used, retry with ANOTHER value
;---
@@found_unused:
 str  r0,[r1] ;udpport_counter  ;-writeback (start-point for next pseudo-random)
 bx   lr     ;out: r0 = the unused port number
;------------------
sgIP_UDP_CalcChecksum:  ;in: r0=MemBlk, r1=srcip, r2=destip, r3=totallength, out: r0
 push lr
;BLAH: incoming "totallength" isn't needed (it's SAME as MemBlk's totallength)
 cmp  r0,0   ;MemBlk                            ;\return zero if no MemBlk
 beq  @@return_r0  ;out: r0=0                   ;/
;mov  r0,r0  ;MemBlk                            ;\
;mov  r1,r1  ;srcip                             ;
;mov  r2,r2  ;destip                            ;
 mov  r3,PROTOCOL_IP_UDP*100h  ;protocol        ;
 bl   sgIP_memblock_with_faux_header_IPChecksum ;/
 mvn    r0,r0  ;invert                          ;\checksum isolate LSW
 movs   r0,r0,lsl 16  ;to MSW (isolate LSW)     ; and invert checksum
 mvneq  r0,r0  ;if zero --> invert again        ; (unless result would be zero)
 mov    r0,r0,lsr 16  ;to LSW                   ;/
@@return_r0:    ;out: r0=checksum (or 0=failed)
 pop  pc
;------------------
sgIP_UDP_ReceivePacket:  ;in: r0=MemBlk, r1=srcip, r2=destip, out: r0
 push r4-r9,lr
 movs r4,r0  ;MemBlk            ;\memorize memblk, return zero if none
 beq  @@return_zero             ;/
 mov  r5,r1  ;srcIP             ;\memorize srcIp and destIP
 mov  r6,r2  ;destIP            ;/
;mov  r0,r0/r4  ;MemBlk                                 ;\
;mov  r1,r5/r1  ;srcIP                                  ;
;mov  r2,r6/r2  ;destIP                                 ; calc checksum
 ldr  r3,[r4,sgMemBlk_totallength]                      ;
 bl   sgIP_UDP_CalcChecksum                             ;/
 ldr  r9,[r4,sgMemBlk_datastart]                        ;-get ptr to UdpHdr
 ldr  r1,=0FFFFh                                        ;\
 cmp  r0,r1        ;calculated chksum                   ; want calculated=FFFFh
 ldrneh r0,[r9,sgUdpHdr_checksum]                       ; or memblk_check=0000h
 cmpne  r0,0000h   ;memblk's checksum entry             ; otherwise it's BAD
 bne    @@bad_chksum                                    ;/
 bl   sgIP_IntrProtect          ;\
 mov  r8,r0                     ;/
 ldr  r2,=udprecords       ;-ptr to FIRST record                      ;\
@@search_record_lop:                                                  ;
 ldr  r7,[r2]              ;\                                         ; search
 cmp  r7,0                 ; get CURRENT record (if any)              ; matching
 beq  @@record_not_found   ;/                                         ; record
 add  r2,r7,sgUdpRec_next  ;-ptr to NEXT record                       ;
 ldr  r0,[r7,sgUdpRec_srcip]                        ;\                ;
 cmp   r0,0   ;Rec/srcip = 0                        ; want srcip=0    ;
 cmpne r0,r6  ;Rec/srcip = destip                   ; or srcip=destip ;
 bne   @@search_record_lop                          ;/                ;
 ldr  r0,[r7,sgUdpRec_state]                        ;\                ;
 cmp  r0,SGIP_UDP_STATE_UNUSED                      ; want used state ;
 beq  @@search_record_lop                           ;/                ;
 ldrh r0,[r7,sgUdpRec_srcport]                      ;\                ;
 ldrh r1,[r9,sgUdpHdr_destport]                     ; want matching   ;
 cmp  r0,r1    ;Rec/src vs Hdr/dest                 ; src/dst         ;
 bne  @@search_record_lop                           ;/                ;/
;- - - okay, we have a record and a packet for it, add some data and enqueue it
 mov  r0,r4  ;MemBlk                    ;\
 mov  r1,+4                             ; expose...
 bl   sgIP_memblock_exposeheader        ;/
 ldr  r0,[r4,sgMemBlk_datastart]        ;\apply incoming srcip (this is 4 bytes
 str  r5,[r0,0]                         ;/PRIOR to the UdpHdr, due to above "expose 4")
 ldr  r0,[r7,sgUdpRec_incoming_queue]      ;\       ;\enqueue MemBlk as
 cmp  r0,0                                 ; first  ; first block of record,
 streq r4,[r7,sgUdpRec_incoming_queue]     ;/       ; or append it at end of
 ldrne r1,[r7,sgUdpRec_incoming_queue_end] ;\last   ; already queued MemBlk
 strne r4,[r1,sgMemBlk_next]               ;/       ;/
@@search_memblk_end:                    ;\
 ldr  r0,[r4,sgMemBlk_next]             ;
 cmp  r0,0                              ; search the LAST chain part of MemBlk
 movne r4,r0                            ;
 bne   @@search_memblk_end              ;/
 str   r4,[r7,sgUdpRec_incoming_queue_end]      ;-apply that as record's end
;- - - okay, data added to queue - yay! that means... we're done.
 mov  r0,r8                     ;\
 bl   sgIP_IntrUnprotect        ;/
@@return_zero:
 mov  r0,0              ;return 0 (always, no matter if okay/failed)
 pop  r4-r9,pc
;---
@@bad_chksum:
;SGIP_DEBUG_MESSAGE(("UDP receive checksum incorrect"));
 mov  r0,r4  ;MemBlk            ;\dealloc
 bl   sgIP_memblock_free        ;/
 b    @@return_zero
;---
@@record_not_found:
 mov  r0,r4  ;MemBlk            ;\dealloc
 bl   sgIP_memblock_free        ;/
 mov  r0,r8                     ;\
 bl   sgIP_IntrUnprotect        ;/
 b    @@return_zero
;------------------
sgIP_UDP_SendTo:  ;in: r0=UdpRec, r1=const char * buf, r2=buflength, r3=flags, r4=dest_ip, r5=dest_port, out: r0
 push r4,lr
;mov  r0,r0  ;UdpRec            ;\
;mov  r1,r1  ;buf               ; kept as is
;mov  r2,r2  ;buflen            ;/
;mov  N/A,r3 ;flags             ;-ignored flags
 mov  r3,r4  ;dest_ip           ;\moved
 mov  r4,r5  ;dest_port         ;/
 bl   sgIP_UDP_SendPacket       ;-pass on (without <flags>)
 pop  r4,pc
;------------------
sgIP_UDP_SendPacket:  ;in: r0=UdpRec, r1=data, r2=datalen, r3=destip, r4=destport, out: r0
 push r4-r12,lr
;mov  r4,r4  ;destport                  ;\
 mov  r5,r3  ;destip                    ;
 mov  r6,r2  ;datalen                   ; memorize params
 movs r7,r1  ;data                      ;
 beq  @@error_incoming_value            ;
 movs r8,r0  ;UdpRec                    ;
 beq  @@error_incoming_value            ;/
 ldr  r0,[r8,sgUdpRec_state]    ;\check         ;\
 cmp  r0,SGIP_UDP_STATE_BOUND   ; if bound      ;
 beq  @@already_bound           ;/              ;
 mov  r0,0                              ;\src   ; bind port (unless already)
 str  r0,[r8,sgUdpRec_srcip]            ;/ip    ;
 bl   sgIP_UDP_GetUnusedOutgoingPort    ;\src   ;
 strh r0,[r8,sgUdpRec_srcport]          ;/port  ;
 mov  r0,SGIP_UDP_STATE_BOUND           ;\mark  ;
 str  r0,[r8,sgUdpRec_state]            ;/bound ;
@@already_bound:                                ;/
 bl   sgIP_IP_RequiredHeaderSize  ;hdrsiz       ;\
 add  r0,8   ;plus 8, plus...     ;+8           ;
 add  r0,r6  ;datalen             ;+dtalen      ; alloc mem
 bl   sgIP_memblock_alloc                       ;
 movs r9,r0  ;MemBlk                            ;
 beq  @@error_no_memory                         ;/
 bl   sgIP_IP_RequiredHeaderSize  ;hdrsiz       ;\
 rsb  r1,r0,0  ;0-hdrsiz                        ; hide IP header space for later
 mov  r0,r9    ;MemBlk                          ;
 bl   sgIP_memblock_exposeheader                ;/
;- - -
 bl   sgIP_IntrProtect          ;\
 mov  r11,r0                    ;/
 ldr  r0,[r8,sgUdpRec_srcip]                    ;\
 mov  r1,r5  ;destip                            ; get srcip
 bl   sgIP_IP_GetLocalBindAddr                  ;
 mov  r10,r0 ;srcip                             ;/
 ldr  r12,[r9,sgMemBlk_datastart]  ;UdpHdr              ;-get ptr to UdpHdr
 ldrh r0,[r8,sgUdpRec_srcport]                      ;\  ;\
 strh r0,[r12,sgUdpHdr_srcport]                     ;/  ;
 strh r4,[r12,sgUdpHdr_destport]                    ;-  ;
 add  r0,r6,8  ;datalen+8   ;XXXX aka sgUdpHdr_size ;\  ; init UDP header
 bl   htons                                         ;   ;
 strh r0,[r12,sgUdpHdr_length]                      ;/  ;
 mov  r0,0                                          ;\  ;
 strh r0,[r12,sgUdpHdr_checksum]                    ;/  ;/
 mov  r0,r7    ;data               ;src                 ;\
 add  r1,r12,sgUdpHdr_size         ;dst                 ; copy data
 mov  r2,r6    ;datalen            ;len                 ;
 bl   memcopy_bytewise                                  ;/
 mov  r0,r9    ;MemBlk                                  ;\
 mov  r1,r10   ;srcip                                   ;
 mov  r2,r5    ;destip                                  ; adjust checksum
 ldr  r3,[r9,sgMemBlk_totallength]                      ;
 bl   sgIP_UDP_CalcChecksum                             ;
 strh r0,[r12,sgUdpHdr_checksum]                        ;/
 mov  r0,r9    ;MemBlk                                  ;\
 mov  r1,PROTOCOL_IP_UDP                                ;
 mov  r2,r10   ;srcip                                   ; send it
 mov  r3,r5    ;destip                                  ;
 bl   sgIP_IP_SendViaIP                                 ;/
 mov  r0,r11                    ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r6    ;datalen   ;out: r0=datalen=okay
@@return_r0:
 pop  r4-r12,pc
;---
@@error_incoming_value:
 bl   sgIP_error_inval
 b    @@return_r0
;---
@@error_no_memory:
 bl   sgIP_error_nomem
 b    @@return_r0
;------------------
sgIP_UDP_AllocRecord:  ;in: none, out: r0=UdpRec
 push r4,lr
 mov  r0,sgUdpRec_size          ;\
 bl   sgIP_malloc               ; alloc memory
 movs r4,r0                     ;
 beq  @@exit  ;alloc failed     ;/
 bl   sgIP_IntrProtect          ;\
;mov  r0,r0                     ;/
 mov  r1,0                                      ;\
 str  r1,[r4,sgUdpRec_destip]             ;=0   ;
 strh r1,[r4,sgUdpRec_destport]           ;=0   ; init entries
 str  r1,[r4,sgUdpRec_srcip]              ;=0   ;
 strh r1,[r4,sgUdpRec_srcport]            ;=0   ;
 str  r1,[r4,sgUdpRec_incoming_queue]     ;=0   ;
 str  r1,[r4,sgUdpRec_incoming_queue_end] ;=0   ;
 str  r1,[r4,sgUdpRec_state]              ;=0   ;/
 ldr  r1,=udprecords                            ;\
 ldr  r2,[r1]   ;old chain start                ; insert at begin of chain
 str  r4,[r1]   ;new chain start                ;
 str  r2,[r4,sgUdpRec_next]                     ;/
;mov  r0,r0                     ;\
 bl   sgIP_IntrUnprotect        ;/
@@exit:
 mov  r0,r4  ;out: r0=UpdRec (or 0=failed)
 pop  r4,pc
;------------------
sgIP_UDP_FreeRecord:  ;in: r0=UdpRec, out: none
 push r4-r5,lr
 movs r4,r0  ;UdpReq            ;\
 beq  @@fail                    ;/
 bl   sgIP_IntrProtect          ;\
 mov  r5,r0                     ;/
 ldr  r0,[r4,sgUdpRec_incoming_queue]   ;\incoming queue is all clumped together
 cmp  r0,0                              ; as a single memblock, so, time to free
 blne sgIP_memblock_free   ;(if any)    ;/it all in one call :) woohoo!
;BLAH: [r4,sgUdpRec_state]=0  ;nonsense (it's removed and deallocated anyways)
 ldr  r1,=udprecords            ;-ptr to FIRST chain entry
@@lop:
 ldr  r0,[r1]                   ;-get CURRENT chain entry
 cmp  r0,0                      ;\fail if end of chain (oops, not found)
 beq  @@fail                    ;/
 cmp  r0,r4                     ;\checked if searched entry
 beq  @@found                   ;/
 add  r1,r0,sgUdpRec_next       ;\lop next with ptr to NEXT chain entry
 b    @@lop                     ;/
;---
@@found:
 ldr  r0,[r0,sgUdpRec_next]     ;\replace ptr to CURRENT entry
 str  r0,[r1]                   ;/by ptr to NEXT entry (remove our entry)
 mov  r0,r4  ;UdpReq            ;\dealloc memory
 bl   sgIP_free                 ;/
 mov  r0,r5                     ;\
 bl   sgIP_IntrUnprotect        ;/
@@fail:
 pop  r4-r5,pc
;------------------
sgIP_UDP_Bind:  ;in: r0=UdpRec, r1=srcPort, r2=srcIP, out: r0
 push r4-r6,lr
 movs r4,r0  ;UdpRec            ;\error if rec=0
 beq  @@err_incoming_value      ;/
 mov  r5,r1  ;srcPort           ;\memorize params
 mov  r6,r2  ;srcIP             ;/
 bl   sgIP_IntrProtect          ;\
;mov  r0,r0                     ;/
 ldr  r3,[r4,sgUdpRec_state]   ;state   ;-get state
 cmp  r3,SGIP_UDP_STATE_UNUSED          ;\skip if state=UNUSED
 beq  @@skip_unused                     ;/
 strh r5,[r4,sgUdpRec_srcport] ;srcPort ;\apply port & ip
 str  r6,[r4,sgUdpRec_srcip]   ;srcIP   ;/
 cmp  r3,SGIP_UDP_STATE_UNBOUND         ;\if state=UNBOUND
 moveq r3,SGIP_UDP_STATE_BOUND          ; then change to state=BOUND
 streq r3,[r4,sgUdpRec_state]  ;state   ;/
@@skip_unused:
;mov  r0,r0                     ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,0
@@return_r0:
 pop  r4-r6,pc
;---
@@err_incoming_value:
 bl   sgIP_error_inval
 b    @@return_r0
;------------------
sgIP_UDP_RecvFrom:  ;in: r0=UdpRec, r1=destbuf, r2=buflength, r3=flags, r4=sender_ip, r5=sender_port, out: r0
 push r4-r11,lr
 cmp    r4,0   ;sender_ip       ;\
 cmpne  r5,0   ;sender_port     ; check/memorize params, and
 movnes r6,r0  ;UdpRec          ; fail if pointers/addresses/length are 0
 movnes r7,r1  ;destbuf         ;
 movnes r8,r2  ;buflength       ; ;note: sender_ip and sender_port are pointers
 beq    @@err_incoming_value    ; ;and the actual ip/port will be stored there
 mov    r9,r3  ;flags           ;/
 bl   sgIP_IntrProtect          ;\
 mov  r11,r0                    ;/
 ldr  r10,[r6,sgUdpRec_incoming_queue]  ;\
 cmp  r10,0    ;MemBlk                  ; fail if queue empty (would block)
 beq  @@err_would_block                 ;/
 ldr  r0,[r10,sgMemBlk_totallength]     ;\
 sub  r0,12    ;totallength-12          ; fail if queue contains MORE data
 cmp  r0,r8    ;buflength               ; as expected
 bhi  @@err_msg_size                    ;/
 ldr  r1,[r10,sgMemBlk_datastart]       ;\   ;<-- 4 bytes PRIOR to UdpHdr
 ldr  r0,[r1,0]                         ; store IP and Port at the
 str  r0,[r4]  ;[sender_ip]             ; incoming pointers
 ldrh r0,[r1,4]                         ;
 strh r0,[r5]  ;[sender_port]           ;/
;- - - now copy bytes to destbuf...
 mov  r4,12    ;first=12        ;skip first 12 bytes in first MemBlk (uh, why? maybe it's having another number of "exposed" bytes than later/queued blocks?) (BUT, all MemBlk's are gained via "sgUdpRec_incoming_queue" so they SHOULD be all the same in length...?)
 mov  r5,0     ;destindex
 ldr  r8,[r10,sgMemBlk_totallength]     ;-get total_len
@@copy_lop:
 cmp  r8,0        ;total_len            ;\
 beq  @@copy_done                       ; until total_len=0
;bmi  @@copy_done ;(uh?)                ; or no more MemBlk's queued
 cmp  r10,0    ;curr MemBlk from queue  ;
 beq  @@copy_done                       ;/
 ldr  r0,[r10,sgMemBlk_datastart]  ;src ;\
 add  r0,r4    ;add first          ;src ;
 add  r1,r7,r5 ;destbuf+destindex  ;dst ; copy received bytes to dest
 ldr  r2,[r10,sgMemBlk_thislength] ;len ;
 sub  r8,r2  ;<--decrease total_len     ; (and decrease total_len)
 sub  r2,r4    ;thislength-first   ;len ; (and raise destindex)
 add  r5,r2  ;<--raise destindex        ;
 bl   memcopy_bytewise                  ;/
 mov  r0,r10  ;old MemBlk               ;-move OLD memblk to r0
 ldr  r10,[r0,sgMemBlk_next]            ;\move NEXT memblk to r10, and
 str  r10,[r6,sgUdpRec_incoming_queue]  ;/apply it is as new queue_start
 mov  r1,0                   ;\unchain  ;\
 str  r1,[r0,sgMemBlk_next]  ;/         ; disconnect OLD memblk from chain
;mov  r0,r0   ;old MemBlk    ;\dealloc  ; and deallocate it
 bl   sgIP_memblock_free     ;/         ;/
 mov  r4,0     ;first=0                 ;-
 b    @@copy_lop
;---
@@copy_done:
 cmp   r10,0   ;curr MemBlk                     ;\if there is no more MemBlk,
 streq r10,[r6,sgUdpRec_incoming_queue_end]     ;/also set LAST MemBlk to ZERO
 mov  r0,r11                    ;\
 bl   sgIP_IntrUnprotect        ;/
 mov  r0,r5             ;okay, return r0=destindex (aka num bytes received)
@@return_r0:
 pop  r4-r11,pc
;---
@@err_incoming_value:
 bl   sgIP_error_inval
 b    @@return_r0
;---
@@err_would_block:
 mov  r0,r11                    ;\
 bl   sgIP_IntrUnprotect        ;/
 bl   sgIP_error_wouldblock
 b    @@return_r0
;---
@@err_msg_size:
 mov  r0,r11                    ;\
 bl   sgIP_IntrUnprotect        ;/
 bl   sgIP_error_msgsize
 b    @@return_r0
;------------------
.pool
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\wifi_arm9.c Heap
;------------------
.ifdef WIFI_USE_TCP_SGIP
;------------------
.data?
 wifi_hw        dd 0  ;ptr to sgHubHwi
.code
;------------------
;ASSOCSTATUS_STRINGS:  ;BLAH/UNUSED  ;for "arm9_Wifi_AssocStatus" return values
; db 'Disconnected',0   // .errif 0<>ASSOCSTATUS_DISCONNECTED   ;not *trying* to connect
; db 'Searching',0      // .errif 1<>ASSOCSTATUS_SEARCHING      ;data given does not completely specify an AP, looking for AP that matches the data.
; db 'Authenticating',0 // .errif 2<>ASSOCSTATUS_AUTHENTICATING ;connecting...
; db 'Associating',0    // .errif 3<>ASSOCSTATUS_ASSOCIATING    ;connecting...
; db 'AcquiringDHCP',0  // .errif 4<>ASSOCSTATUS_ACQUIRINGDHCP  ;connected to AP, but getting IP data from DHCP
; db 'Associated',0     // .errif 5<>ASSOCSTATUS_ASSOCIATED     ;Connected!
; db 'CannotConnect',0  // .errif 6<>ASSOCSTATUS_CANNOTCONNECT  ;error in connecting...
; .align 4
;------------------
;wifi heap allocator system...
;------------------
WHEAP_RECORD_FLAG_INUSE    equ 0        ;uh, actually that are STATE VALUES
WHEAP_RECORD_FLAG_UNUSED   equ 1        ;(not "FLAGS")
WHEAP_RECORD_FLAG_FREED    equ 2
;------------------
;struct wHeapRecord:
 sgHeapRec_next       equ 00h ;4  ;struct WHEAP_RECORD * next;
 sgHeapRec_flags      equ 04h ;2  ;unsigned short        flags
 sgHeapRec_unused     equ 06h ;2  ;unsigned short        unused; (USED: this is "number of unused/extra bytes")
 sgHeapRec_size_len   equ 08h ;4  ;int                   size;
 sgHeapRec_size_total equ 0ch ;total
;------------------
.ifdef SGIP_DEBUG
  WHEAP_FILL_START   equ 0AAh  ;padding value
  WHEAP_FILL_END     equ 0BBh  ;padding value
  WHEAP_PAD_START    equ 4     ;padding length
  WHEAP_PAD_END      equ 4     ;padding length
  WHEAP_DO_PAD   equ 1
.else
  WHEAP_PAD_START    equ 0
  WHEAP_PAD_END      equ 0
  ;undefine WHEAP_DO_PAD
.endif
;------------------
WHEAP_RECORD_SIZE  equ sgHeapRec_size_total
WHEAP_PAD_SIZE     equ (WHEAP_PAD_START+WHEAP_PAD_END)
WHEAP_SIZE_CUTOFF  equ (WHEAP_RECORD_SIZE+64)
;------------------
.data?
;wHeapsize   dd 0  ;<-- BLAH/UNUSED
wHeapStart  dd 0  ;ptr to wHeapRecord, start of heap
wHeapFirst  dd 0  ;ptr to wHeapRecord, first free block (0=no free block) (intended to speed-up searching free records)
.code
;------------------
arm9_wHeapAllocInit:  ;in: r0=size, out: none
 push r4,lr
 mov  r4,r0     ;size
;mov  r0,r4     ;size           ;\
 bl   arm9_malloc               ; alloc heap
 ldr  r1,=wHeapStart            ;
 str  r0,[r1]   ;start          ;/
 cmp  r0,0                      ;\exit if failed
 beq  @@exit                    ;/
 ldr  r1,=wHeapFirst            ;\apply as first free block
 str  r0,[r1]   ;first free     ;/
 mov  r1,WHEAP_RECORD_FLAG_UNUSED       ;\mark as unused
 strh r1,[r0,sgHeapRec_flags]           ;/
 mov  r1,0                              ;\no next chain entry
 str  r1,[r0,sgHeapRec_next]            ;/
 sub  r4,sgHeapRec_size_total ;siz-hdr  ;\init size (excluding struct size)
 str  r4,[r0,sgHeapRec_size_len]        ;/
@@exit:
 pop  r4,pc
;------------------
arm9_wHeapAlloc:  ;in: r0=size, out: r0=data
;uh, is it reliable to do this WITHOUT sgIP_IntrProtect? not sure if there are
;cases where IRQ handlers could allocate memory at same time than main program,
;but if so, then both might end up allocating the SAME "free" block!
;- - -
 push r4-r5,lr

         push r6
         push r0
         bl   sgIP_IntrProtect         ;\XXXX????
         mov  r6,r0                    ;/
         pop  r0

 add  r4,r0,3  ;size.roundup    ;\
 bics r4,3     ;size.align      ; size
 moveq r4,4    ;size.min=4      ;
 add  r4,WHEAP_PAD_SIZE         ;/
 ldr  r5,=wHeapFirst            ;\get first free record (0=none)
 ldr  r5,[r5]                   ;/
 cmp  r5,0   ;HeapRec           ;\fail if no free records at all
 beq  @@return_zero             ;/
@@search_enough_space_lop:
 ldr  r0,[r5,sgHeapRec_size_len]        ;\
 subs r0,r4  ;size                      ; check if enough space
 bhs  @@found_enough_space   ;in: r0    ;/
 ldr  r1,[r5,sgHeapRec_next]            ;\
 cmp  r1,0                              ; fail if no more (free/used) records
 beq  @@return_zero                     ;/
 ldrh r0,[r1,sgHeapRec_flags]           ;\
 cmp  r0,WHEAP_RECORD_FLAG_INUSE        ; check if next record is free/used
 beq  @@skip_used_records               ;/
 ldr  r0,[r1,sgHeapRec_next]        ;\apply "next_next"         ;\
 str  r0,[r5,sgHeapRec_next]        ;/as "next"                 ; merge next
 ldr  r0,[r1,sgHeapRec_size_len]    ;\                          ; free record
 ldr  r1,[r5,sgHeapRec_size_len]    ; merge next size           ; with current
 add  r0,r1  ;size+next_size        ; with curr size            ; free one,
 add  r0,WHEAP_RECORD_SIZE          ;                           ; and retry
 str  r0,[r5,sgHeapRec_size_len]    ;/                          ;
 b    @@search_enough_space_lop     ;-retry with merged record  ;/
;---
@@skip_used_records:  ;skip ahead to more friendly waters
 mov  r5,r1  ;next record (which is already known to exist and to be INUSE)
@@skip_used_records_lop:  ;search next UNUSED record...
 ldr  r5,[r5,sgHeapRec_next]            ;\
 cmp  r5,0                              ; get next, fail if no more records
 beq  @@return_zero                     ;/
 ldrh r0,[r5,sgHeapRec_flags]           ;\
 cmp  r0,WHEAP_RECORD_FLAG_INUSE        ; check if record is free
 beq  @@skip_used_records_lop           ;/
 b    @@search_enough_space_lop         ;-found free record, go back to "search"
;---
@@found_enough_space:   ;in: r0="[r5,sgHeapRec_size_len]-size"
 mov  r1,WHEAP_RECORD_FLAG_INUSE        ;\mark record as used
 strh r1,[r5,sgHeapRec_flags]           ;/
 cmp  r0,WHEAP_SIZE_CUTOFF              ;\if the old/free record is only a
 strloh r0,[r5,sgHeapRec_unused]        ; little bigger than needed, apply
 blo    @@do_not_chop_into_2_blocks     ;/the extra bytes as "unused"
;- - - else, chop the old/free record into TWO blocks (1st=used, 2nd=free)...
 add  r1,r5,WHEAP_RECORD_SIZE ;\ptr to  ;\ ;\
 add  r1,r4                   ;/2ndRec  ;  ;
 sub  r0,WHEAP_RECORD_SIZE        ;\2nd ;  ;
 str  r0,[r1,sgHeapRec_size_len]  ;/size;  ; second record (free)
 mov  r0,WHEAP_RECORD_FLAG_UNUSED ;\2nd ;  ;
 strh r0,[r1,sgHeapRec_flags]     ;/free;  ;
 ldr  r0,[r5,sgHeapRec_next] ;1st ;\2nd ;  ;
 str  r0,[r1,sgHeapRec_next] ;2nd ;/next;  ;/
 str  r1,[r5,sgHeapRec_next] ;[1st]=2nd ;  ;\
 str  r4,[r5,sgHeapRec_size_len]        ;  ; first record (used)
 mov  r0,0                      ;\1st   ;  ;
 strh r0,[r5,sgHeapRec_unused]  ;/unused;/ ;/
@@do_not_chop_into_2_blocks:
 ldr  r1,=wHeapFirst                    ;\
 ldr  r0,[r1]                           ;
 cmp  r0,r5                             ; if the allocated record was
 bne  @@is_not_first_free               ; the "first free" one, then
@@find_new_first_free_lop:              ; update the "first free" pointer,
 ldr  r0,[r0,sgHeapRec_next]            ; ie. search the next free record
 cmp  r0,0                              ; (if any, or 0=none)
 beq  @@is_first_free                   ;
 ldrh r3,[r0,sgHeapRec_flags]           ;
 cmp  r3,WHEAP_RECORD_FLAG_INUSE        ;
 beq  @@find_new_first_free_lop         ;
@@is_first_free:                        ;
 str  r0,[r1]  ;[wHeapFirst]=r0         ;
@@is_not_first_free:                    ;/
 .ifdef WHEAP_DO_PAD
   add  r1,r5,WHEAP_RECORD_SIZE  ;skip hdr      ;\
   mov  r2,WHEAP_PAD_START  ;pad.length         ;
   mov  r3,WHEAP_FILL_START ;pad.value          ; apply padding
  @@pad_start_lop:                              ; at record start
   strb r3,[r1],1                               ;
   subs r2,1                                    ;
   bne  @@pad_start_lop                         ;/
   add  r1,r5,r4 ;base+size                     ;\
   add  r1,WHEAP_RECORD_SIZE-WHEAP_PAD_END      ;
   mov  r2,WHEAP_PAD_END    ;pad.length         ; apply padding
   mov  r3,WHEAP_FILL_END   ;pad.value          ; at record end
  @@pad_end_lop:                                ;
   strb r3,[r1],1                               ;
   subs r2,1                                    ;
   bne  @@pad_end_lop                           ;/
 .endif
 add  r0,r5,WHEAP_RECORD_SIZE+WHEAP_PAD_START   ;-return ptr to data (after hdr)
@@return_r0:

         mov r4,r0
         mov  r0,r6                     ;\
         bl   sgIP_IntrUnprotect        ;/
         mov r0,r4
         pop  r6

 pop  r4-r5,pc
;---
@@return_zero:

        .if 0       ;XNAY
        mov r0,'H' // bl wrchr_r0
        mov r0,'E' // bl wrchr_r0
        mov r0,'A' // bl wrchr_r0
        mov r0,'P' // bl wrchr_r0
        mov r0,'F' // bl wrchr_r0
        mov r0,'U' // bl wrchr_r0
        mov r0,'L' // bl wrchr_r0
        mov r0,'L' // bl wrchr_r0
        .endif

 mov  r0,0
 b    @@return_r0
;------------------
arm9_wHeapFree:  ;in: r0=data, out: none
 push r4,lr

         push r6
         push r0
         bl   sgIP_IntrProtect         ;\XXXX????
         mov  r6,r0                    ;/
         pop  r0

 sub  r4,r0,WHEAP_RECORD_SIZE+WHEAP_PAD_START  ;HeapRec = data-hdr
 .ifdef WHEAP_DO_PAD
   add  r1,r4,WHEAP_RECORD_SIZE  ;skip hdr      ;\
   mov  r2,WHEAP_PAD_START  ;pad.length         ;
  @@verify_start_lop:                           ;
   ldrb r3,[r1],1                               ; verify padding
   cmp  r3,WHEAP_FILL_START ;pad.value          ; at record start
   bne  @@heap_corrupt                          ;
   subs r2,1                                    ;
   bne  @@verify_start_lop                      ;/
   ldr  r1,[r4,sgHeapRec_size_len]              ;\
   ldrh r3,[r4,sgHeapRec_unused]                ;
   sub  r1,r3  ;size-unused                     ;
   add  r1,r4  ;add base                        ;
   add  r1,WHEAP_RECORD_SIZE-WHEAP_PAD_END      ; verify padding
   mov  r2,WHEAP_PAD_END    ;pad.length         ; at record end
  @@verify_end_lop:                             ;
   ldrb r3,[r1],1                               ;
   cmp  r3,WHEAP_FILL_END   ;pad.value          ;
   bne  @@heap_corrupt                          ;
   subs r2,1                                    ;
   bne  @@verify_end_lop                        ;/
   b    @@padding_okay
  ;---
  @@heap_corrupt:
   ;SGIP_DEBUG_MESSAGE(("wHeapFree: Corruption found! 0x%x",data));
   b    $
  @@padding_okay:
 .endif
;ldrh r0,[r4,sgHeapRec_flags]       ;warn if already free'd                 ;\
;cmp  r0,WHEAP_RECORD_FLAG_INUSE                                            ;
;blne SGIP_DEBUG_MESSAGE(("wHeapFree: Data already freed! 0x%X",data)) ;/

         ldrh r0,[r4,sgHeapRec_flags]       ;warn if already free'd
         cmp  r0,WHEAP_RECORD_FLAG_INUSE
         beq @@ok
          mov r0,'O' // bl wrchr_r0         ;XNAY
          mov r0,'O' // bl wrchr_r0
          mov r0,'P' // bl wrchr_r0
          mov r0,'S' // bl wrchr_r0
         @@ok:

 mov  r0,WHEAP_RECORD_FLAG_FREED                ;\mark free
 strh r0,[r4,sgHeapRec_flags]                   ;/
 ldr  r1,=wHeapFirst                            ;\
 ldr  r2,[r1] ;old                              ; apply as "first free" record
 cmp  r2,0      ;\there was NO free record      ; (if there was NO free record,
 streq r4,[r1]  ;/                              ; or if the old "first free" one
 cmp  r4,r2     ;\old "first free" was higher   ; was at higher memory address)
 strlo r4,[r1]  ;/                              ;/

         mov r4,r0
         mov  r0,r6                     ;\
         bl   sgIP_IntrUnprotect        ;/
         mov r0,r4
         pop  r6

 pop  r4,pc
;------------------
;///////////////////////////... ;uh, why this "////" PRIOR to below "endif"?
;------------------
sgIP_malloc  equ arm9_wHeapAlloc  ;in: r0=size, out: r0=data  ;__attribute__((weak))
sgIP_free    equ arm9_wHeapFree   ;in: r0=data, out: none     ;__attribute__((weak))
;------------------
.pool
;------------------
.endif ;WIFI_USE_TCP_SGIP
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\wifi_arm9.c ...
;------------------
arm9_ethhdr_print:  ;in: r0=char ("R"/"T"), r1=EthHdr, out: none
 ;BLAH: original code is doing this even if "SGIP_DEBUG" is disabled (although
 ;"SGIP_DEBUG_MESSAGE" isn't doing anything in that case, so creating the
 ;the "buffer" string is total nonsense in that case)
 ;and asides, the string creation in original code is a little bit weird.
 ;- - -
 .ifdef SGIP_DEBUG
   ;SGIP_DEBUG_MESSAGE(char,":",sgEthHdr_dest_mac(6)," ",sgEthHdr_src_mac(6)," ",sgEthHdr_protocol(2))
 .endif
 bx   lr
;------------------
.data?
arm9_WifiData          dd 0  ;ptr to "Wifi_MainStruct"
arm9_packethandler     dd 0  ;proc WifiPacketHandler
arm9_synchandler       dd 0  ;proc WifiSyncHandler
.code
;------------------
.data?
wifi_connect_state   dd 0   ;-1==error, 0==searching, 1==associating, 2==dhcp'ing, 3==done, 4=searching wfc data
wifi_connect_point:  defs sgWifiAp_size
.code
;------------------
arm9_erasemem:  ;in: r0=dest, r1=length, out: none
 mov  r2,00h  ;fillbyte
@@lop:
 subs   r1,1
 strhsb r2,[r0],1
 bhi    @@lop
 bx   lr
;------------------
arm9_Wifi_CopyMacAddr:  ;in: r0=src, r1=dst, out: r0/r1=increased
 ;note: original code used r0/r1 vice-versa, and didn't return r0/r1=next
 ldrh r2,[r0],2         ;\copy 1st halfword     ;\
 strh r2,[r1],2         ;/                      ; write in 16bit units
 ldrh r2,[r0],2         ;\copy 2nd halfword     ; (Wifi hardware doesn't
 strh r2,[r1],2         ;/                      ; support 8bit writes)
 ldrh r2,[r0],2         ;\copy 3rd halfword     ;
 strh r2,[r1],2         ;/                      ;/
 bx   lr
;------------------
arm9_Wifi_CmpMacAddr:  ;in: r0=mac1, r1=mac2, out: r0
 ldrh   r2,[r0,0]       ;\
 ldrh   r3,[r1,0]       ; compare 1st halfword
 cmp    r2,r3           ;/
 ldreqh r2,[r0,2]       ;\
 ldreqh r3,[r1,2]       ; compare 2nd halfword
 cmpeq  r2,r3           ;/
 ldreqh r2,[r0,4]       ;\
 ldreqh r3,[r1,4]       ; compare 3rd halfword
 cmpeq  r2,r3           ;/
 moveq  r0,1   ;match
 movne  r0,0   ;mismatch
 bx     lr
;------------------
arm9_Wifi_TxBufferWordsAvailable:  ;in: none, out: r0
 ldr  r0,=WifiData_txbufIn
 ldr  r0,[r0]
 ldr  r1,=WifiData_txbufOut
 ldr  r1,[r1]
 sub  r0,r1
 subs r0,1
 addmi r0,WIFI_TXBUFFER_SIZE/2  ;wrap
 bx   lr    ;out: r0
;------------------
arm9_Wifi_TxBufferWrite:  ;in: r0=dst.index/2, r1=len/2, r2=src, out: none
 push r4-r6,lr
 mov  r4,r2        ;src (regular memory address)
 mov  r5,r0,lsl 1  ;dst (halfword index in "txbufData") (mul2: byte index)
 mov  r6,r1,lsl 1  ;len (num halfwords)                 (mul2: num bytes)
@@lop:
 movs r2,r6  ;len = remain          ;\
 beq  @@done ;len=0                 ;
 rsb  r3,r5,WIFI_TXBUFFER_SIZE      ; len
 cmp  r2,r3  ;len,(SIZE-dst)        ;
 movhi r2,r3 ;len=(SIZE-dst)        ;/
 mov  r0,r4  ;src                   ;\
 ldr  r1,=WifiData_txbufData        ; src,dst
 add  r1,r5  ;dst+base              ;/
 add  r4,r2  ;raise src             ;\
 add  r5,r2  ;raise dst             ; raise,
 cmp  r5,WIFI_TXBUFFER_SIZE  ;dst   ; wrap,
 subhs r5,WIFI_TXBUFFER_SIZE ;wrap  ; decrease
 sub  r6,r2  ;decrease remain       ;/

.if 0       ;XNAY
push r0-r7
mov  r4,r0 ;src
mov  r5,r2 ;len
@@showlop:
ldrb r0,[r4],1
mov  r6,r0
mov  r0,r0,lsr 4
cmp  r0,09h
addhi r0,07h
add r0,30h
bl  wrchr_r0
and  r0,r6,0fh
cmp  r0,09h
addhi r0,07h
add r0,30h
bl  wrchr_r0
mov r0,20h
bl  wrchr_r0
subs r5,1
bne @@showlop
pop  r0-r7
.endif

 bl   memcopy_bytewise              ;-copy
 b    @@lop
@@done:
 pop  r4-r6,pc
;------------------
arm9_Wifi_RxRawReadPacket:  ;in: r0=src.index/2, r1=len, r2=dst, out: none
 ;BLAH: original code does round-up length to halfword boundary, thus writing
 ;an extra byte to dest upon odd length (to avoid writing too much data to dest,
 ;original code in "arm9_Wifi_Update" is transferring the last/odd byte manually
 ;via some weird code construction, instead of via this function.
 ;however, READING from WifiRAM should work even in byte-units, so the whole
 ;rounding stuff & manual last-byte transfer stuff aren't really needed, and
 ;one can instead just support odd lengths.
 ;uh, this is ARM9 code (with everything in MainRAM or DTCM, not WifiRAM),
 ;so odd bytes should be no issue at all.
 ;another oddity is that original code returned the rounded-length div2 (which
 ;doesn't work out when supporting odd lengths, but which isn't needed because
 ;the return value wasn't used anywhere, so one can just omit the return value.
 ;- - -
 push r4-r6,lr
 mov  r4,r0,lsl 1  ;src (halfword index in "rxbufData") (mul2: byte index)
 mov  r5,r2        ;dst (regular memory address)
 mov  r6,r1        ;len (num bytes) (not rounded-up, unlike original code)
@@lop:
 movs r2,r6  ;len = remain          ;\
 beq  @@done ;len=0                 ;
 rsb  r3,r4,WIFI_RXBUFFER_SIZE      ; len
 cmp  r2,r3  ;len,(SIZE-src)        ;
 movhi r2,r3 ;len=(SIZE-src)        ;/
 ldr  r0,=WifiData_rxbufData        ;\
 add  r0,r4  ;src+base              ; src,dst
 mov  r1,r5  ;dst                   ;/
 add  r4,r2  ;raise src             ;\
 add  r5,r2  ;raise dst             ; raise,
 cmp  r4,WIFI_RXBUFFER_SIZE  ;src   ; wrap,
 subhs r4,WIFI_RXBUFFER_SIZE ;wrap  ; decrease
 sub  r6,r2  ;decrease remain       ;/
 bl   memcopy_bytewise              ;-copy
 b    @@lop
@@done:
 pop  r4-r6,pc   ;out: nothing (unlike original code)
;------------------
arm9_Wifi_RxReadOffset:  ;in:r0=base, r1=offset, out: r0=halfword
 add  r0,r1   ;base+offset
 cmp  r0,WIFI_RXBUFFER_SIZE/2
 subhs r0,WIFI_RXBUFFER_SIZE/2  ;wrap
 mov  r0,r0,lsl 1  ;mul2 (bytes vs halfwords)
 ldr  r1,=WifiData_rxbufData
 ldrh r0,[r1,r0]
 bx   lr
;------------------
.if with_gimmicks  ;this function is unused...
arm9_Wifi_RawTxFrame:  ;in: r0=datalen, r1=rate, r2=data, out: r0
 ;datalen = size of packet from beginning of 802.11 header to end, but not including CRC.
 ;uh, "rate" should be "maxrate7" or so... or maybe 0=auto... or WHAT...?
 ;- - -
 push r4-r8,lr
 sub  sp,sgTxHdr_size           ;alloc tx header
 mov  r4,r0  ;datalen
 mov  r5,r2  ;data
 mov  r0,0                                      ;\
 strh r0,[sp,sgTxHdr_enable_flags]  ;=0         ;
 strh r0,[sp,sgTxHdr_unknown]       ;=0         ;
 strh r0,[sp,sgTxHdr_countup]       ;=0         ; init tx header
 strh r0,[sp,sgTxHdr_beaconfreq]    ;=0         ;
 strh r1,[sp,sgTxHdr_tx_rate]       ;=rate      ;
 add  r0,r4,4  ;datalen+4                       ;
 strh r0,[sp,sgTxHdr_tx_length]     ;=len+4     ;/
 add  r4,1      ;round-up                       ;\round-up/align len
 bic  r4,1      ;align                          ;/
 add  r8,r4,sgTxHdr_size   ;len+header+roundup  ;-calc size.needed
 bl   arm9_Wifi_TxBufferWordsAvailable          ;\
 cmp  r0,r8  ;sizeneeded                        ;
 bhs  @@has_enough_space                        ; check if enough buffer space
 ldr  r1,=WifiData_stats                ;\      ;
 ldr  r0,[r1,WSTAT_TXQUEUEDREJECTED*4]  ; error ;
 add  r0,1                              ; stats ;
 str  r0,[r1,WSTAT_TXQUEUEDREJECTED*4]  ;/      ;
 mov  r0,-1        ;out: r0=-1 (failed) ;\fail  ;
 b    @@return_r0                       ;/      ;
@@has_enough_space:                             ;/
 ldr  r6,=WifiData_txbufOut                     ;\get dest.base
 ldr  r7,[r6]   ;dest.base                      ;/
 mov  r0,r7             ;dest.base      ;\      ;\
 mov  r1,sgTxHdr_size/2 ;len: tx header ; send  ;
 mov  r2,sp             ;src: tx header ;       ;
 bl   arm9_Wifi_TxBufferWrite           ;/      ; send --> tx header
 add  r7,sgTxHdr_size/2 ;dest.base+len  ;\raise ;
 cmp  r7,WIFI_TXBUFFER_SIZE/2           ; dest  ;
 subhs r7,WIFI_TXBUFFER_SIZE/2  ;wrap   ;/      ;/
 mov  r0,r7             ;dest.base      ;\      ;\
 mov  r1,r4,lsr 1       ;len: datalen/2 ; send  ;
 mov  r2,r5             ;src: data      ;       ;
 bl   arm9_Wifi_TxBufferWrite           ;/      ; send --> packet data
 add  r7,r7,r4,lsr 1    ;dest.base+len/2;\raise ;
 cmp  r7,WIFI_TXBUFFER_SIZE/2           ; dest  ;
 subhs r7,WIFI_TXBUFFER_SIZE/2  ;wrap   ;/      ;/
;ldr  r6,=WifiData_txbufOut                     ;\apply new dest.base
 str  r7,[r6]   ;dest.base                      ;/
 ldr  r1,=WifiData_stats                        ;\
 ldr  r0,[r1,WSTAT_TXQUEUEDPACKETS*4]   ;\      ;
 add  r0,1                              ;       ; raise stats
 str  r0,[r1,WSTAT_TXQUEUEDPACKETS*4]   ;/      ;
 ldr  r0,[r1,WSTAT_TXQUEUEDBYTES*4]     ;\      ;
 add  r0,r8  ;sizeneeded                ;       ;
 str  r0,[r1,WSTAT_TXQUEUEDBYTES*4]     ;/      ;/
 ldr  r3,=arm9_synchandler                      ;\
 ldr  r3,[r3]                                   ; call sync handler (if any)
 cmp  r3,0                                      ;
 blne bx_r3                                     ;/
 mov  r0,0      ;out: r0=0=okay
@@return_r0:
 add  sp,sgTxHdr_size           ;dealloc tx header
 pop  r4-r8,pc
.endif ;with_gimmicks
;------------------
arm9_Wifi_RawSetPacketHandler:  ;in: r0=WifiPacketHandler wphfunc, out: none
 ldr  r1,=arm9_packethandler
 str  r0,[r1]
 bx   lr
;------------------
arm9_Wifi_SetSyncHandler:  ;in: r0=WifiSyncHandler wshfunc, out: none
 ldr  r1,=arm9_synchandler
 str  r0,[r1]
 bx   lr
;------------------
arm9_Wifi_DisableWifi:  ;in/out: none
 ldr  r1,=WifiData_reqMode      ;\
 mov  r0,WIFIMODE_DISABLED      ; set DISABLED mode
 strh r0,[r1]                   ;/
 ldr  r1,=WifiData_reqReqFlags  ;\
 ldrh r0,[r1]                   ; clear APCONNECT flag
 bic  r0,WFLAG_REQ_APCONNECT    ;
 strh r0,[r1]                   ;/
 bx   lr
;------------------
arm9_Wifi_EnableWifi:  ;in/out: none
 ldr  r1,=WifiData_reqMode      ;\
 mov  r0,WIFIMODE_NORMAL        ; set NORMAL mode
 strh r0,[r1]                   ;/
 ldr  r1,=WifiData_reqReqFlags  ;\
 ldrh r0,[r1]                   ; set APCONNECT flag
 orr  r0,WFLAG_REQ_APCONNECT    ;
 strh r0,[r1]                   ;/
 bx   lr
;------------------
arm9_Wifi_SetPromiscuousMode:  ;in: r0=enable, out: none
 ldr  r1,=WifiData_reqReqFlags  ;\
 ldrh r2,[r1]                   ;
 cmp  r0,0    ;param            ; set/clear PROMISC flag
 orrne r2,WFLAG_REQ_PROMISC     ;
 biceq r2,WFLAG_REQ_PROMISC     ;
 strh r2,[r1]                   ;/
 bx   lr
;------------------
arm9_Wifi_ScanMode:  ;in/out: none
 ldr  r1,=WifiData_reqMode      ;\
 mov  r0,WIFIMODE_SCAN          ; set SCAN mode
 strh r0,[r1]                   ;/
 ldr  r1,=WifiData_reqReqFlags  ;\
 ldrh r0,[r1]                   ; clear APCONNECT flag
 bic  r0,WFLAG_REQ_APCONNECT    ;
 strh r0,[r1]                   ;/
 bx   lr
;------------------
arm9_Wifi_AutoConnect:  ;in/out: none
 ldr  r1,=wifi_connect_state
 ldr  r0,=WifiData_wfc_ap+0     ;\check first access point
 ldrb r0,[r0,sgWifiWfc_enable]  ; (see if there's at least ONE access point)
 tst  r0,80h                    ;/
 moveq r0,-1                    ;\nope, fail  ;uh, without any "error" returned
 streq r0,[r1]  ;state          ;/            ;(aside from "wifi_connect_state")
 movne r0,4                 ;\  ;\
 strne r0,[r1]  ;state      ;/  ;
 ldrne r1,=WifiData_reqMode ;\  ; yup, "scan" for (already known) access points
 movne r0,WIFIMODE_SCAN     ;   ;
 strneh r0,[r1]             ;/  ;/
 bx   lr
;------------------
arm9_Wifi_SetChannel:  ;in: r0=channel, out: none
 sub  r1,r0,1                   ;\
 cmp  r1,12                     ; exit if channel isn't in range 1..13
 bxhi lr                        ;/
 ldr  r1,=WifiData_reqMode      ;\
 ldrh r1,[r1]                   ;
 cmp    r1,WIFIMODE_NORMAL      ; apply channel only if mode is NORMAL or SCAN
 cmpne  r1,WIFIMODE_SCAN        ;
 ldreq  r1,=WifiData_reqChannel ;
 streqh r0,[r1]                 ;/
 bx  lr
;------------------
arm9_Wifi_GetNumAP:  ;in: none, out: r0=num
 mov  r0,0   ;initial sum
 ldr  r1,=WifiData_aplist  ;list of received beacons
 mov  r2,WIFI_MAX_AP
@@lop:
 ldrh r3,[r1,sgWifiAp_flags]    ;\
 tst  r3,WFLAG_APDATA_ACTIVE    ; raise if active entry
 addne r0,1  ;raise sum         ;/
 add  r1,sgWifiAp_size  ;\
 subs r2,1              ; lop next
 bne  @@lop             ;/
 bx   lr     ;out: r0=sum (number of active access point entries)
;------------------
arm9_Wifi_DisconnectAP:  ;in: none, out: r0
 ldr  r1,=WifiData_reqMode      ;\
 mov  r0,WIFIMODE_NORMAL        ;
 strh r0,[r1]                   ;/
 ldr  r1,=WifiData_reqReqFlags  ;\
 ldrh r0,[r1]                   ;
 bic  r0,WFLAG_REQ_APCONNECT    ;
 strh r0,[r1]                   ;/
 ldr  r1,=WifiData_flags9       ;\
 ldr  r0,[r1]                   ;
 bic  r0,WFLAG_ARM9_NETREADY    ;
 str  r0,[r1]                   ;/
 ldr  r1,=wifi_connect_state    ;\
 mov  r0,-1                     ;
 str  r0,[r1]                   ;/
 mov  r0,0      ;out: r0=0 (always)
 bx   lr
;------------------
arm9_Wifi_GetAPData:  ;in: r0=src.apnum, r1=dst.WifiAp, out: r0
 ;CHAOS: original code uses quite misleading indent (the lines after the "while"
 ;statement are NOT part of the single-line "while" statement)
 ;- - -
 ;note: original code wants an INDEX in WifiData_aplist, ASM port uses a PTR
 ;- - -
 push r4-r5,lr
 mov  r4,r0    ;src (ptr to a "WifiData_aplist" entry)
 movs r5,r1    ;dst                     ;\
 moveq r0,WIFI_RETURN_PARAMERROR        ; fail if DST is zero
 beq   @@return_r0                      ;/
 ldrh r0,[r4,sgWifiAp_flags]            ;\
 tst  r0,WFLAG_APDATA_ACTIVE            ; fail if SRC is not active
 moveq r0,WIFI_RETURN_ERROR             ;    XXXX returns GARBAGE at DST !!!
 beq   @@return_r0                      ;/
@@wait_lop:                             ;\
 mov  r0,r4                             ; lock access point to ARM9
 bl   arm9_Spinlock_Acquire             ; (wait if it's currently
 cmp  r0,SPINLOCK_OK                    ; locked to ARM7)
 bne  @@wait_lop                        ;/
 mov  r0,0  ;initial sum                ;\
 add  r1,r4,sgWifiAp_rssi_past ;src     ;
 mov  r2,8                     ;len     ;
@@lop:                                  ; additionally calculate
 ldrb r3,[r1],1  ;rssi_past[0..7]       ; average RSSI here
 add  r0,r3   ;raise sum                ;
 subs r2,1                              ;
 bne  @@lop                             ;
 mov  r0,r0,lsr 3   ;sum/8              ;
 strh r0,[r4,sgWifiAp_rssi]    ;sum     ;/
 mov  r0,r4               ;sgWifiAp.src ;\
 mov  r1,r5               ;sgWifiAp.dst ; copy the access point data to dest
 mov  r2,sgWifiAp_size             ;len ;
 bl   memcopy_bytewise                  ;/
 mov  r0,r4                             ;\release
 bl   arm9_Spinlock_Release             ;/
 mov  r0,WIFI_RETURN_OK                 ;-okay
@@return_r0:
 pop  r4-r5,pc
;------------------
arm9_Wifi_FindMatchingAP:  ;in: r0=numaps, r1=WifiAp/WifiWfc, r2=WifiAp_dest, out: r0
 ;note: the list with incoming access point(s) can either,
 ;  one         "WifiAp" structure   (eg. selected from received beacons), or
 ;  one or more "WifiWfc" structures (from "WFC" in WifiFLASH)
 ;the "WifiWfc" structure does internally contain a "WifiAp" structure, so
 ;the search code works same for both structure types, the important difference
 ;is that "WifiWfc" is bigger than "WifiAp", and the stepping for numaps>1 is
 ;using the "WifiWfc_size" as offset to next list entry.
 ;- - -
 ;returned are TWO things:
 ;  r0      points to the matching WifiWfc entry for incoming WFC list (-1=none)
 ;  [dest]  contains a copy of the WifiAp data from received beacon list
 ;the "WifiWfc" stuff does also contain "WifiAp" stuff, but that shouldn't be
 ;used upon return (among others because it's incomplete: contains only the
 ;SSID name, but not the BSSID address), INSTEAD, one should use the WifiAp
 ;copy at [dest].
 ;note: original code returned an INDEX in r0, the ASM port returns a PTR in r0
 ;- - -
 push r4-r11,lr
 sub  sp,sgWifiAp_size  ;alloc WifiAp.temp
 mov  r4,r0  ;numaps
 mov  r5,r1  ;WifiAp.src[numaps=1], or WifiWfc.[numaps]
 mov  r6,r2  ;WifiAp.dest
 mov  r7,-1 ;WifiWfc.match ;FFFFFFFFh   ;-intially no match
 bl   arm9_Wifi_GetNumAP                ;\
 movs r9,r0  ;num beacons               ; search received beacons (WifiAp's)
 beq  @@beacon_lop_done                 ;
 ldr  r8,=WifiData_aplist               ;
@@beacon_lop:                           ;/
 mov  r0,r8  ;WifiData_aplist[N]        ;\
 mov  r1,sp  ;WifiAp.temp               ; WifiAp.temp = WifiData_aplist[N]
 bl   arm9_Wifi_GetAPData               ;/
 mov  r11,r4 ;numaps                    ;\search incoming WifiWfc FLASH list
 mov  r10,r5 ;WifiWfc.src[numaps]       ; (or incoming single WifiAp)
@@flash_lop:                            ;/
 ldrb r0,[r10,sgWifiAp_ssid_len];flash  ;\
 cmp  r0,0                      ;zero   ;
 beq  @@no_ssid                         ;
 ldrb r2,[sp,sgWifiAp_ssid_len] ;beacon ;
 cmp  r2,r0                     ;flash  ; want matching SSID
 bne  @@no_match  ;different len        ; (or zero SSID... uh, WITHOUT SSID ?)
 cmp  r2,32                             ;
 bhi  @@no_match  ;too long len         ;
@@compare_ssid_lop:                     ;
 add  r0,r10,sgWifiAp_ssid      ;flash  ;
 add  r1,sp,sgWifiAp_ssid       ;beacon ;
;mov  r2,r2                     ;len    ;
 bl   memcompare_bytewise               ;
 cmp  r2,0   ;0=match (len=0)           ;
 bne  @@no_match                        ;
@@no_ssid:                              ;/
 ldr  r0,=const_000000000000h  ;zero    ;\
 add  r1,r10,sgWifiAp_macaddr  ;flash   ;
 bl   arm9_Wifi_CmpMacAddr              ;
 cmp  r0,0                              ; want matching MAC addr
 bne  @@no_mac_addr                     ; (or zero MAC addr)
 add  r0,sp,sgWifiAp_macaddr   ;beacon  ;
 add  r1,r10,sgWifiAp_macaddr  ;flash   ;
 bl   arm9_Wifi_CmpMacAddr              ;
 cmp  r0,0                              ;
 beq  @@no_match                        ;
@@no_mac_addr:                          ;/
 ldrb r0,[r10,sgWifiAp_channel] ;flash  ;\
 cmp  r0,0                      ;zero   ;
 beq  @@no_channel                      ; want matching channel
 ldrb r1,[sp,sgWifiAp_channel]  ;beacon ; (or zero channel)
 cmp  r0,r1                     ;flash  ;
 bne  @@no_match                        ;
@@no_channel:                           ;/
;- - -
 mov  r0,sp         ;sgWifiAp from RECEIVED BEACON      ;\
 mov  r1,r10        ;sgWifiWfc from Wifi-FLASH          ;
 bl   determine_crypto                                  ;
 beq  @@no_match                                        ;/
;- - -
 cmp  r7,r10 ;WifiWfc.match curr.Wfc    ;\in case of multiple matches, prefer
 bls  @@no_match                        ;/the first WFC entry as most-wanted
;- - - okay, accept match
 mov  r7,r10 ;WifiWfc.match (return value)      ;-return ptr to WifiWfc (FLASH)
 mov  r0,sp  ;WifiAp.temp (beacon) ;src         ;\
 mov  r1,r6  ;WifiAp.dest          ;dst         ; return copy of WifiAp (beacon)
 mov  r2,sgWifiAp_size  ;len                    ; (with BSSID, etc, which is NOT found in FLASH)
 bl   memcopy_bytewise                          ;/
    ldr  r1,=WifiData_curr_AP       ;\XXX this works only if the entry isn't
    str  r8,[r1]                    ;/    re-allocated for use by another AP
;keep searching, in case beacon for an earlier (more preferred) WFC entry exists
@@no_match:
 add  r10,sgWifiWfc_size ;WFC(!);\next entry, eg. incoming FLASH entry(s)
 subs r11,1 ;numaps             ; (this loop works only if the list contains
 bne  @@flash_lop               ;/"WifiWfc" entries, not "WifiAp" entries!
 add  r8,sgWifiAp_size  ;AP(!)  ;\
 subs r9,1  ;num beacons        ; next entry in "received beacon" list
 bne  @@beacon_lop              ;/
@@beacon_lop_done:
 mov  r0,r7  ;WifiWfc.match             ;-return WifiWfc ptr (or -1=none)
 add  sp,sgWifiAp_size  ;dealloc WifiAp.temp
 pop  r4-r11,pc
;------------------
determine_crypto:          ;in: r0=sgWifiAp/beacon, r1=sgWifiWfc/flash
 push r4-r9,lr
 mov  r4,r0     ;sgWifiAp from RECEIVED BEACON
 mov  r5,r1     ;sgWifiWfc from Wifi-FLASH
 ldr  r6,[r4,sgWifiAp_rsnie_wpa2]       ;\                              ;\
 mov  r7,EAPOL_TYPE_WPA2                ; try WPA2, preferred           ;
 bl   @@try_this                        ;                               ;
 bne  @@use_this_eapol                  ;/                              ; EAPOL
 ldr  r6,[r4,sgWifiAp_rsnie_wpa]        ;\                              ;
 mov  r7,EAPOL_TYPE_WPA                 ; try WPA, alternate            ;
 bl   @@try_this                        ;                               ;
 bne  @@use_this_eapol                  ;/                              ;
 ldr  r0,[r4,sgWifiAp_rsnie_wpa]        ;\refuse if RSNIE(s) were       ;
 ldr  r1,[r4,sgWifiAp_rsnie_wpa2]       ; nonzero,                      ;
 orrs r0,r1                             ; but unsupported by console    ;
 bne  @@refuse                          ;/                              ;/
 mov  r7,EAPOL_TYPE_NONE                ;-else no EAPOL (for Open/WEP)  ;\
 ldr   r0,[r4,sgWifiAp_flags]   ;\                                      ;
 tst   r0,WFLAG_APDATA_WEP      ; open or wep                           ; OPEN
 moveq r0,KEY_TYPE_NONE         ; (depending on capability flags)       ; or WEP
 movne r0,KEY_TYPE_WEP          ;/                                      ;
 .if insist_on_selected_cipher                                          ;
   ldrb  r3,[r5,sgWifiWfc_wpamode] ;flash   ;\reject open/wep           ;
   cmp   r3,0                               ; if wpa/wpa2 selected      ;
   bne   @@refuse                           ;/                          ;
   ldrb  r3,[r5,sgWifiWfc_wepmode] ;flash   ;\                          ;
   cmp   r3,0                               ;                           ;
   moveq r3,KEY_TYPE_NONE                   ; insist on open/wep        ;
   movne r3,KEY_TYPE_WEP                    ; respectively              ;
   cmp   r3,r0                              ;                           ;
   bne   @@refuse                           ;/                          ;
 .endif                                                                 ;
;XXX .if insist_on_minimum_cipher --> reject AP=WEP with FLASH having empty WEP-password entry
;XXX .if insist_on_minimum_cipher --> reject AP=open with FLASH=NotOpen
;XXX .if insist_on_minimum_cipher --> reject AP=WEP with FLASH=WPA/WPA2
 mov   r8,r0  ;group key                                                ;
 mov   r9,r0  ;pairwise key                                             ;/
 b     @@use_this_eapol
;---
@@refuse:
 mov  r7,EAPOL_TYPE_ERROR
 mov  r8,KEY_TYPE_ERROR
 mov  r9,KEY_TYPE_ERROR
@@use_this_eapol:
;- - -
@@finish:
 strb  r7,[r5,sgWifiWfc_eapol]          ;-apply EAPOL type              ;\
 strb  r8,[r5,sgWifiWfc_grp]            ;-apply GROUP key type          ; apply
 strb  r9,[r5,sgWifiWfc_pair]           ;-apply PAIRWISE key type       ;/
 cmp   r7,EAPOL_TYPE_ERROR   ;out: EQ=bad, NE=okay
 pop   r4-r9,pc
;--- --- ---
@@try_this:    ;in: r6=RSNIE flags, r7=EAPOL type, r5 - out: zf,r0,r8,r9
 mov  r0,r6  ;rsnie
 .if with_nds_wifi AND with_dsi_wifi      ;\
   ldr  r3,=dsi_wifi_flag                 ;
   ldrb r3,[r3]                           ; for NDS-wifi:
   cmp  r3,0                              ; mask-off AES (and TKIP, unless supporting that someday)
   bne  @@dsi                             ;
 .endif                                   ;
 .if with_nds_wifi                        ;
  @@nds:                                  ;
   bic  r0,RSNIE_PAIR_AES+RSNIE_GRP_AES   ; <-- AES not supported by NDS hardware
  ;XXX with_nds_wpa...                    ;
   bic  r0,RSNIE_PAIR_TKIP+RSNIE_GRP_TKIP ; <-- TKIP not (yet) supported by NDS software
  @@dsi:                                  ;
 .endif                                   ;/
 ;- - -
 .if insist_on_selected_cipher                          ;\
   ldrb  r3,[r5,sgWifiWfc_wpamode] ;flash               ; for insistive: mask-off anything not explicitely selected in wifi-flash
   cmp   r3,4  ;WPA-TKIP                                ; ;\
   cmpne r3,5  ;WPA2-TKIP                               ; ; insist on TKIP only
   andeq r0,RSNIE_PAIR_TKIP+RSNIE_GRP_TKIP              ; ;/
   cmp   r3,6  ;WPA-AES                                 ; ;\insist on AES only
   cmpne r3,7  ;WPA2-AES                                ; ; (except, can allow
   andeq r0,RSNIE_PAIR_AES+RSNIE_GRP_AES+RSNIE_GRP_TKIP ; ;/TKIP as GROUP key)
   cmp   r3,4  ;WPA-TKIP                                ; ;\
   cmpne r3,6  ;WPA-AES                                 ; ;
   moveq r2,EAPOL_TYPE_WPA                              ; ; insist on WPA/WPA2
   movne r2,EAPOL_TYPE_WPA2                             ; ; respectively
   cmp   r2,r7                                          ; ;
   movne r0,RSNIE_NULL                                  ; ;/
 .endif                                                 ;/
 ;- - -
 ldrb  r3,[r5,sgWifiWfc_wpamode] ;flash   ;\
 cmp   r3,0     ;WEP/OPEN (no WPA/WPA2)   ; for all wifi: mask-off AES+TKIP
 biceq r0,RSNIE_PAIR_AES+RSNIE_GRP_AES    ; if password isn't in wifi-flash
 biceq r0,RSNIE_PAIR_TKIP+RSNIE_GRP_TKIP  ;/
;XXX .if insist_on_minimum_cipher: allow above also if FLASH=Open/WEP (but detect/insist on PSK being defined in FLASH) (ie. detect if PSK=zerofilled, instead of checking wpamode=zero)
 ;- - -
 tst   r0,RSNIE_GRP_AES+RSNIE_GRP_TKIP    ;\want a working GROUP key, AND also
 tstne r0,RSNIE_PAIR_AES+RSNIE_PAIR_TKIP  ; want a working PAIRWISE key
 moveq r0,RSNIE_NULL   ;oops, no pair     ;/
 ;- - -
 tst   r0,RSNIE_GRP_TKIP  ;\    ;\                                      ;\
 movne r8,KEY_TYPE_TKIP   ;/    ; AES or TKIP                           ; GROUP
 tst   r0,RSNIE_GRP_AES   ;\    ; (depending on RSNIE flags)            ; KEY
 movne r8,KEY_TYPE_AES    ;/    ;/                                      ;/
 tst   r0,RSNIE_PAIR_TKIP ;\    ;\                                      ;\PAIR-
 movne r9,KEY_TYPE_TKIP   ;/    ; AES or TKIP                           ; WISE
 tst   r0,RSNIE_PAIR_AES  ;\    ; (depending on RSNIE flags)            ; KEY
 movne r9,KEY_TYPE_AES    ;/    ;/                                      ;/
 cmp   r0,RSNIE_NULL  ;\out: EQ=not accepted, NE=okay
 bx    lr             ;/
;------------------
arm9_Wifi_ApplyBeaconInfoFromWifiAP:
 push r4,lr
 mov  r4,r0  ;WifiAp
 add  r0,r4,sgWifiAp_bssid         ;src ;\
 ldr  r1,=WifiData_bssid9          ;dst ; apply BSSID
 bl   arm9_Wifi_CopyMacAddr             ;/
 add  r0,r4,sgWifiAp_bssid         ;src ;\
;add  r0,r4,sgWifiAp_macaddr ;<-- this better?
 ldr  r1,=WifiData_apmac9          ;dst ; apply APMAC (uh, from BSSID, too?)
 bl   arm9_Wifi_CopyMacAddr             ;/  (or should this be from "sgWifiAp_macaddr"?)
 add  r0,r4,sgWifiAp_ssid          ;src ;\
 ldr  r1,=WifiData_ssid9           ;dst ;
 ldrb r2,[r4,sgWifiAp_ssid_len]    ;len ; apply SSID string (and SSID len)
 strb r2,[r1],1        ;dst[0]=len      ;
 bl   memcopy_bytewise ;dst[1..N]=ssid  ;/
 ldrb r0,[r4,sgWifiAp_channel]          ;\
 ldr  r1,=WifiData_apchannel9           ; apply channel
 strb r0,[r1]                           ;/
 add  r0,r4,sgWifiAp_base_rates    ;src ;\
 ldr  r1,=WifiData_baserates9      ;dst ; apply base rates
 mov  r2,16                        ;len ;
 bl   memcopy_bytewise ;dst[1..N]=ssid  ;/
 .if 1
   ldr  r1,=txt_chipset         ;\
   bl   wrstr_r1                ; Chipset
   .if with_nds_wifi AND with_dsi_wifi
     ldr  r1,=dsi_wifi_flag     ;
     ldrb r0,[r1]               ;
     cmp  r0,0                  ;
     bne  @@dsi                 ;
   .endif                       ;
   .if with_nds_wifi            ;
    @@nds:                      ; ;\
     ldr  r1,=txt_chipset_nds   ; ;
     bl   wrstr_r1              ; ; NDS
     bl   wrspc                 ; ;
     ldr  r1,=nds_wifi_chip_id  ; ; ;\
     ldrh r0,[r1]               ; ; ; Chip ID (1440h=DS, C340h=DS-Lite)
     bl   wrhex16bit            ; ; ;/
     ldr  r1,=txt_bb_rf_type    ; ; ;\
     bl   wrstr_r1              ; ; ;
     ldr  r1,=nds_wifi_bb_rf_type ; ; BB/RF chip type (02h/03h/05h)
     ldrh r0,[r1]               ; ; ;
     bl   wrhexdigit            ; ; ;/
     b    @@chipset_done        ; ;/
   .endif                       ;
   .if with_dsi_wifi            ;
    @@dsi:                      ; ;\
     ldr  r1,=txt_chipset_dsi   ; ; DSi
     bl   wrstr_r1              ; ;
     bl   wrspc                 ; ;
     ldr  r1,=sdio_chip_id      ; ; ;\
     ldr  r0,[r1]               ; ; ; Chip ID (AR60xx)
     bl   wrhex32bit            ; ; ;/
     b    @@chipset_done        ; ;/
   .endif                       ;
  @@chipset_done:               ;/
   bl   wrcrlf
   ldr  r1,=txt_mac             ;\
   bl   wrstr_r1                ; MAC
   ldr  r1,=WifiData_MacAddr    ;
   bl   wrmacaddr_from_r1       ;/
   bl   wrcrlf
   ldr  r1,=txt_bssid           ;\
   bl   wrstr_r1                ; BSSID
   ldr  r1,=WifiData_bssid9     ;
   bl   wrmacaddr_from_r1       ;/
   bl   wrcrlf
  ;ldr  r1,=txt_apmac           ;\
  ;bl   wrstr_r1                ; APMAC (same as BSSID)
  ;ldr  r1,=WifiData_apmac9     ;
  ;bl   wrmacaddr_from_r1       ;/
  ;bl   wrcrlf
   ldr  r1,=txt_ssid            ;\
   bl   wrstr_r1                ; SSID
   ldr  r1,=WifiData_ssid9      ;
   ldrb r2,[r1],1   ;len        ;
   cmp r2,0         ;len        ;
   blne   wrstr_r1_len_r2       ;/
   bl   wrcrlf
   ldr  r1,=txt_channel         ;\
   bl   wrstr_r1                ; CHANNEL
   ldr  r1,=WifiData_apchannel9 ;
   ldrb r0,[r1]                 ;
   bl   wrdecimal               ;/
   bl   wrcrlf
   ldr  r1,=txt_rssi            ;\
   bl   wrstr_r1                ; RSSI (signal strength)
   ldr  r1,=vram_addr      ;\   ;
   ldr  r0,[r1]            ;    ;
   ldr  r1,=rssi_vram_addr ;    ;
   str  r0,[r1]            ;/   ;
   ldrh r0,[r4,sgWifiAp_rssi]   ;  (02h=MIN?, 146=high, 00h=MAX) (or is that 00h=uninit?)
   bl   wrdecimal               ;/
   bl   wrcrlf
   ldr  r1,=txt_crypt           ;\
   bl   wrstr_r1                ; CRYPT
   ldr  r2,=WifiData_eapol9 ;\  ;
   ldrb r2,[r2]             ;   ;
   cmp  r2,EAPOL_TYPE_WPA   ;   ;
   ldr  r1,=txt_crypt_wpa   ;   ;
   bleq wrstr_r1            ;/  ;
   ldr  r2,=WifiData_eapol9 ;\  ;
   ldrb r2,[r2]             ;   ;
   cmp  r2,EAPOL_TYPE_WPA2  ;   ;
   ldr  r1,=txt_crypt_wpa2  ;   ;
   bleq wrstr_r1            ;/  ;
   ldr   r0,=WifiData_pair9 ;\  ;
   ldrb  r0,[r0]            ;   ;
   ldr   r1,=txt_crypt_oops ;   ;
   cmp   r0,KEY_TYPE_NONE   ;   ;
   ldreq r1,=txt_crypt_open ;   ;
   cmp   r0,KEY_TYPE_WEP    ;   ;
   ldreq r1,=txt_crypt_wep  ;   ;
   cmp   r0,KEY_TYPE_TKIP   ;   ;
   ldreq r1,=txt_crypt_tkip ;   ;
   cmp   r0,KEY_TYPE_AES    ;   ;
   ldreq r1,=txt_crypt_aes  ;   ;
   bl    wrstr_r1           ;/  ;
   ldr   r1,=WifiData_pair9 ;\  ;
   ldrb  r1,[r1]            ;   ;
   ldr   r0,=WifiData_grp9  ;   ;
   ldrb  r0,[r0]            ;   ;
   cmp   r0,r1              ;   ;
   beq   @@same_key_type    ;/  ;
   mov   r0,'/'             ;\  ;
   bl    wrchr_r0           ;/  ;
   ldr   r0,=WifiData_grp9  ;\  ;
   ldrb  r0,[r0]            ;   ;
   cmp   r0,r1              ;   ;
   ldr   r1,=txt_crypt_oops ;   ;
   cmp   r0,KEY_TYPE_NONE   ;   ;
   ldreq r1,=txt_crypt_open ;   ;
   cmp   r0,KEY_TYPE_WEP    ;   ;
   ldreq r1,=txt_crypt_wep  ;   ;
   cmp   r0,KEY_TYPE_TKIP   ;   ;
   ldreq r1,=txt_crypt_tkip ;   ;
   cmp   r0,KEY_TYPE_AES    ;   ;
   ldreq r1,=txt_crypt_aes  ;   ;
   bl    wrstr_r1           ;/  ;
  @@same_key_type:              ;/
   .if 01
     bl   wrspc
    ;ldr  r1,=txt_rsnie_wpa       ;\
    ;bl   wrstr_r1                ; RSNIE WPA
     ldr  r0,=WifiData_rsnie9_wpa ;
     ldr  r0,[r0]                 ;
     bl   wrhex8bit               ;/
     bl   wrspc
    ;ldr  r1,=txt_rsnie_wpa2      ;\
    ;bl   wrstr_r1                ; RSNIE WPA2
     ldr  r0,=WifiData_rsnie9_wpa2;
     ldr  r0,[r0]                 ;
     bl   wrhex8bit               ;/
   .endif
   bl   wrcrlf
   ldr  r1,=txt_domain          ;\
   bl   wrstr_r1                ; REG_DOMAIN
   ldr  r0,=WifiData_reg_domain ;
   ldrh r0,[r0]                 ;
   bl   wrhex16bit              ;/
   bl   wrspc                   ;\
   ldr  r1,=WifiData_reg_channels         ;\enabled channels
   ldr  r0,[r1]                 ;         ;/
   bl   wrhex16bit              ;/
;bl wrspc
;ldrb r0,[r4,sgWifiAp_rssi_past+0]
;bl   wrdecimal
;bl wrspc
;ldrb r0,[r4,sgWifiAp_rssi_past+1]
;bl   wrdecimal
;bl wrspc
;ldrb r0,[r4,sgWifiAp_rssi_past+2]
;bl   wrdecimal
   bl   wrcrlf
 .endif
 ldr  r1,=WifiData_reqMode                              ;\
 mov  r0,WIFIMODE_NORMAL                                ; set NORMAL mode
 strh r0,[r1]                                           ;/
 ldr  r1,=WifiData_reqReqFlags                          ;\
 ldrh r0,[r1]                                           ; flags
 orr  r0,WFLAG_REQ_APCONNECT+WFLAG_REQ_APCOPYVALUES     ;
 strh r0,[r1]                                           ;/
 ldr  r1,=wifi_connect_state                            ;\
 mov  r0,1                                              ; state = 1
 str  r0,[r1]                                           ;/
 pop  r4,pc
;---
.pool
;---
txt_ip        db 'LOCAL IP  : ',0
txt_remote_ip db 'REMOTE IP : ',0
txt_subnet    db 'SUBNET    : ',0
txt_gateway   db 'GATEWAY   : ',0
txt_dns       db 'DNS       : ',0
txt_mac     db 'MAC:   ',0
txt_bssid   db 'BSSID: ',0
;txt_apmac   db 'APMAC: ',0
txt_ssid    db 'SSID:  ',0
txt_channel db 'CHANNEL:',0
txt_rssi    db 'RSSI:   ',0
txt_crypt   db 'CRYPT:  ',0
txt_domain  db 'DOMAIN: ',0
;txt_rsnie_wpa  db 'RSNIE WPA  :',0
;txt_rsnie_wpa2 db 'RSNIE WPA2 :',0
txt_dhcp    db 'DHCP...',0dh,0
txt_chipset     db 'INTERFACE: ',0
txt_chipset_nds db 'NDS',0
txt_chipset_dsi db 'DSi',0
txt_crypt_oops  db '???',0
txt_crypt_open  db 'OPEN',0
txt_crypt_wep   db 'WEP',0
txt_crypt_tkip  db 'TKIP',0
txt_crypt_aes   db 'AES',0
txt_crypt_wpa   db 'WPA-',0
txt_crypt_wpa2  db 'WPA2-',0
txt_bb_rf_type  db ' BB/RF:',0
  ;XXXX WEP flag
  ;XXXX rate (and rateset)

.align 4
;------------------
.if with_gimmicks
arm9_Wifi_ConnectAP:  ;in: r0=WifiAp, r1=wepmode, r2=wepkeyid, r3=wepkey, out: r0
 push r4-r7,lr
 sub  sp,sgWifiAp_size  ;alloc WifiAp.temp
 mov  r4,r0  ;WifiAp.wanted
 mov  r5,r1  ;wepmode
 mov  r6,r2  ;wepkeyid
 mov  r7,r3  ;wepkey
 ldr  r1,=wifi_connect_state            ;\
 mov  r0,-1                             ; state = -1
 str  r0,[r1]                           ;/
 mov  r0,-1                             ;\
 cmp  r4,0   ;WifiAp.wanted             ;
 beq  @@return_r0  ;out: r0=-1 = fail   ; fail if WifiAp.wanted
 ldrb r1,[r4,sgWifiAp_ssid_len]         ; is missing/bad
 cmp  r1,32                             ;
 bhi  @@return_r0  ;out: r0=-1 = fail   ;/
 bl   arm9_Wifi_DisconnectAP            ;-disconnect old
 ldr  r1,=wifi_connect_state            ;\
 mov  r0,0                              ; state = 0
 str  r0,[r1]                           ;/
.errif with_dsi_wifi  ;also need psk9, and rsnie9_wpa, rsnie9_wpa2, eapol9, grp9, pair9
 ldr  r1,=WifiData_wepmode9             ;\apply wepmode
 strb r5,[r1]                           ;/
 ldr  r1,=WifiData_wepkeyid9            ;\apply wepkeyid
 strb r6,[r1]                           ;/
 cmp  r5,0   ;wepmode                   ;\
 cmpne r6,0  ;wepkey                    ;
 movne r0,r6                       ;src ; apply wepkey, if any
 ldrne r1,=WifiData_wepkey9        ;dst ; (if mode<>0 and key<>0)
 movne r2,20                       ;len ;
 blne  memcopy_bytewise                 ;/
;- - -
 mov  r0,1  ;numaps                     ;\
 mov  r1,r4 ;WifiAp.wanted              ;
 mov  r2,sp ;WifiAp.temp (dst)          ; get info for the desired AP
 bl   arm9_Wifi_FindMatchingAP          ; (from received beacon list)
 cmp  r0,-1                             ;
 beq  @@no_beacon_found                 ;/
;- - - okay, have beacon info, apply it...
 mov  r0,sp  ;WifiAp                            ;\
 bl   arm9_Wifi_ApplyBeaconInfoFromWifiAP       ;/
 b    @@done_return_0  ;okay (all fine)
;---
@@no_beacon_found:
;okay, no beacon info available yet, so important info like BSSID is still
;missing - anyways, don't give up, and start scanning for that info...
 ldr  r1,=WifiData_reqMode              ;\
 mov  r0,WIFIMODE_SCAN                  ; set SCAN mode
 strh r0,[r1]                           ;/
 mov  r0,r4  ;WifiAp.wanted        ;src ;\
 ldr  r1,=wifi_connect_point       ;dst ; memorize the desired WifiAp
 mov  r2,sgWifiAp_size             ;len ;
 bl   memcopy_bytewise                  ;/
;b    @@done_return_0  ;okay (although still incomplete)
@@done_return_0:
 mov  r0,0             ;okay
@@return_r0:   ;out: r0 (0=okay, or -1=failed)
 add  sp,sgWifiAp_size  ;dealloc WifiAp.temp
 pop  r4-r7,pc
.endif
;------------------
.if with_dns
sgIP_DNS_Record_Localhost:  ;in/out: none  ;"static"
;create a DNS record for the local console itself...
 ;- - -
 ;uh, why is this in "wifi_arm9.c"? shouldn't it better be in "sgIP_DNS.c"? XXXX
 ;- - -
 ;uh, original code is is calling this function ONLY after DHCP (ie. NOT when
 ;connecting without DHCP, eg. in cases when WFC/WifiFLASH contains a fixed IP)
 ;that's somewhat wrong... BUT there MIGHT be cases where one NEEDS to OMIT
 ;this (eg. when re-connecting, then one should NOT create a new local record)?
 ;- - -
 push r4,lr
 bl   sgIP_DNS_GetUnusedRecord          ;\alloc DnsRec
 mov  r4,r0  ;DnsRec                    ;/
 mov  r0,SGIP_DNS_FLAG_ACTIVE+SGIP_DNS_FLAG_BUSY   ;notyet resolved...  ;\flags
 str  r0,[r4,sgDnsRec_flags]                                            ;/
 mov  r0,4                              ;\init addrlen
 strh r0,[r4,sgDnsRec_addrlen]  ;=4     ;/
 mov  r0,1                              ;\
 str  r0,[r4,sgDnsRec_numalias] ;=1     ; init numalias and numaddr
 str  r0,[r4,sgDnsRec_numaddr]  ;=1     ;/
 add  r0,r4,sgDnsRec_aliases+0 ;alias[0];\          ;\
 mov  r1,256                   ;len     ; alias[0]  ; apply hostname as
 bl   gethostname                       ;/          ; name/alias, ie. usually:
 add  r0,r4,sgDnsRec_name      ;name    ;\          ; SGIP_DHCP_DEFAULTHOSTNAME
 mov  r1,256                   ;len     ; name      ; aka "NintendoDS",0
 bl   gethostname                       ;/          ;/
 ldr  r1,=wifi_hw                       ;\
 ldr  r1,[r1]  ;HubHwi                  ; addr[0]=IP (from HubHwi)
 ldr  r0,[r1,sgHubHwi_ipaddr]           ;
 str  r0,[r4,sgDnsRec_addrdata+0]       ;/
 mov  r0,AF_INET                        ;\init addrclass
 strh r0,[r4,sgDnsRec_addrclass]        ;/
 mov  r0,0                              ;\init time-to-live
 str  r0,[r4,sgDnsRec_TTL]              ;/
 mov  r0,SGIP_DNS_FLAG_ACTIVE+SGIP_DNS_FLAG_BUSY+SGIP_DNS_FLAG_RESOLVED ;\flags
 str  r0,[r4,sgDnsRec_flags]    ;still/permanently "busy" (!)           ;/
 pop  r4,pc
.endif
;------------------
arm9_Wifi_AssocStatus:  ;in: none, out: r0=ASSOCSTATUS_xxx
 ldr  r0,=wifi_connect_state
 ldr  r0,[r0]
 cmp  r0,0  // beq @@connect_state_0_searching
 cmp  r0,1  // beq @@connect_state_1_associating
 cmp  r0,2  // beq @@connect_state_2_dhcp_ing
 cmp  r0,3  // beq @@connect_state_3_connected
 cmp  r0,4  // beq @@connect_state_4_search_wfc
;cmp  r0,-1 // beq @@connect_state_error
;cmp  r0,xx // beq @@connect_state_undefined_state
;- - - - - -
@@connect_state_error:             ;<--can happen
@@connect_state_undefined_state:   ;<--shouldn't happen
 mov  r0,ASSOCSTATUS_CANNOTCONNECT
 bx   lr
;--- --- --- ------
@@connect_state_3_connected:
 mov  r0,ASSOCSTATUS_ASSOCIATED
 bx   lr
;--- --- --- ------
@@connect_state_0_searching:  ;search SPECIFIC access point (wifi_connect_point)
 push lr                                     ;\
 sub  sp,sgWifiAp_size  ;alloc WifiAp.temp   ;
 mov  r0,1                                   ;  ;\
 ldr  r1,=wifi_connect_point                 ;  ;
 mov  r2,sp  ;WifiAp.temp (dest)             ;  ; check if desired beacon info
 bl   arm9_Wifi_FindMatchingAP               ;  ; has showed up meanwhile
 cmp  r0,-1                                  ;  ;
 beq  @@no_beacon_found_for_search_specific  ;  ;/
 mov  r0,sp  ;WifiAp.temp (src)              ;  ;\okay, apply beacon info
 bl   arm9_Wifi_ApplyBeaconInfoFromWifiAP    ;  ;/
@@no_beacon_found_for_search_specific:       ;
 add  sp,sgWifiAp_size  ;dealloc WifiAp.temp ;
 mov  r0,ASSOCSTATUS_SEARCHING               ;
 pop  pc                                     ;/
;--- --- --- ------
@@connect_state_4_search_wfc:  ;search nintendo WFC data for a suitable AP
 push r4-r5,lr
 sub  sp,sgWifiAp_size  ;alloc WifiAp.temp
 mov  r0,0                 ;src.num             ;\
 ldr  r1,=WifiData_wfc_ap                       ;
 mov  r2,3  ;max                                ;
@@count_wfc_ap_lop:                             ; count num used entries
 ldrb r3,[r1,sgWifiWfc_enable]                  ; in WFC (WifiFLASH data)
 tst  r3,80h                                    ;
 addne r0,1                ;src.num             ;
 addne r1,sgWifiWfc_size                        ;
 subs r2,1                                      ;
 bne  @@count_wfc_ap_lop                        ;/
;mov  r0,r0                ;src.num             ;\
 ldr  r1,=WifiData_wfc_ap  ;src.list            ;
 mov  r2,sp  ;WifiAp.temp (dest)                ; check if beacon info for a
 bl   arm9_Wifi_FindMatchingAP                  ; WFC has showed up meanwhile
 cmp  r0,-1                                 ;r0 ;
 beq  @@no_beacon_found_for_search_wfc          ;/
;- - -
 mov  r5,r0  ;=WifiData_wfc_ap+NNN          ;r0 ;\
 .ifdef WIFI_USE_TCP_SGIP                       ;
   ldr  r0,[r5,sgWifiWfc_ip]            ;\      ;
   ldr  r1,[r5,sgWifiWfc_gateway]       ;       ; okay, apply WFC data
   ldr  r2,[r5,sgWifiWfc_subnet]        ;       ;
   ldr  r3,[r5,sgWifiWfc_1st_dns]       ;       ;
   ldr  r4,[r5,sgWifiWfc_2nd_dns]       ;       ;
   bl   arm9_Wifi_SetIP                 ;/      ;

       .if 0
        ldr  r1,=txt_ip
        bl   wrstr_r1
        ldr  r0,[r5,sgWifiWfc_ip]
        bl wripaddr
        bl   wrcrlf
        ldr  r1,=txt_subnet
        bl   wrstr_r1
        ldr  r0,[r5,sgWifiWfc_subnet]
        bl wripaddr
        bl   wrcrlf
       .endif

 .endif                                         ;
 ldrb r0,[r5,sgWifiWfc_wepmode]         ;-      ;
 ldr  r1,=WifiData_wepmode9             ;\wep   ;
 and  r2,r0,03h   ;bit0-1 = wepmode     ; mode  ;
 strb r2,[r1]                           ;/      ;
 ldr  r1,=WifiData_wepkeyid9            ;\      ;  ;\
 and  r0,70h      ;bit4-6 = wepkeyid    ; wep   ;  ; uh, but that 3bits
 mov  r0,r0,lsr 4 ;to bit0-2            ; id    ;  ;     are ALWAYS zero
 strb r0,[r1]                           ;/      ;  ;/
 add  r0,r5,sgWifiWfc_wepkey       ;src ;\      ;
 ldr  r1,=WifiData_wepkey9         ;dst ; wep   ;
 mov  r2,16                        ;len ; key   ;
 bl   memcopy_bytewise                  ;/      ;/
 .if with_dsi_wifi                              ;\
  ;ldrb r0,[r5,sgWifiWfc_wpamode]       ;\wpa   ;
  ;ldr  r1,=WifiData_wpamode9           ; mode  ;
  ;strb r0,[r1]                         ;/      ;

   ldrb r0,[r5,sgWifiWfc_eapol]         ;\eapol ;
   ldr  r1,=WifiData_eapol9             ; type  ;
   strb r0,[r1]                         ;/      ;
   ldrb r0,[r5,sgWifiWfc_grp]           ;\group ;
   ldr  r1,=WifiData_grp9               ; keytyp;
   strb r0,[r1]                         ;/      ;
   ldrb r0,[r5,sgWifiWfc_pair]          ;\pair- ;
   ldr  r1,=WifiData_pair9              ; wise  ;
   strb r0,[r1]                         ;/keytyp;

   add  r0,r5,sgWifiWfc_psk          ;src ;\    ;
   ldr  r1,=WifiData_psk9            ;dst ; wpa ;
   mov  r2,32                        ;len ; psk ;
   bl   memcopy_bytewise                  ;/    ;
   ldr  r0,[sp,sgWifiAp_rsnie_wpa]        ;\rsn ;  ;\
   ldr  r1,=WifiData_rsnie9_wpa           ; wpa ;  ; received settings
   str  r0,[r1]                           ;/    ;  ; from RAM (not from FLASH)
   ldr  r0,[sp,sgWifiAp_rsnie_wpa2]       ;\rsn ;  ;
   ldr  r1,=WifiData_rsnie9_wpa2          ; wpa2;  ;
   str  r0,[r1]                           ;/    ;  ;/
 .endif                                         ;/

 mov  r0,sp  ;WifiAp                            ;\okay, apply beacon info
 bl   arm9_Wifi_ApplyBeaconInfoFromWifiAP       ;/
@@no_beacon_found_for_search_wfc:
 add  sp,sgWifiAp_size  ;dealloc WifiAp.temp
 mov  r0,ASSOCSTATUS_SEARCHING
 pop  r4-r5,pc
;--- --- --- ------
@@connect_state_1_associating:
 ldr   r0,=WifiData_curMode     ;\handle cur mode...
 ldrh  r0,[r0]                  ;/
 cmp   r0,WIFIMODE_SCAN                 ;\scan
 beq   @@associating_is_scanning        ;/
 cmp   r0,WIFIMODE_ASSOCIATE            ;\associate
 beq   @@associating_is_associating     ;/
 cmp   r0,WIFIMODE_ASSOCIATED           ;\associated
 beq   @@associating_is_associated      ;/
 cmp   r0,WIFIMODE_CANNOTASSOCIATE      ;\
 moveq r0,ASSOCSTATUS_CANNOTCONNECT     ; cannot associate
 bxeq  lr                               ;/
;cmp   r0,WIFIMODE_DISABLED             ;\
;cmpne r0,WIFIMODE_NORMAL               ;
;cmpne r0,WIFIMODE_DISASSOCIATE         ; other --> disconnected
;cmpne r0,<other>                       ;
 mov   r0,ASSOCSTATUS_DISCONNECTED      ;
 bx    lr                               ;/
;---
@@associating_is_scanning:
 ldr   r0,=WifiData_reqReqFlags ;\
 ldrh  r0,[r0]                  ; test flag
 tst   r0,WFLAG_REQ_APCONNECT   ;/
 movne r0,ASSOCSTATUS_AUTHENTICATING
 moveq r0,ASSOCSTATUS_DISCONNECTED
 bx    lr
;---
@@associating_is_associating:
 ldr   r0,=WifiData_authlevel
 ldrh  r0,[r0]
 cmp   r0,WIFI_AUTHLEVEL_ASSOCIATED     ;\associated
 beq   @@associating_is_associated_now  ;/--> associated now
 cmp   r0,WIFI_AUTHLEVEL_AUTHENTICATED  ;\
 cmpne r0,WIFI_AUTHLEVEL_DEASSOCIATED   ; authenticated/deassociated
 moveq r0,ASSOCSTATUS_ASSOCIATING       ; --> associating
 bxeq  lr                               ;/
;cmp   r0,WIFI_AUTHLEVEL_DISCONNECTED   ;\disconnected/other
;cmpne r0,<other>                       ; --> still authenticating
 mov   r0,ASSOCSTATUS_AUTHENTICATING    ; (notyet associating)
 bx    lr                               ;/
;---
@@associating_is_associated:
@@associating_is_associated_now:
 .if with_dsi_wifi
  ;XXX somewhat prevent DHCP if 4-way handshake is busy...
   ldr  r1,=WifiData_4way_handshake_busy  ;\
   ldrb r1,[r1]                           ;/
   cmp  r1,0
  ;movne r0,ASSOCSTATUS_ASSOCIATED
  ;movne r0,ASSOCSTATUS_AUTHENTICATING
   movne r0,ASSOCSTATUS_ASSOCIATING     ;stay busy, don't try DHCP yet
   bxne lr
 .endif
 .ifdef WIFI_USE_TCP_SGIP
   ldr  r0,=wifi_hw                     ;\get HubHwi
   ldr  r0,[r0]  ;HubHwi                ;/
   cmp  r0,0     ;HubHwi                ;\uh, is it even possible to get here
   beq  @@associated_but_no_hw          ;/without hardware?
   ldr  r1,[r0,sgHubHwi_ipaddr]         ;\check if already having IP
   cmp  r1,0     ;IP                    ; (from WFC's "arm9_Wifi_SetIP")
   bne  @@associated_already_have_ip    ;/(if so, no DHCP needed)
        ;XXX with_warmboot_info --> re-use old DHCP settings

;XNAY        push r0-r12,lr
;XNAY        bl arm9_synctoarm7     ;XXXX
;XNAY        bl arm9_Wifi_Update    ;XXXX
;XNAY         bl   wait_VBlank  ;XXXX
;XNAY        pop  r0-r12,lr


   push lr  ;-->                        ;\ ;\
  ;ldr  r1,=txt_dhcp            ;\      ;  ;
  ;bl   wrstr_r1                ;/      ;  ;
  ;mov  r0,r0    ;HubHwi                ;  ;
   ldr  r1,[r0,sgHubHwi_dns+0]  ;dns[0] ;  ;
   cmp  r1,0                    ;dns[0] ;  ;
   moveq r1,1  ;getDNS=1                ;  ; DHCP start
   movne r1,0  ;getDNS=0                ;  ;
   bl   sgIP_DHCP_Start                 ;  ;
   pop  lr  ;<--                        ;  ;/
   ldr  r1,=wifi_connect_state          ;  ;\
   mov  r0,2                            ;  ; state = 2
   str  r0,[r1]                         ;  ;/
   mov  r0,ASSOCSTATUS_ACQUIRINGDHCP    ;  ;\done, return Acquiring DHCP
   bx   lr     ;-->                     ;/ ;/
  ;---
  @@associated_already_have_ip:
  @@dhcp_done_now_have_ip:
   push lr  ;-->                        ;\
                mov r0,1000000h
                @@lll:
                subs r0,1
                bne @@lll
   ldr  r0,=wifi_hw                     ; uh, original code is doing this
   ldr  r0,[r0]  ;HubHwi                ; even when HubHwi=0 (aka wifi_hw=0)
   bl   sgIP_ARP_SendGratARP            ;


        .if 0   ;XXX 123   ;XNAY
           ldr  r0,=wifi_hw                     ;
           ldr  r0,[r0]  ;HubHwi                ;
           bl   sgIP_ARP_SendGratARP            ;

           bl   arm7_disable_ime          ;\disable IME
           push r0   ;--->                ;/

           ldr  r0,=wifi_hw                     ;
           ldr  r0,[r0]  ;HubHwi                ;
           ldr  r1,=PROTOCOL_ETHER_IP
           ldr  r2,[r0,sgHubHwi_gateway]
           bl sgIP_ARP_SendARPRequest  ;in: r0=HubHwi, r1=protocol, r2=protocol_addr, out: r0

           ldr  r0,=wifi_hw                     ;
           ldr  r0,[r0]  ;HubHwi                ;
           ldr  r1,=PROTOCOL_ETHER_IP
           ldr  r2,[r0,sgHubHwi_gateway]
          ; add  r2,(29-1) shl 24   ;<-- this IP (the PC's IP) gets no reply??? (when DSi connected directly to zyxel router)
           bl sgIP_ARP_SendARPRequest  ;in: r0=HubHwi, r1=protocol, r2=protocol_addr, out: r0

           pop  r0   ;<---                ;\
           bl   arm7_restore_ime          ;/

           ldr  r0,=wifi_hw                     ;
           ldr  r0,[r0]  ;HubHwi                ;
           bl   sgIP_ARP_SendGratARP            ;
           ldr  r0,=wifi_hw                     ;
           ldr  r0,[r0]  ;HubHwi                ;
           bl   sgIP_ARP_SendGratARP            ;
        .endif

   ;note: The Grat isn't really required (and its response can be ignored)
   pop  lr  ;<--                        ;/
  @@associated_but_no_hw:
 .endif
 ldr  r1,=wifi_connect_state            ;\
 mov  r0,3                              ; state = 3
 str  r0,[r1]                           ;/
 ldr  r1,=WifiData_flags9               ;\
 ldr  r0,[r1]                           ; mark net ready
 orr  r0,WFLAG_ARM9_NETREADY            ;
 str  r0,[r1]                           ;/
.if with_dns
 push lr  ;-->                          ;\
 bl   sgIP_DNS_Record_Localhost         ; create local record
 pop  lr  ;<--                          ;/
.endif
 mov  r0,ASSOCSTATUS_ASSOCIATED         ;\associated
 bx   lr                                ;/
;--- --- --- ------
@@connect_state_2_dhcp_ing:
.ifdef WIFI_USE_TCP_SGIP
   push  lr  ;-->                   ;\
            .if 0   ;XNAY
             mov r0,'D' // bl wrchr_r0
             push r0-r12,lr
             bl arm9_synctoarm7     ;XXXX
             bl arm9_Wifi_Update    ;XXXX
              ;bl   wait_VBlank  ;XXXX
             pop  r0-r12,lr
            .endif
   bl    sgIP_DHCP_Update ;out: r0  ;
   pop   lr  ;<--                   ;/
   cmp   r0,SGIP_DHCP_STATUS_WORKING    ;\dhcp working (aka busy)
   moveq r0,ASSOCSTATUS_ACQUIRINGDHCP   ; --> still Acquiring DHCP
   bxeq  lr                             ;/
   cmp   r0,SGIP_DHCP_STATUS_SUCCESS    ;\check of dhcp done
   beq   @@dhcp_done_now_have_ip        ;/


       .if 0      ;XNAY
        mov r0,'-' // bl wrchr_r0
       .endif

.endif
;cmp   r0,SGIP_DHCP_STATUS_IDLE         ;\
;cmpne r0,SGIP_DHCP_STATUS_FAILED       ; dhcp idle/failed/other
;cmpne r0,<other>                       ;
 push  lr  ;-->                         ; ;\
 bl    arm9_Wifi_DisconnectAP           ; ; disconnect
 pop   lr  ;<--                         ; ;/
 ldr   r1,=wifi_connect_state           ; ;\
 mov   r0,-1                            ; ; state = -1
 str   r0,[r1]                          ; ;/
 mov   r0,ASSOCSTATUS_CANNOTCONNECT     ; ;\
 bx    lr                               ;/;/
;------------------
.ifdef WIFI_USE_TCP_SGIP
arm9_Wifi_TransmitFunction:  ;in: r0=HubHwi, r1=MemBlk, out: r0
 ;used via [sgHubHwi_TransmitFunction]=arm9_Wifi_TransmitFunction
 ;- - -
 ;convert ethernet frame into wireless frame and output.
 ;ethernet header: 6byte dest, 6byte src, 2byte protocol_id
 ;assumes individual pbuf len is >=14 bytes, it's pretty likely ;)
 ;also hopes pbuf len is a multiple of 2 :|
 ;- - -
 ;uh, who/what is that "pbuf"? probably the MemBlk, whereas, yes, it should
 ;contain at least 14 bytes (for the EthHdr), but, no, it doesn't need to be
 ;a multiple of 2 (the TOTAL length may be odd), however, if the MemBlk
 ;consists of multiple smaller MemBlk's, then the fragments MUST be even
 ;(only the LAST fragment may have ODD length)
 ;- - -
 ;uh, original code uses NUMERIC offsets to MemBlk's datastart (should better
 ;use the "sgEthHdr_dest_mac" and "sgEthHdr_protocol" structure indices)
 ;and, same for the ominous excluded "14" bytes and "7" halfwords: that
 ;should be "sgEthHdr_size" structure size
 ;- - -
 push r4-r12,lr
 sub  sp,48  ;alloc hdr buf (12+24+(4)+8 = 48)
;mov  r4,r0  ;HubHwi   ;<-- BLAH: not actually used anywhere in this function
 mov  r5,r1  ;MemBlk
 mov  r6,0008h  ;FC=data frame          ;-init Frame Control (FC)
 mov  r7,12+24+0+8        ;hdrlen       ;-init hdrlen
 ldr  r8,[r5,sgMemBlk_totallength]      ;\get framelen
 sub  r8,sgEthHdr_size    ;framelen     ;/
 .if with_dsi_wifi
   ldr  r0,=dsi_wifi_flag  ;\skip WEP on DSi
   ldrb r0,[r0]            ; (DSi is doing that automatically when needed)
   cmp  r0,0               ; (also skips further FC.WEP-related adjustments)
   bne  @@skip_wep_adjust  ;/
 .endif
 ldr  r0,=WifiData_wepmode7             ;\
 ldrb r0,[r0]                           ;
 cmp  r0,0                              ; adjust stuff for WEP
 addne r7,4     ;hdrlen+4   (WEP IV)    ;
 addne r8,4     ;framelen+4 (WEP FCS)   ;
 orrne r6,4000h ;FC.WEP     (WEP flag)  ;/
@@skip_wep_adjust:
 ldr  r0,=WifiData_curReqFlags          ;\
 ldrh r0,[r0]                           ; adjust stuff for NonAdhoc
 tst  r0,WFLAG_REQ_APADHOC              ;
 orreq r6,100h  ;NonAdhoc --> ToDS=1    ;/
 ldr  r0,=WifiData_flags9               ;\
 ldr  r0,[r0]                           ; fail if net down
 tst  r0,WFLAG_ARM9_NETUP               ;
 beq  @@fail_netdown                    ;/
 bl   arm9_Wifi_TxBufferWordsAvailable  ;\
 mov  r0,r0,lsl 1  ;mul2                ;
 add  r1,r7,r8     ;hdrlen+framelen     ; fail if not enough space
 cmp  r1,r0                             ;
 bhi  @@fail_no_space                   ;/
 ldr  r1,=WifiData_stats                ;\
 ldr  r0,[r1,WSTAT_TXQUEUEDPACKETS*4];\ ;
 add  r0,1                           ;  ;
 str  r0,[r1,WSTAT_TXQUEUEDPACKETS*4];/ ; raise stats
 ldr  r0,[r1,WSTAT_TXQUEUEDBYTES*4]  ;\ ;
 add  r0,r7  ;hdrlen                 ;  ;
 add  r0,r8  ;framelen               ;  ;
 str  r0,[r1,WSTAT_TXQUEUEDBYTES*4]  ;/ ;/
 mov  r0,'T'  ;aka Transmit             ;\
 ldr  r1,[r5,sgMemBlk_datastart] ;EthHdr; debug log transmitted EthHdr
 bl   arm9_ethhdr_print                 ;/
 add  r11,r7,r8     ;hdrlen+framelen    ;\calc expected num halfwords,
 add  r11,1         ;round up           ; and init copied num halfwords
 mov  r11,r11,lsr 1 ;expectedlen/2      ; (just for later error checking)
 mov  r12,0  ;copied/2=0 ;aka copytotal ;/
;- - - -
 mov  r1,sp  ;hdr buf                   ;-hdr buf
 mov  r0,0                              ;\
 str  r0,[r1],4 ;aka sgTxHdr_xx...      ; init TxHdr (12 bytes)
 str  r0,[r1],4                         ;
 strh r0,[r1],2 ;rate                   ;  ;<-- rate, will be filled in by the arm7.  uh, when/where? via WIFI_RAM at 0x4008 ?
 add  r2,r7,r8  ;hdrlen+framelen        ;
 add  r2,4-12                           ;
 strh r2,[r1],2 ;tx.len                 ;/
 strh r6,[r1],2 ;frame control (FC)     ;\ ;-
 mov  r0,0                              ; init MAC header (24 bytes)
 strh r0,[r1],2 ;duration/id (zero)     ;  ;-
 tst  r6,100h   ;FC.ToDS (0=ADHOC)      ;  ;\
 ldreq r0,[r5,sgMemBlk_datastart];adhoc ;  ;
 addeq r0,sgEthHdr_dest_mac      ;adhoc ;  ; Addr1 (DA/BSSID)
 ldrne r0,=WifiData_bssid7       ;norm  ;  ;
 bl   arm9_Wifi_CopyMacAddr             ;  ;/
 ldr  r0,=WifiData_MacAddr       ;mac   ;  ;\Addr2 (SA)
 bl   arm9_Wifi_CopyMacAddr             ;  ;/
 tst  r6,100h   ;FC.ToDS (0=ADHOC)      ;  ;\
 ldreq r0,=WifiData_bssid7       ;adhoc ;  ;
 ldrne r0,[r5,sgMemBlk_datastart];norm  ;  ; Addr3 (BSSID/DA)
 addne r0,sgEthHdr_dest_mac      ;norm  ;  ;
 bl   arm9_Wifi_CopyMacAddr             ;  ;/
 mov  r0,0                              ;  ;\SeqCtrl
 strh r0,[r1],2 ;sequence ctrl (zero)   ;/ ;/
 tst  r6,4000h  ;FC.WEP  ;NDS only      ;\init dummy WEP IV (4 bytes, if any)
 movne r0,0              ;(not DSi)     ; (actual IV will be filled in
 strne r0,[r1],4 ;WEP IV (if any)       ;/on arm7 side if needed)
 ldr  r0,=0003AAAAh                     ;\
 str  r0,[r1],4                  ;[0]   ;
 mov  r0,0000h                          ; init LLC header (8 bytes)
 strh r0,[r1],2                  ;[4]   ;
 ldr  r0,[r5,sgMemBlk_datastart]        ;
 ldrh r0,[r0,sgEthHdr_protocol]         ;
 strh r0,[r1],2 ;protocol aka frametype ;/
;- - - -
 ldr  r1,=WifiData_txbufOut                     ;\get fifo out pos (dest)
 ldr  r9,[r1]                                   ;/
 mov  r0,r9  ;dst.index/2         ;-dst/2       ;\
 mov  r1,r7,lsr 1                 ;-len/2       ;
 mov  r2,sp  ;hdr buf             ;-src         ;
 add  r12,r1 ;copied/2+len/2    ;\              ; send header's
 add  r9,r1  ;dst.index/2+len/2 ; raise         ;
 cmp  r9,WIFI_TXBUFFER_SIZE/2   ; stuff         ;
 subhs r9,WIFI_TXBUFFER_SIZE/2  ;/              ;
 bl   arm9_Wifi_TxBufferWrite     ;-send        ;/
 mov  r10,r5 ;first MemBlk                      ;\
 mov  r3,sgEthHdr_size ;skip.len (in 1st MemBlk); send MemBlk(s)...
@@memblock_lop:                                 ;
 mov  r0,r9  ;dst.index/2         ;-dst/2       ;  ;\
 ldr  r1,[r10,sgMemBlk_thislength];\            ;  ;
 sub  r1,r3  ;exclude skip.len    ; len/2       ;  ;
 add  r1,1        ;round-up       ;             ;  ; send MemBlk
 movs r1,r1,lsr 1 ;align          ;/            ;  ; (unless len=0,
 ldr  r2,[r10,sgMemBlk_datastart] ;\src         ;  ; which may(?) happen
 add  r2,r3  ;exclude skip.len    ;/            ;  ; for 1st Memblk,
 add  r12,r1 ;copied/2+len/2    ;\              ;  ; if it's only a
 add  r9,r1  ;dst.index/2+len/2 ; raise         ;  ; EthHdr without data)
 cmp  r9,WIFI_TXBUFFER_SIZE/2   ; stuff         ;  ;
 subhs r9,WIFI_TXBUFFER_SIZE/2  ;/              ;  ;
 cmp  r1,0  ;len                  ;\send        ;  ;
 blne arm9_Wifi_TxBufferWrite     ;/            ;  ;/
 mov  r3,0  ;skip.len (none for next MemBlk's)  ;  ;\
 ldr  r10,[r10,sgMemBlk_next]                   ;  ; lop next MemBlk
 cmp  r10,0                                     ;  ; (if any)
 bne  @@memblock_lop                            ;/ ;/
 tst  r6,4000h  ;FC.WEP  ;NDS only (not DSi)    ;\
 addne r12,4/2 ;copied/2    +4/2  ;\            ; raise for WEP FCS (if any)
 addne r9,4/2  ;dst.index/2 +4/2  ; raise       ; (just raise, without
 cmp  r9,WIFI_TXBUFFER_SIZE/2     ; stuff       ; actually sending the FCS)
 subhs r9,WIFI_TXBUFFER_SIZE/2    ;/            ;/
 ldr  r1,=WifiData_txbufOut                     ;\update fifo out pos,
 str  r9,[r1]                                   ;/done sending packet
;- - - -
 cmp  r12,r11 ;copied/2, expect/2               ;\some self-test error check
 bne  @@fail_copied_vs_expected_len             ;/
 mov  r0,r5  ;MemBlk (1st Blk, plus childs) ;\free packet, as we're the last
 bl   sgIP_memblock_free                    ;/stop on this chain
;- - - -
 ldr  r3,=arm9_synchandler      ;\
 ldr  r3,[r3]                   ; call sync handler (if any)
 cmp  r3,0                      ;
 blne bx_r3                     ;/
@@return_zero:
 mov  r0,0   ;out: r0=0 (always)
 add  sp,48  ;dealloc hdr buf (12+24+(4)+8 = 48)
 pop  r4-r12,pc
;---
@@fail_copied_vs_expected_len:
 ;this shouldn't happen (unless the software is bugged, or unless the MemBlk's
 ;"thislength" and "totallength" entries don't match with each other)
;SGIP_DEBUG_MESSAGE(("Tx exp:%i que:%i",copyexpect,copytotal));
 mov  r0,r5  ;MemBlk            ;\
 bl   sgIP_memblock_free        ;/
 b    @@return_zero     ;?
;---
@@fail_netdown:
;SGIP_DEBUG_MESSAGE(("Transmit:err_netdown"))
 mov  r0,r5  ;MemBlk            ;\
 bl   sgIP_memblock_free        ;/
 b    @@return_zero     ;?
;---
@@fail_no_space:  ;error, can't send this much!
;SGIP_DEBUG_MESSAGE(("Transmit:err_space"))
 mov  r0,r5  ;MemBlk            ;\
 bl   sgIP_memblock_free        ;/
 b    @@return_zero     ;?
.endif ;WIFI_USE_TCP_SGIP
;------------------
.ifdef WIFI_USE_TCP_SGIP
arm9_Wifi_Interface_Init:  ;in: r0=HubHwi, out: r0
 ;BUGGED/BLAH: the "sgHubHwi_MTU" isn't actually used anywhere! instead,
 ;original code uses SGIP_MTU_OVERRIDE, whilst, ACTUALLY, it should use
 ;the user-specified MTU from WFC in WifiFLASH)!
 ;and, UNLESS there are different kinds of MTU's (one for Wifi and one for TCP
 ;or so), if so... not sure about the purpose of the MTU WifiFLASH value.
 ;oh, and that MTU value in WifiFLASH exists on DSi only, not on NDS.
 ;- - -
 push r4,lr
 mov  r4,r0  ;HubHwi
 ldr  r0,=2300                  ;\mtu
 str  r0,[r4,sgHubHwi_MTU]      ;/
 ldr  r0,=09701A8C0h            ;\default IP = 192.168.1.151  ;uh, why not?
 str  r0,[r4,sgHubHwi_ipaddr]   ;/
 ldr  r0,=000FFFFFFh            ;\default mask = 255.255.255.0
 str  r0,[r4,sgHubHwi_snmask]   ;/
 ldr  r0,=00101A8C0h            ;\
 str  r0,[r4,sgHubHwi_gateway]  ; default gateway and DNS[0] = 192.168.1.1
 str  r0,[r4,sgHubHwi_dns+0]    ;/
 mov  r0,6                      ;\addlen
 strh r0,[r4,sgHubHwi_hwaddrlen];/
 ldr  r0,=WifiData_MacAddr  ;src;\
 add  r1,r4,sgHubHwi_hwaddr ;dst; apply mac addr
 bl   arm9_Wifi_CopyMacAddr     ;/
 mov  r0,0                      ;\no userdata (BLAH/UNUSED)
 str  r0,[r4,sgHubHwi_userdata] ;/
 mov  r0,0      ;out: r0=0
 pop  r4,pc
.endif
;------------------
.ifdef WIFI_USE_TCP_SGIP
arm9_Wifi_Timer:  ;in: r0=num_ms, out: none
 push r4,lr
 mov  r4,r0  ;num_ms
 bl   arm9_Wifi_Update          ;-
 mov  r0,r4  ;num_ms            ;\
 bl   sgIP_Timer                ;/
 pop  r4,pc
.endif
;------------------
arm9_Wifi_Init:  ;in: r0=initflags, out: r0=Wifi_Data_Struct_start
 ;note: "Wifi_Data_Struct" must be "memUncached", that should prevent the
 ;cache from eating us alive
 ;- - -
 push r4,lr
 mov  r4,r0  ;initflags
 ldr  r0,=Wifi_Data_Struct_start                      ;dst ;\
 ldr  r1,=Wifi_Data_Struct_end-Wifi_Data_Struct_start ;len ;
 bl   zerofill_bytewise                                    ;/

 ldr  r0,=Xtra_uncached_mem_start                          ;\
 ldr  r1,=Xtra_uncached_mem_end-Xtra_uncached_mem_start    ; XXXX
 bl   zerofill_bytewise                                    ;/

 bl   arm9_cache_FlushAll               ;-flush cache and write buffer
 ldr  r0,=Wifi_Data_Struct_start        ;\
 ldr  r1,=arm9_WifiData                 ; dummy ptr (mark initialized)
 str  r0,[r1]                           ;/
 .ifdef WIFI_USE_TCP_SGIP
   and  r1,r4,WIFIINIT_OPTION_HEAPMASK ;initflags ;\
   cmp  r1,WIFIINIT_OPTION_USEHEAP_64  ;\         ;
   moveq r0,1024*64                    ;/         ; alloc heap at selected
   cmp  r1,WIFIINIT_OPTION_USEHEAP_128 ;\         ; size
   moveq r0,1024*128                   ;/         ; (unless custom alloc,
   cmp  r1,WIFIINIT_OPTION_USEHEAP_256 ;\         ; in that case, user must
   moveq r0,1024*256                   ;/         ; call arm9_wHeapAllocInit
   cmp  r1,WIFIINIT_OPTION_USEHEAP_512 ;\         ; on his/her own)
   moveq r0,1024*512                   ;/         ;
   cmp  r1,WIFIINIT_OPTION_USECUSTOMALLOC         ;
  ;movne r0,r0               ;\allocate heap      ;
   blne  arm9_wHeapAllocInit ;/(unless custom)    ;/
   bl   sgIP_Init                                 ;-init
 .endif
 ldr  r1,=WifiData_flags9                       ;\
 and  r0,r4,WFLAG_ARM9_INITFLAGMASK ;initflags  ; apply flags and mark active
 orr  r0,WFLAG_ARM9_ACTIVE                      ;
 str  r0,[r1]                                   ;/
 ldr  r0,=Wifi_Data_Struct_start        ;-return "dummy" ptr (nonzero=okay)
 pop  r4,pc
;------------------
arm9_Wifi_CheckInit:  ;in: none, out: r0
 ldr   r0,=arm9_WifiData        ;\
 ldr   r0,[r0]                  ; want "WifiData" present
 cmp   r0,0                     ;/
 ldrne r0,=WifiData_flags7      ;\
 ldrne r0,[r0]                  ; want ARM7 active
 tstne r0,WFLAG_ARM7_ACTIVE     ;/
 ldrne r0,=WifiData_flags9      ;\
 ldrne r0,[r0]                  ; want ready
 tstne r0,WFLAG_ARM9_ARM7READY  ;/
 moveq r0,0  ;nope
 movne r0,1  ;all okay
 bx    lr
;------------------
arm9_Wifi_Update:  ;in/out: none
 ;BUGGED/UNRELIABLE: if "SGIP_MEMBLOCK_DYNAMIC_MALLOC_ALL" is disabled, then
 ;"arm9_Wifi_RxRawReadPacket" couldn't be used to copy MemBlks from packets
 ;bigger than "SGIP_MEMBLOCK_FIRSTINTERNALSIZE" (aka "1600-16-16" aka "1568"),
 ;so below MemBlk data copying WON'T WORK if packet body is bigger than 1568
 ;(dunno if that could happen in practice; it should be physically possible,
 ;but common network protocols MIGHT tend to use only smaller packet bodys?)
 ;- - -
 push r4-r9,lr

        .if 0 ;XNAY
         push r11
         bl   sgIP_IntrProtect         ;\XXXX????
         mov  r11,r0                   ;/
        .endif
              ; mov r0,cpsr
              ; tst r0,80h
              ; bne @@ookk
              ; mov r0,'C' // bl wrchr_r0
              ; mov r0,':' // bl wrchr_r0
              ; b $
              ; @@ookk:

 sub  sp,48  ;alloc hdr buf, 12+24+(4)+8 = 48 bytes
 ldr  r1,=arm9_WifiData         ;\
 ldr  r0,[r1]                   ; exit if not initialized yet
 cmp  r0,0                      ;
 beq  @@exit                    ;/
 .ifdef WIFI_USE_TCP_SGIP
   ldr  r1,=WifiData_flags9     ;\
   ldr  r0,[r1]                 ; check if already ready
   tst  r0,WFLAG_ARM9_ARM7READY ;
   bne  @@already_ready         ;/
   ldr  r2,=WifiData_flags7     ;\
   ldr  r2,[r2]                 ; check if now ready
   tst  r2,WFLAG_ARM7_ACTIVE    ;
   beq  @@notyet_ready          ;/
   orr  r0,WFLAG_ARM9_ARM7READY         ;\mark now ready
   str  r0,[r1]  ;[WifiData_flags9]     ;/
   ldr  r0,=arm9_Wifi_TransmitFunction  ;\
   ldr  r1,=arm9_Wifi_Interface_Init    ;
   bl   sgIP_Hub_AddHardwareInterface   ; add network interface
   ldr  r1,=wifi_hw                     ;
   str  r0,[r1]                         ;/
   ldr  r1,=WifiData_random             ;\
   ldr  r0,[r1]                         ; init random time
   ldr  r1,=sgIP_timems                 ; hacky! but it should work just fine :)
   str  r0,[r1]                         ;/
  @@notyet_ready:
  @@already_ready:
  ;- - - -
   ldr  r1,=WifiData_authlevel          ;\
   ldrh r0,[r1]                         ;
   cmp  r0,WIFI_AUTHLEVEL_ASSOCIATED    ; when associated,
   ldr  r1,=WifiData_flags9             ; mark net up, else net down
   ldr  r0,[r1]                         ;
   bicne r0,WFLAG_ARM9_NETUP  ;nope     ;
   orreq r0,WFLAG_ARM9_NETUP  ;yup      ;
   str  r0,[r1]                         ;/
 .endif
;- - - - check for received packets, forward to whatever wants them...
 mov  r4,80  ;limit     ;\process max 80 packets      ;XXX better more for ndma?
@@packet_lop:           ;/
 ldr  r0,=WifiData_rxbufIn              ;\
 ldr  r0,[r0]                           ;
 ldr  r1,=WifiData_rxbufOut             ; done if no more packets
 ldr  r1,[r1]                           ;
 cmp  r0,r1                             ;
 beq  @@packet_lop_done                 ;/
 ldr  r1,=WifiData_rxbufIn              ;\get RX addr (src)
 ldr  r5,[r1]                           ;/
 mov  r0,r5   ;src                      ;\
 mov  r1,8/2  ;aka sgRxHdr_byteLength/2 ; get packet length
 bl   arm9_Wifi_RxReadOffset            ;
 mov  r6,r0  ;packet len                ;/

       ; bl wrhex32bit

        cmp r6,24+0+8
       ;; cmp r6,3ch              ;XXXX????
        blo @@ignore_packet

 .ifdef WIFI_USE_TCP_SGIP
   ;- - - do lwIP interfacing for rx here...

          ;mov  r0,'(' // bl wrchr_r0 ;XXXX????  ;XNAY

   mov  r0,r5  ;src                     ;\
   mov  r1,12/2  ;aka sgRxHdr_size      ; get frame control (FC)
   bl   arm9_Wifi_RxReadOffset          ;
   mov  r7,r0  ;FC, memorize for later  ;/
   ldr  r1,=01CFh ;mask                 ;\
   and  r1,r7     ;frame control (FC)   ; ignore packet, unless it is a non-null
   cmp  r1,0008h                        ; data packet coming from the AP; toDS=0
   bne  @@ignore_packet                 ;/
   mov  r0,r5  ;src                     ;\copy all headers to RAM
   mov  r1,44  ;12+24+(0)+8             ; note: hardware is automatically
   mov  r2,sp  ;dst                     ; excluding the received WEP IV value
   bl   arm9_Wifi_RxRawReadPacket       ;/(hence only 44 bytes, not 48 bytes)
   ldr  r0,=WifiData_MacAddr    ;\      ;\
   add  r1,sp,12+4              ;       ;
   bl   arm9_Wifi_CmpMacAddr    ;/      ; ignore packet, unless it's sent
   cmp  r0,0                            ; to the console's MAC addr (or to
   ldreq r0,=const_FFFFFFFFFFFFh;\      ; broadcast address FFFFFFFFFFFFh)
   addeq r1,sp,12+4             ;       ;
   bleq  arm9_Wifi_CmpMacAddr   ;/      ;
   cmp  r0,0                            ;
   beq  @@ignore_packet                 ;/

          ;mov  r0,'"' // bl wrchr_r0 ;XXXX???? ;XNAY

   ldr  r0,[sp,12+24+0+0]  ;LLC[0..3]   ;\
   ldrh r1,[sp,12+24+0+4]  ;LLC[4..5]   ; ignore packet, unless it's having
   ldr  r2,=0003AAAAh                   ; proper LLC/SLIP header
   cmp  r0,r2                           ;    ;BUGGED/comment: should be called
   cmpeq r1,0000h                       ;    ;SNAP (Subnetwork Access Protocol),
   bne  @@ignore_packet                 ;/   ;not SLIP (Serial Line Internet Protocol)
   ;- - - okay, accept packet...
   mov  r0,sgEthHdr_size   ;hdr.size    ;\
   sub  r1,r6,24+0+8       ;packet.size ;
   bl   sgIP_memblock_allocHW           ; alloc MemBlk
   movs r8,r0  ;MemBlk                  ;
   beq  @@ignore_packet  ;oops          ;/
   ldr  r9,[r8,sgMemBlk_datastart]      ;-get ptr to EthHdr (followed by data)
   add  r0,sp,12+4      ;Addr1          ;\
   add  r1,r9,sgEthHdr_dest_mac         ; copy MAC dest to EthHdr
   bl   arm9_Wifi_CopyMacAddr           ;/
   tst  r7,200h  ;FC.FromDS             ;\
   addeq r0,sp,12+4+6   ;Addr2          ;
   addne r0,sp,12+4+6+6 ;Addr3          ; copy MAC src to EthHdr
   add  r1,r9,sgEthHdr_src_mac          ;
   bl   arm9_Wifi_CopyMacAddr           ;/
   ldrh r0,[sp,12+24+0+6]  ;LLC[6..7]   ;\copy MAC protocol to EthHdr
   strh r0,[r9,sgEthHdr_protocol]       ;/(assume LLC exists and is 8 bytes)
   add  r0,r5,(44/2)  ;src         ;src ;\
   cmp  r0,WIFI_RXBUFFER_SIZE/2    ;src ;
   subhs r0,WIFI_RXBUFFER_SIZE/2   ;src ; copy packet.data to MemBlk
   sub  r1,r6,24+0+8       ;packet.size ;
   add  r2,r9,sgEthHdr_size  ;data ;dst ;
   bl   arm9_Wifi_RxRawReadPacket       ;/

       .if 0       ;XNAY
          ; mov  r0,'"' // bl wrchr_r0 ;XXXX????  <-- required here ???
          ; *** doesn't even WORK WITHOUT above CRAP when killing "arm9_Wifi_Sync"/"arm9_Wifi_Update"
        ;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX timing issue here? XXXXXXXXXXXXXXXXXX
                  ;ldr  r2,=sgIP_timems
                  ;ldr  r0,[r2]
                  ;add  r0,3
                  ;str  r0,[r2]
           .if 0;1
              push r0-r12
              push r0-r12
              bl   check_host_nds7
              pop  r0-r12
              pop  r0-r12
           .endif
       .endif

   mov  r0,'R'  ;aka Received           ;\
   mov  r1,r9   ;EthHdr                 ; debug log received EthHdr
   bl   arm9_ethhdr_print               ;/
   ldr  r0,=wifi_hw                     ;\
   ldr  r0,[r0] ;HubHwi                 ; done generating received data packet,
   mov  r1,r8   ;MemBlk                 ; now distribute it
   bl   sgIP_Hub_ReceiveHardwarePacket  ;/      ---->
  @@ignore_packet:
 .endif
 ldr  r3,=arm9_packethandler    ;\      ;\
 ldr  r3,[r3]                   ;       ;
 cmp  r3,0                      ;       ; pass to custom handler
 beq  @@no_custom_handler       ;/      ; (if any, usually none)
 add  r0,r5,12/2  ;src          ;\      ;
 cmp  r0,WIFI_RXBUFFER_SIZE/2   ;       ;
 subhs r0,WIFI_RXBUFFER_SIZE/2  ;       ;
 mov  r1,r6   ;packet len       ;       ;
 bl   bx_r3   ;in: r0,r1        ;/      ;
@@no_custom_handler:                    ;/
 add  r0,r6,12+3  ;packet len           ;\
 bic  r0,3        ;align                ;
 add  r5,r5,r0,lsr 1   ;add src,len/2   ;
 cmp  r5,WIFI_RXBUFFER_SIZE/2           ; raise RX addr (src)
 subhs r5,WIFI_RXBUFFER_SIZE/2          ;
 ldr  r1,=WifiData_rxbufIn              ;
 str  r5,[r1]                           ;/
 subs r4,1   ;limit     ;\process max 80 packets
 bne  @@packet_lop      ;/
@@packet_lop_done:
@@exit:
 add  sp,48  ;dealloc hdr buf, 12+24+(4)+8 = 48 bytes

        .if 0 ;XNAY
         mov r4,r0
         mov  r0,r11                    ;\
         bl   sgIP_IntrUnprotect        ;/
         mov r0,r4
         pop  r11
        .endif

 pop  r4-r9,pc
;------------------
.pool
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm9\source\wifi_arm9.c IP addr
;------------------
;Ip addr get/set functions...
;------------------
.ifdef WIFI_USE_TCP_SGIP
  ;------------------
  arm9_Wifi_GetIP:  ;in: none, out: r0=IP (or 0=no hardware)
   ldr  r0,=wifi_hw
   ldr  r0,[r0]  ;HubHwi
   cmp  r0,0
   ldrne r0,[r0,sgHubHwi_ipaddr]
   bx   lr
  ;------------------
  arm9_Wifi_GetIPInfo:  ;in: r0=ptrGateway, r1=ptrSnmask, r2=ptrDns1, r3=ptrDns2, out: r0=struct in_addr
   push r4-r5,lr
   ldr  r4,=wifi_hw             ;\
   ldr  r4,[r4]  ;HubHwi        ;
   cmp  r4,0                    ; get hardware (if any)
   moveq r0,INADDR_NONE         ;
   beq   @@no_hardware          ;/
   cmp   r0,0                           ;\
   ldrne r5,[r4,sgHubHwi_gateway]       ; return Gateway in [r0], unless r0=0
   strne r5,[r0]                        ;/
   cmp   r1,0                           ;\
   ldrne r5,[r4,sgHubHwi_snmask]        ; return Subnet in [r1], unless r1=0
   strne r5,[r1]                        ;/
   cmp   r2,0                           ;\
   ldrne r5,[r4,sgHubHwi_dns+0]         ; return 1st DNS in [r2], unless r2=0
   strne r5,[r2]                        ;/
   cmp   r3,0                           ;\
   ldrne r5,[r4,sgHubHwi_dns+4]         ; return 2nd DNS in [r3], unless r3=0
   strne r5,[r3]                        ;/
   ldr   r0,[r4,sgHubHwi_ipaddr]        ;-return ipaddr in r0
  @@no_hardware:    ;out: r0=IP (or INADDR_NONE when no hardware)
   pop  r4-r5,pc
  ;------------------
  arm9_Wifi_SetIP:  ;in: r0=IPaddr, r1=gateway, r2=subnetmask, r3=dns1, r4=dns2, out: none
   push r4-r5,lr
   ldr  r5,=wifi_hw             ;\
   ldr  r5,[r5]  ;HubHwi        ; get HW interface, exit if none
   cmp  r5,0                    ;
   beq  @@exit                  ;/
  ;SGIP_DEBUG_MESSAGE(("SetIP%08X %08X %08X",IPaddr,gateway,subnetmask));
   str  r0,[r5,sgHubHwi_ipaddr]         ;\
   str  r1,[r5,sgHubHwi_gateway]        ; apply incoming params
   str  r2,[r5,sgHubHwi_snmask]         ;
   str  r3,[r5,sgHubHwi_dns+0]          ;
   str  r4,[r5,sgHubHwi_dns+4]          ;/
   mov  r0,r5  ;HubHwi                  ;\reset arp cache...
   bl   sgIP_ARP_FlushInterface         ;/
  @@exit:
   pop  r4-r5,pc
  ;------------------
  arm9_Wifi_SetDHCP:  ;in/out: none
   ;BLAH: UNUSED, and doesn't do anything
   bx   lr
  ;------------------
.endif ;WIFI_USE_TCP_SGIP
;------------------
.if with_gimmicks
arm9_Wifi_GetData:  ;in: r0=datatype, r1=bufferlen, r2=buffer, out: r0
;BLAH: if(datatype<0 || datatype>=MAX_WIFIGETDATA) return -1;
;- - -
 push lr
 cmp  r0,WIFIGETDATA_MACADDRESS ;\
 beq  @@get_mac_address         ;/
 cmp  r0,WIFIGETDATA_NUMWFCAPS  ;\
 beq  @@get_num_wfc_entries     ;/
@@fail_return_minus_1:
 mov  r0,-1
@@return_r0:
 pop  pc
;---
@@get_mac_address:
 cmp  r1,0  ;buffer
 beq  @@fail_return_minus_1
 cmp  r2,6  ;bufferlen
 blo  @@fail_return_minus_1
 ldr  r0,=WifiData_MacAddr ;src ;\
;mov  r1,r1 ;buffer        ;dst ; copy mac addr
 bl   arm9_Wifi_CopyMacAddr     ;/
 mov  r0,6              ;length of mac addr
 b    @@return_r0
;---
@@get_num_wfc_entries:
 mov  r0,0  ;num entries (initially 0)
 ldr  r1,=WifiData_wfc_ap       ;\
@@count_wfc_lop:                ;
 ldrb r2,[r1,sgWifiWfc_enable]  ;
 add  r1,sgWifiWfc_size         ; count used WFC entries
 tst  r2,80h                    ;
 addne r0,1 ;num entries        ;
 cmpne r0,3 ;max entries        ;
 bne  @@count_wfc_lop           ;/
;mov  r0,r0             ;num used WFC entries
 b    @@return_r0
.endif
;------------------
.if with_gimmicks
arm9_Wifi_GetStats:  ;in: r0=statnum, out: r0
 cmp  r0,NUM_WIFI_STATS
 movhs r0,0   ;invalid index, return 0
 ldrlo r1,=WifiData_stats
 ldrlo r0,[r1,r0,lsl 2]
 bx   lr
.endif
;------------------
;sync functions...
;------------------
arm9_Wifi_Sync:  ;in/out: none
 push r4-r5,lr
 mov  r4,4000000h
 ldr  r5,[r4,REG_IE]    ;old.ie         ;\memorize old IE,
 bic  r0,r5,IRQ_TIMER3  ;timer3 irq off ; and disable TIMER3 irq
 str  r0,[r4,REG_IE]    ;new.ie         ;/
 bl   arm9_Wifi_Update                  ;---> update
 str  r5,[r4,REG_IE]    ;old.ie         ;-restore old IE
 pop  r4-r5,pc
;------------------
;Dswifi helper functions...
;------------------
arm9_Timer_50ms:  ;in/out: none
 ;wifi timer function, to update internals of sgIP

 mov  r1,4000000h               ;\
 mov  r0,IRQ_TIMER3             ; wifi timer3   <--- uh, original code does NOT ack IRQ_TIMER3 (unlike IRQ_WIFI)
 str  r0,[r1,REG_IF]            ;/

 mov  r0,50                     ;\
 b    arm9_Wifi_Timer           ;/
;------------------
arm9_synctoarm7:  ;in/out: none
 ;notification function to send fifo message to arm7
 mov  r0,FIFO_DSWIFI            ;\
 mov  r1,WIFI_SYNC              ;
 b    arm9_fifoSendValue32      ;/
;------------------
arm9_wifiValue32Handler:  ;in: r0=value, r1=data/optional, out: none
 cmp  r0,WIFI_SYNC              ;\sync
 beq  arm9_Wifi_Sync  ;--->     ;/
 bx   lr                        ;-other
;------------------
arm9_Wifi_InitDefault:  ;in: r0=bool:useFirmwareSettings, out: r0=bool
 ;BUGGED: original code does issue an unneccassary "swiWaitForVBlank" AFTER
 ;receiving the final "ASSOCSTATUS_ASSOCIATED"
 ;also, "swiWaitForVBlank" is a bit overkill (waiting for ANY interrupt should
 ;work smoother; ideally with an IRQ generated upon ARM7 status changes)
 ;and, if "swiWaitForVBlank" is literally using the SWI waitvblank function:
 ;that function is bugged in DSi-mode.
 ;- - -
 push r4-r5,lr
 mov  r4,r0  ;memorize flag (useFirmwareSettings) aka "WFC_CONNECT"
;mov  r0,FIFO_DSWIFI                    ;\
;ldr  r1,=arm9_wifiValue32Handler       ;
;mov  r2,0                              ;
;bl   arm9_fifoSetValue32Handler        ;/
 mov  r0,WIFIINIT_OPTION_USELED         ;\
        orr r0,WIFIINIT_OPTION_USEHEAP_128  ;XXX
 bl   arm9_Wifi_Init                    ;
 movs r5,r0     ;"wifi_pass"            ;
 beq  @@fail_return_false               ;/
;mov  r0,IRQ_TIMER3                     ;\
;ldr  r1,=arm9_Timer_50ms               ; setup timer IRQ
;bl   arm9_irqSet                       ;/
 mov  r0,IRQ_TIMER3                     ;\enable timer IRQ
 bl   arm9_irqEnable                    ;/
 ldr  r0,=arm9_synctoarm7               ;\tell wifi lib to use our handler
 bl   arm9_Wifi_SetSyncHandler          ;/to notify arm7
 mov  r1,4000000h                       ;\set timer3
 ldr  r0,=((-6553) AND 0FFFFh)+0c20000h ; (6553.1 * 256 cycles = circa 50ms)
 str  r0,[r1,TIMER3CNT]                 ;/(mode = enable, irq, 1/256 clock)
 mov  r0,FIFO_DSWIFI                    ;\
   mov  r1,WIFI_STARTUP
   bl   arm9_fifoSendValue32
;; mov  r1,r5     ;"wifi_pass             ;
;; bl   arm9_fifoSendAddress              ;/
@@wait_lop:                             ;\
 bl   arm9_Wifi_CheckInit               ;
 cmp  r0,0                              ; wait
 bne  @@wait_done                       ;
             ;bl   wait_VBlank  ;XNAY
 bl   arm9_Halt   ;wait for irq         ;
 b    @@wait_lop                        ;
@@wait_done:                            ;/
;- - -
 cmp  r4,0  ;useFirmwareSettings     ;\ ;\
 beq  @@skip_auto_connect            ;  ;/
 bl   arm9_Wifi_AutoConnect          ;  ;-request connect
@@wait_assoc_lop:                    ;  ;\
 bl   arm9_Wifi_AssocStatus          ;  ;
 cmp  r0,ASSOCSTATUS_ASSOCIATED      ;  ; wait for status=associated
 beq  @@done_okay                    ;  ; (or cannot connected)
 cmp  r0,ASSOCSTATUS_CANNOTCONNECT   ;  ;
 beq  @@fail_return_false            ;  ;
 bl   arm9_Halt   ;wait for irq      ;  ;

            ;bl   wait_VBlank  ;XNAY

 b    @@wait_assoc_lop               ;  ;/
@@done_okay:                         ;
@@skip_auto_connect:                 ;/

             ;bl   wait_VBlank  ;XXXX ;XNAY



 mov  r0,true       ;return "true"
@@return_r0:
 pop  r4-r5,pc
;---
@@fail_return_false:
 mov  r0,false      ;return "false"
 b    @@return_r0
;------------------
.pool
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm7\source\wifi_arm7.c <shared dsi>
;------------------
.data?
 arm7_WifiData    dd 0    ;XXX shall be initially ZERO (!)
.code
;------------------
        ;XXXXchannel
boot_channel_list:
        ;XXX with_warmboot_info --> re-use old channel
 db 1,6,11
 db 1,6,11
 db 1,6,11
 db 2,3,4,5
 db 1,6,11
 db 7,8,9,10
 db 12,13,14
 db 0
.align 4
;---
.data?
boot_channel_index dd 0
boot_channel_wait  dd 0
.code
;------------------
arm7_Wifi_CopyMacAddr:  ;in: r0=src, r1=dst, out: r0/r1=increased
 ;note: original code used r0/r1 vice-versa, and didn't return r0/r1=next
 ldrh r2,[r0],2         ;\copy 1st halfword     ;\
 strh r2,[r1],2         ;/                      ; write in 16bit units
 ldrh r2,[r0],2         ;\copy 2nd halfword     ; (Wifi hardware doesn't
 strh r2,[r1],2         ;/                      ; support 8bit writes)
 ldrh r2,[r0],2         ;\copy 3rd halfword     ;
 strh r2,[r1],2         ;/                      ;/
 bx   lr
;------------------
arm7_Wifi_CmpMacAddr:  ;in: r0=mac1, r1=mac2, out: r0
 ldrh   r2,[r0,0]       ;\
 ldrh   r3,[r1,0]       ; compare 1st halfword
 cmp    r2,r3           ;/
 ldreqh r2,[r0,2]       ;\
 ldreqh r3,[r1,2]       ; compare 2nd halfword
 cmpeq  r2,r3           ;/
 ldreqh r2,[r0,4]       ;\
 ldreqh r3,[r1,4]       ; compare 3rd halfword
 cmpeq  r2,r3           ;/
 moveq  r0,1   ;match
 movne  r0,0   ;mismatch
 bx     lr
;------------------
arm7_parse_beacon_or_probe_response:
 push r4-r12,lr
@@local_rsnie_wpa       equ 00h  ;4
@@local_rsnie_wpa2      equ 04h  ;4
@@local_alloc_size      equ 08h
 sub  sp,@@local_alloc_size
 mov  r4,r0        ;beacon info
 mov  r5,r1        ;frame body
 mov  r6,r2        ;frame len
;- - - - - -
 add  r5,8+2                    ;\
 subs r6,8+2                    ; skip timestamp(8),BeaconInterval(2)
 blo  @@refuse_packet           ;/
;- - - - - -
 ldr  r7,=WFLAG_APDATA_ACTIVE+WFLAG_APDATA_COMPATIBLE   ;-initial/default flags
 add  r0,r4,sgBeacon_sa     ;SA                 ;\
 add  r1,r4,sgBeacon_bssid  ;BSSID              ;
 bl   arm7_Wifi_CmpMacAddr                      ; check addr/adhoc
 cmp  r0,0    ;0=diff=adhoc, 1=same=fromsta     ;
 orreq r7,WFLAG_APDATA_ADHOC                    ;/
 ldrh r0,[r5],2         ;\                      ;\
 subs r6,2              ; get Capability(2)     ;
 blo  @@refuse_packet   ;/                      ; capability info, WEP bit
 tst  r0,0010h         ;WEP bit                 ;
 orrne r7,WFLAG_APDATA_WEP                      ;/
 mov  r10,0   ;ptr_ssid                         ;\initially no ssid/rateset
 mov  r11,0   ;ptr_rateset                      ;/
 ldr  r0,=WifiData_curChannel                   ;\init channel (default=current)
 ldrh r12,[r0] ;channel                         ;/
 mov  r0,0                                      ;\
 str  r0,[sp,@@local_rsnie_wpa]                 ; initially no rsnie
 str  r0,[sp,@@local_rsnie_wpa2]                ;/
;- - - - - - process beacon entries...
;mov  r5,r5       ;after IEEE(24),timestamp(8),BeaconInterval(2),Capability(2)
;mov  r6,r6       ;len
@@scan_beacon_lop:                                      ;\
 subs r6,2     ;packet_len      ;\want min 2 bytes      ;
 blo  @@scan_beacon_done        ;/(type,len)            ;
 ldrb r0,[r5],1   ;seg.type                             ;
 ldrb r2,[r5],1   ;seg.len                              ;
 mov  r1,r5       ;begin of current segment data        ;
 add  r5,r2       ;skip seg.len                         ; scan beacon entries
 subs r6,r2    ;packet_len      ;\want min LEN bytes    ;
 blo  @@scan_beacon_done ;oops  ;/                      ;
 cmp  r0,0   // beq @@scan_beacon_ssid                  ;
 cmp  r0,1   // beq @@scan_beacon_rate_set              ;
 cmp  r0,3   // beq @@scan_beacon_ds_set                ;
 cmp  r0,48  // beq @@scan_beacon_rsn_a_field_wpa2      ;
 cmp  r0,221 // beq @@scan_beacon_vendor_specific       ;
;cmp  r0,xxx // ...don't care about the others...       ;
@@scan_beacon_next:                                     ;
 b    @@scan_beacon_lop                                 ;
@@scan_beacon_done:                                     ;/
;- - - - - - search access point entry with same BSSID (or an free/unused entry)
 ldr  r8,=WifiData_aplist
 mov  r5,WIFI_MAX_AP
 mov  r6,0  ;oldest_time
 mov  r9,r8 ;oldest_entry
@@search_aplist_lop:
 add  r0,r8,sgWifiAp_bssid      ;\
 add  r1,r4,sgBeacon_bssid      ;
 bl   arm7_Wifi_CmpMacAddr      ; check for existing entry with same BSSID
 cmp  r0,0                      ; if so, update that entry
;movne r5,=nonzero=update entry ;
 bne   @@use_this_ap_entry      ;/
 ldrh r0,[r8,sgWifiAp_flags]    ;\
 tst  r0,WFLAG_APDATA_ACTIVE    ; check if entry is not active,
 moveq r0,0ffffffffh ;force old ; or if it has oldest timectr,
 ldrne r0,[r8,sgWifiAp_timectr] ; if so, memorize that entry as discardable
 cmp  r6,r0  ;oldest_time       ;   (will be used to create a new entry
 movlo r6,r0 ;oldest_time       ;   if BSSID isn't found)
 movlo r9,r8 ;oldest_entry      ;/
 add  r8,sgWifiAp_size          ;\
 subs r5,1                      ; lop next
 bne  @@search_aplist_lop       ;/
 mov  r8,r9  ;oldest_entry      ;\no match found, overwrite "discardable" entry
;mov  r5,0  ;0=overwrite entry  ;/
@@use_this_ap_entry:   ;in: r5 (0=overwrite entry, Nonzero=update entry)
 mov  r0,r8                     ;\try to lock the entry to ARM9
 bl   arm7_Spinlock_Acquire     ; (fail if it was currently locked to ARM7,
 cmp  r0,SPINLOCK_OK            ; if so, future beacons will hopefully work)
 bne  @@cannot_update_now       ;/
;- - - - - - apply the beacon stuff to the access point entry...
 movs r0,r10  ;ptr_ssid         ;src    ;\
 beq  @@oops_refuse_missing_ssid        ;
 ldrb r2,[r0],1                 ;len    ;

   cmp  r2,0       ;XXXX
   beq  @@oops_refuse_missing_ssid

 cmp  r2,32   ;crop max 32      ;len    ; apply SSID
 movhi r2,32  ;(plus EOL)       ;len    ; (name, and len)
 strb r2,[r8,sgWifiAp_ssid_len] ;len    ;
 add  r1,r8,sgWifiAp_ssid       ;dst    ;
 bl   memcopy_bytewise          ;copy   ;
 mov  r0,00h                    ;eol    ;
 strb r0,[r1],1                 ;eol    ;/

 .if 0       ;XNAY
   mov  r0,'<' // bl wrchr_r0
   add  r1,r8,sgWifiAp_ssid
   bl   raw_wrstr_r1
   mov  r0,'>' // bl wrchr_r0
   mov  r0,0dh // bl wrchr_r0
 .endif

 mov  r0,0                              ;\reset timectr
 str  r0,[r8,sgWifiAp_timectr]          ;/

 add  r0,r4,sgBeacon_sa     ;SA    ;src ;\
 add  r1,r8,sgWifiAp_macaddr       ;dst ; apply addr
 bl   arm7_Wifi_CopyMacAddr             ;/
 add  r0,r4,sgBeacon_bssid  ;BSSID ;src ;\
 add  r1,r8,sgWifiAp_bssid         ;dst ; apply BSSID
 bl   arm7_Wifi_CopyMacAddr             ;/
 mov  r3,0  ;maxrate               ;max ;\                              ;\
 mov  r1,sgWifiAp_base_rates+0     ;dst ;                               ;
 cmp  r11,0 ;ptr_rateset           ;src ;                               ;
 beq  @@rateset_done  ;oops, none       ;/                              ; apply
 bic  r7,WFLAG_APDATA_COMPATIBLE+WFLAG_APDATA_EXTCOMPATIBLE  ;init=0    ; rates
 ldrb r2,[r11],1 ;[ptr_rateset+0]  ;len ;-                              ;
@@rateset_lop:                                                          ;
 subs r2,1                         ;len ;\                              ;
 blo  @@rateset_done                    ;/                              ;
 ldrb r0,[r11],1 ;[ptr_rateset+N]  ;src ;-                              ;
 tst  r0,80h  ;any Mbit/s with bit7=1   ;\skip if bit7=0                ;
 beq  @@skip_rate_entry                 ;/                              ;
 cmp  r1,sgWifiAp_base_rates+15         ;\append to list                ;
 strlob r0,[r8,r1] ;sgWifiAp_base_rates ; (unless list full)            ;
 addlo  r1,1                            ;/(max 15 entries)              ;
 bic  r7,WFLAG_APDATA_COMPATIBLE+WFLAG_APDATA_EXTCOMPATIBLE  ;-uh, ???  ;
 cmp   r0,82h  ;1 Mbit/s                ;\1 Mbit/s and 2 Mbit/s:        ;
 cmpne r0,84h  ;2 Mbit/s                ; fully compatible              ;
 orreq r7,WFLAG_APDATA_COMPATIBLE       ;/                              ;
 cmp   r0,8bh  ;5.5 Mbit/s              ;\5.5 Mbit/s and 11Mbit/s:      ;
 cmpne r0,96h  ;11 Mbit/s               ; have to fake our way in       ;
 orreq r7,WFLAG_APDATA_EXTCOMPATIBLE    ;/(uh, what do we fake how?)    ;
;tst  r7,WFLAG_APDATA_COMPATIBLE+WFLAG_APDATA_EXTCOMPATIBLE  ;\uh, ???  ;
;beq  PANIC ABORT force not compatible ???                   ;/         ;
@@skip_rate_entry:   ;uh, below "maxrate" applied even if bit7=0 (?)    ;
 and  r0,7fh                            ;\                              ;
 cmp  r3,r0  ;maxrate                   ; maxrate (find biggest)        ;
 movlo r3,r0 ;maxrate                   ;/                              ;
 b    @@rateset_lop                     ;-lop next                      ;
@@rateset_done:                                                         ;
 mov  r0,00h                            ;\append list end (max 15       ;
 strb r0,[r8,r1] ;sgWifiAp_base_rates+N ;/entries, plus ending zero)    ;
 strh r3,[r8,sgWifiAp_maxrate] ;maxrate ;-apply maxrate                 ;/
 cmp  r5,0  ;0=overwrite entry          ;\
;moveq r0,0                             ; for overwrite entry: reset rssi_past
 streq r0,[r8,sgWifiAp_rssi_past+0] ;0-3; (when updating entry: keep rssi_past)
 streq r0,[r8,sgWifiAp_rssi_past+4] ;4-7;/
 ldr  r0,=WifiData_curChannel           ;\                          ;\
 ldrh r0,[r0]                           ; apply RSSI only if we're  ;
 cmp  r0,r12  ;channel                  ; on the right channel      ;
 bne  @@skip_rssi                       ;/                          ;
 add  r0,r8,sgWifiAp_rssi_past+1   ;src ;\                          ; RSSI
 add  r1,r8,sgWifiAp_rssi_past+0   ;dst ; move old RSSI values      ;
 mov  r2,7                         ;len ; to older entries          ; (signal
 bl   memcopy_bytewise                  ;/                          ; strength)
 ldrb r0,[r4,sgBeacon_strength]         ;\append newest RSSI value  ;
 strb r0,[r8,sgWifiAp_rssi_past+7]      ;/at end of list            ;
 ldrb r1,[r8,sgWifiAp_rssi_past+0]      ;\                          ;
 cmp  r1,00h ;00h=empty (min is 02h)    ; if RSSI list was empty,   ;
;moveq r0,r0    ;RSSI              ;fil ; fill the WHOLE list       ;
 addeq r1,r8,sgWifiAp_rssi_past+0  ;dst ; by the newest RSSI value  ;
 moveq r2,8                        ;len ;                           ;
 bleq  memfill_bytewise                 ;/                          ;
@@skip_rssi:                                                        ;/
 tst  r7,WFLAG_APDATA_WPA                                     ;\if WPA, force
 bicne r7,WFLAG_APDATA_COMPATIBLE+WFLAG_APDATA_EXTCOMPATIBLE  ;/not compatible
 strh r7,[r8,sgWifiAp_flags]    ;flags          ;-apply flags
 strb r12,[r8,sgWifiAp_channel] ;channel        ;-apply channel
 ldr  r0,[sp,@@local_rsnie_wpa]                 ;\
 str  r0,[r8,sgWifiAp_rsnie_wpa]                ; apply rsnie for wpa/wpa2
 ldr  r0,[sp,@@local_rsnie_wpa2]                ;
 str  r0,[r8,sgWifiAp_rsnie_wpa2]               ;/
@@oops_refuse_missing_ssid:
 mov  r0,r8                     ;\done, release
 bl   arm7_Spinlock_Release     ;/
@@cannot_update_now:
@@refuse_packet:
 add  sp,@@local_alloc_size
 pop  r4-r12,pc
;--- --- ---
@@scan_beacon_ssid:     ;case 0: SSID element
 sub  r10,r1,1  ;ptr_ssid       ;-memorize ptr to SSID "len,name"
 b    @@scan_beacon_next
;--- --- ---
@@scan_beacon_rate_set: ;case 1: rate set (make sure we're compatible)
 sub  r11,r1,1  ;ptr_rateset    ;-memorize ptr to rateset "len,name"
 b    @@scan_beacon_next
;--- --- ---
@@scan_beacon_ds_set:   ;case 3: DS set (current channel)
 subs r2,1                      ;\want min 1 byte
 blo  @@scan_beacon_next        ;/
 ldrb r12,[r1],1  ;channel      ;-get channel
 b    @@scan_beacon_next
;--- --- ---
@@scan_beacon_rsn_a_field_wpa2: ;case 48: RSN(A) field- WPA enabled
 ldr  r3,=0ac0f00h  ;aka 00h,0Fh,ACh                            ;\
 bl   examine_rsnie  ;in: r1=src, r2=len, r3=oui - out: r0      ;
 str  r0,[sp,@@local_rsnie_wpa2]                                ;/
@@finish_rsnie_r0:
 tst   r0,RSNIE_PAIR_TKIP+RSNIE_PAIR_AES ;\make oldstyle dswifi WPA/WPA2 flag
 orrne r7,WFLAG_APDATA_WPA               ;/
 tst   r0,RSNIE_PAIR_WEPNONE             ;\make oldstyle dswifi WEP flag
 orrne r7,WFLAG_APDATA_WEP               ;/
 b    @@scan_beacon_next
;--- --- ---
@@scan_beacon_vendor_specific: ;case 221: vendor specific
 subs r2,4                      ;\want min 4 bytes
 blo  @@scan_beacon_next        ;/
 bl   ldr_32bit_r0_from_r1      ;\
 ldr  r3,=01f25000h             ; want four bytes ID (00h,50h,F2h,01h)
 cmp  r0,r3                     ;  (WPA RSNIE)
 bne  @@scan_beacon_next        ;/
 ldr  r3,=0f25000h  ;aka 00h,50h,F2h                            ;\
 bl   examine_rsnie  ;in: r1=src, r2=len, r3=oui - out: r0      ;
 str  r0,[sp,@@local_rsnie_wpa]                                 ;/
 b    @@finish_rsnie_r0
;------------------
examine_rsnie:  ;in: r1=src, r2=len, r3=oui - out: r0=flags
;BUG: original code did accept several nonsense pairwise ciphers:
;  AES WRAP      - this type is for EAPOL frames, not for packets
;  AES WEP64/104 - this type is for GROUP cipher, not for PAIRWISE
;on the other hand, "WEPNONE" was missing (which says sharing GROUP cipher
;as PAIRWISE cipher) (though WEP access points usually don't send RSNIE at all)
;- - -
 push r4-r5,lr
 mov  r4,0      ;initially clear rsnie flags
 subs r2,2                      ;\want min 2 bytes                  ;\
 blo  @@bad                     ;/                                  ;
 bl   ldrh_16bit_r0_from_r1     ;\                                  ; VERSION
 cmp  r0,0001h  ;aka 01h,00h    ; want two bytes version (01h,00h)  ;
 bne  @@bad                     ;/                                  ;/
 subs r2,4                      ;\want min 4 bytes                  ;\
 blo  @@bad                     ;/                                  ;
 bl   ldr_24bit_r0_from_r1      ;\                                  ;
 cmp  r0,r3     ;24bitID        ; get multicast/group cipher        ; GROUP
 bne  @@bad                     ;                                   ; CIPHER
 ldrb r0,[r1],1 ;type           ;                                   ;
 cmp   r0,01h             ;\    ;                                   ;
 orreq r4,RSNIE_GRP_WEP40 ;/    ;                                   ;
 cmp   r0,02h             ;\    ;                                   ;
 orreq r4,RSNIE_GRP_TKIP  ;/    ;                                   ;
 cmp   r0,04h             ;\    ;                                   ;
 orreq r4,RSNIE_GRP_AES   ;/    ;                                   ;
 cmp   r0,05h             ;\    ;                                   ;
 orreq r4,RSNIE_GRP_WEP104;/    ;                                   ;
 cmp   r4,0   ;oops,            ;                                   ;
 beq   @@bad  ;none of above    ;/                                  ;/
 subs r2,2                      ;\want min 2 bytes                  ;\
 blo  @@bad                     ;/                                  ; NUM
 bl   ldrh_16bit_r0_from_r1     ;-get 2-byte num_uni_ciphers (N)    ; CIPHERS
 subs r2,r2,r0,lsl 2            ;\want min N*4 bytes                ;
 blo  @@bad                     ;/                                  ;/
 mov  r5,r0  ;lopcount          ;-num_uni_ciphers (N)               ;\
@@cipher_lop:                                                       ;
 subs r5,1   ;lopcount          ;\exit if all done                  ; PAIRWISE
 blo  @@cipher_lop_done         ;/                                  ; CIPHER(s)
 bl   ldr_24bit_r0_from_r1      ;\                                  ;
 cmp  r0,r3   ;24bitID    ;zf   ; skip if unknown/wrong/custom 3byte ID
 ldrb r0,[r1],1           ;     ; and get type                      ;
 bne  @@unknow_next       ;zf   ;/                                  ;
 cmp   r0,00h                ;\ ;                                   ;
 orreq r4,RSNIE_PAIR_WEPNONE ;/ ;                                   ;
 cmp   r0,02h                ;\ ;                                   ;
 orreq r4,RSNIE_PAIR_TKIP    ;/ ;                                   ;
 cmp   r0,04h                ;\ ;                                   ;
 orreq r4,RSNIE_PAIR_AES     ;/ ;                                   ;
@@unknow_next:                                                      ;
 b    @@cipher_lop                                                  ;
;---                                                                ;
@@cipher_lop_done:                                                  ;/
 ;(there's usually MORE info here: authentication info & optional capabilities)
 ;(but, ignore that)
 ;- - -
 mov  r0,r4   ;rsnie flags
 b    @@done
;---
@@bad:
 mov  r0,0
@@done:
 pop  r4-r5,pc
;------------------
arm7_get_next_scan_channel:   ;out: [WifiData_reqChannel]
 ldr  r3,=boot_channel_index
 ldr  r2,[r3]  ;index
@@retry:
 ldr  r1,=boot_channel_list
 ldrb r0,[r1,r2] ;ch(index)
 cmp  r0,0   ;channel                ;\
 beq  @@wrap                         ;/
 add  r2,1  ;index
 str  r2,[r3]  ;index
 ldr  r1,=WifiData_reqChannel   ;\apply channel
 strh r0,[r1]                   ;/
 bx   lr
;---
@@wrap:
 ldr  r1,=boot_channel_wait ;\
 ldr  r0,[r1]               ;
 add  r0,r0                 ; raise time per channel scanned
 cmp   r0,7  ;ca. 460ms     ;
 movhi r0,7                 ;
 str  r0,[r1]               ;/
;- - -
 ldr  r1,=WifiData_aplist                       ;\
 mov  r2,WIFI_MAX_AP                            ;
@@ap_lop:                                       ; alongsides,
 ldrh r0,[r1,sgWifiAp_flags]    ;\              ; process all AP's
 tst  r0,WFLAG_APDATA_ACTIVE    ; check flags   ;
 beq  @@ap_next                 ;/              ; if active & timeout,
 ldr  r0,[r1,sgWifiAp_timectr]  ;\              ; clear rssi...
 add  r0,1                      ; raise time,   ;
 str  r0,[r1,sgWifiAp_timectr]  ; and check if  ;
 cmp  r0,WIFI_AP_TIMEOUT        ; timeout       ;
 bls  @@ap_next  ;no timeout    ;/              ;
 mov  r0,0                               ;\     ;
 strh r0,[r1,sgWifiAp_rssi]      ;=0000h ;      ;
 strb r0,[r1,sgWifiAp_rssi_past+0] ;=00h ;      ;
 strb r0,[r1,sgWifiAp_rssi_past+1] ;=00h ; clr  ;
 strb r0,[r1,sgWifiAp_rssi_past+2] ;=00h ;      ;
 strb r0,[r1,sgWifiAp_rssi_past+3] ;=00h ;      ;
 strb r0,[r1,sgWifiAp_rssi_past+4] ;=00h ;      ;
 strb r0,[r1,sgWifiAp_rssi_past+5] ;=00h ;      ;
 strb r0,[r1,sgWifiAp_rssi_past+6] ;=00h ;      ;
 strb r0,[r1,sgWifiAp_rssi_past+7] ;=00h ;/     ;
@@ap_next:                                      ;
 add  r1,sgWifiAp_size                          ;
 subs r2,1                                      ;
 bne  @@ap_lop                                  ;/
;- - -
 mov  r2,0  ;index          ;\retry from begin of channel list
 b    @@retry               ;/
;------------------
arm7_copy_ap_data_from_arm9:  ;in: r0
 push lr
 tst  r0,WFLAG_REQ_APCOPYVALUES ;\check copy
 beq  @@skip_copy               ;/
 tst  r0,WFLAG_REQ_APADHOC      ;\              ;\
 ldr  r1,=WifiData_curReqFlags  ; copy ap adhoc ;
 ldrh r0,[r1]                   ; flag (reqReq  ;
 biceq r0,WFLAG_REQ_APADHOC ;clr; to curReq)    ; copy stuff
 orrne r0,WFLAG_REQ_APADHOC ;set;               ; (optionally)
 strh r0,[r1]                   ;/              ;
 ldr  r0,=WifiData_wepkeyid9    ;\              ;
 ldr  r1,=WifiData_wepkeyid7    ; copy wepkeyid ;
 ldrb r3,[r0]                   ;               ;
 strb r3,[r1]                   ;/              ;
 ldr  r0,=WifiData_wepmode9     ;\              ;
 ldr  r1,=WifiData_wepmode7     ; copy wepmode  ;
 ldrb r3,[r0]                   ;               ;
 strb r3,[r1]                   ;/              ;
 ldr  r0,=WifiData_apchannel9   ;\              ;
 ldr  r1,=WifiData_apchannel7   ; copy apchannel;
 ldrb r3,[r0]                   ;               ;
 strb r3,[r1]                   ;/              ;
 ldr  r0,=WifiData_bssid9  ;src ;\              ;
 ldr  r1,=WifiData_bssid7  ;dst ; copy bssid    ;
 bl   arm7_Wifi_CopyMacAddr     ;/              ;
 ldr  r0,=WifiData_apmac9  ;src ;\              ;
 ldr  r1,=WifiData_apmac7  ;dst ; copy apmac    ;
 bl   arm7_Wifi_CopyMacAddr     ;/              ;
 ldr  r0,=WifiData_wepkey9      ;\              ;
 ldr  r1,=WifiData_wepkey7      ; copy wepkey   ;
 mov  r2,20                     ;               ;
 bl   memcopy_bytewise          ;/              ;
 ldr  r0,=WifiData_ssid9        ;\              ;
 ldr  r1,=WifiData_ssid7        ; copy ssid     ;
 mov  r2,34                     ;               ;
 bl   memcopy_bytewise          ;/              ;
 ldr  r0,=WifiData_baserates9   ;\              ;
 ldr  r1,=WifiData_baserates7   ; copy baserates;
 mov  r2,16                     ;               ;
 bl   memcopy_bytewise          ;/              ;/
 .if with_dsi_wifi                              ;\
  ;ldr  r0,=WifiData_wpamode9     ;\            ;
  ;ldr  r1,=WifiData_wpamode7     ; copy wpamode;
  ;ldrb r3,[r0]                   ;             ;
  ;strb r3,[r1]                   ;/            ;

   ldr  r0,=WifiData_eapol9       ;\            ;
   ldr  r1,=WifiData_eapol7       ; copy eapol  ;
   ldrb r3,[r0]                   ; type        ;
   strb r3,[r1]                   ;/            ;
   ldr  r0,=WifiData_grp9         ;\            ;
   ldr  r1,=WifiData_grp7         ; copy group  ;
   ldrb r3,[r0]                   ; key type    ;
   strb r3,[r1]                   ;/            ;
   ldr  r0,=WifiData_pair9        ;\            ;
   ldr  r1,=WifiData_pair7        ; copy pairwise
   ldrb r3,[r0]                   ; key type    ;
   strb r3,[r1]                   ;/            ;

   ldr  r0,=WifiData_psk9         ;\            ;
   ldr  r1,=WifiData_psk7         ; copy wpakey ;
   mov  r2,32                     ;             ;
   bl   memcopy_bytewise          ;/            ;
   ldr  r0,=WifiData_rsnie9_wpa   ;\            ;
   ldr  r1,=WifiData_rsnie7_wpa   ; copy RSNIE  ;
   ldr  r3,[r0]                   ; for WPA     ;
   str  r3,[r1]                   ;/            ;
   ldr  r0,=WifiData_rsnie9_wpa2  ;\            ;
   ldr  r1,=WifiData_rsnie7_wpa2  ; copy RSNIE  ;
   ldr  r3,[r0]                   ; for WPA2    ;
   str  r3,[r1]                   ;/            ;
 .endif                                         ;/
@@skip_copy:
 pop  pc
;------------------
arm7_Wifi_CheckTxBuf:  ;in: r0=offset, out: r0
 ;read halfword from queued TX packet (from normal memory, NOT from Wifi RAM)
 ;- - -
 ldr  r1,=WifiData_txbufIn      ;\index in circular Main RAM buffer
 ldr  r1,[r1]                   ;/
 add  r1,r0   ;add offset
 cmp   r1,WIFI_TXBUFFER_SIZE/2  ;\wrap
 subhs r1,WIFI_TXBUFFER_SIZE/2  ;/
 mov  r1,r1,lsl 1  ;mul2 (bytes vs halfwords)
 ldr  r2,=WifiData_txbufData
 ldrh r0,[r2,r1]      ;out: r0=[buffer]  ;16bit (halfword)
 bx   lr
;------------------
arm7_Wifi_CopyFirstTxData:  ;in: r0=dst, out: r0
 ;copy packet from queued TX packet (in normal memory; with wrapping)
 ;to TX buf (in Wifi RAM; without wrapping)
 ;- - -
 ;the incoming r0=dst value was changed for with_dsi_wifi:
 ;  old was r0=WIFIRAM_TX_LOC3_START/2 (halfword offset in NDS wifi ram),
 ;  new is r0=WIFIRAM_TX_LOC3_START+4804000h (actual byte addr in NDS wifi ram),
 ;  or r0=sdio_xfer_buf (byte address of DSi sdio buffer in main ram)
 ;also, the "queue empty check" and "keepalive reset" are now moved into
 ;this function.
 ;- - -
 push r4-r7,lr
 mov  r4,r0  ;dst
 ldr  r0,=WifiData_txbufOut     ;\
 ldr  r0,[r0]                   ;
 ldr  r1,=WifiData_txbufIn      ; exit if ARM9 queue empty
 ldr  r1,[r1]                   ;   ;BLAH: original code had some complex
 subs r0,r1        ;0=none      ;   ;extra condition, but it was outcommented
 beq  @@return_r0  ;out: r0=0   ;/
 mov  r0,5   ;index/2           ;\      XXXX aka TxHdr_tx_length/2
 bl   arm7_Wifi_CheckTxBuf      ; get packet length
 mov  r5,r0  ;packetlen         ;/
 ldr  r1,=WifiData_txbufIn      ;\get src.start
 ldr  r6,[r1]  ;src             ;/
 ldr  r1,=WifiData_txbufOut     ;\get src.end (end of all queued packets)
 ldr  r0,[r1]  ;src.end         ;/
 subs  r0,r0,r6  ;max = end-src ;\get max.len (len of all queued packets)
 addlo r0,WIFI_TXBUFFER_SIZE/2  ;/
 add  r7,r5,12-4+1              ;\total_halfwords
 mov  r7,r7,lsr 1               ;/
 cmp  r0,r7                     ;\
 movlo r0,0  ;out: r0=0         ; fail if whole packet isn't fully queued yet
 blo   @@return_r0              ;/
@@lop:                                                  ;\
 movs r2,r7  ;total_halfwords   ;\                      ;
 beq  @@lop_done                ;/                      ;
 rsb  r0,r6,WIFI_TXBUFFER_SIZE/2       ;\clip len r2    ;
 cmp   r2,r0                           ; to boundary    ;
 movhi r2,r0                           ;/               ; copy fragment(s)
 ldr  r0,=WifiData_txbufData            ;src    ;\      ; (with wrapping)
 add  r0,r0,r6,lsl 1                    ;src    ;       ;
 mov  r1,r4                             ;dst    ; copy  ;
 add  r6,r2          ;raise src                 ;       ;
 add  r4,r4,r2,lsl 1 ;raise dst                 ;       ;
 sub  r7,r2          ;decrease total_halfwords  ;       ;
 mov  r2,r2,lsl 1  ;num_halfwords*2     ;len    ;       ;
 bl   memcopy_bytewise_halfwords                ;/      ;
 cmp   r6,WIFI_TXBUFFER_SIZE/2                  ;\wrap  ;
 subhs r6,WIFI_TXBUFFER_SIZE/2                  ;/src   ;
 b    @@lop                                             ;
@@lop_done:                                             ;/
 ldr  r1,=WifiData_txbufIn      ;\new src.start (of next packet)
 str  r6,[r1]  ;src             ;/
 mov  r0,0                              ;\
 ldr  r1,=keepalive_time                ; reset keepalive
 str  r0,[r1]     ;=0                   ;/
 ldr  r1,=WifiData_stats                ;\
 ldr  r0,[r1,WSTAT_TXPACKETS]        ;\ ;
 add  r0,1                           ;  ;
 str  r0,[r1,WSTAT_TXPACKETS]        ;/ ; raise stats
 ldr  r0,[r1,WSTAT_TXBYTES]          ;\ ;
 add  r0,r5    ;packetlen            ;  ;
 add  r0,12-4                        ;  ;
 str  r0,[r1,WSTAT_TXBYTES]          ;/ ;
 ldr  r0,[r1,WSTAT_TXDATABYTES]      ;\ ;
 add  r0,r5    ;packetlen            ;  ;
 add  r0,0-4                         ;  ;
 str  r0,[r1,WSTAT_TXDATABYTES]      ;/ ;/
 mov  r0,r5  ;packetlen                 ;-return packetlen
@@return_r0:
 pop  r4-r7,pc
;------------------
arm7_Wifi_QueueRxMacData:  ;in: r0=src, r1=len, r2=src.wrap.end, r3=src.wrap.size, out: r0
 ;forward WifiRAM to RX queue in normal memory
 ;(both source and dest may wrap on buffer boundaries)
 ;(note: original code did handle wrapping for normal memory here, and
 ;wrapping in WifiRAM was handled in the arm7_Wifi_MACCopy subfunction)
 ;- - -
 ;the incoming r0=src value was changed for with_dsi_wifi:
 ;  old was r0=READCSR*2 (byte offset in NDS wifi ram),
 ;  new is r0=READCSR*2+4804000h (actual byte addr in NDS wifi ram),
 ;  or r0=sdio_xfer_buf (byte address of DSi sdio buffer in main ram)
 ;alongsides, new code has incoming r2/r3 to handle src.wrapping (or uses
 ;dummy r2/r3 values to prevent src.wrapping for DSi buffer).
 ;- - -
 push r4-r9,lr
 mov  r4,r0  ;base.src
 mov  r5,r1  ;total.len
 mov  r8,r2  ;wrap.end.addr
 mov  r9,r3  ;wrap.size
 ldr  r2,=WifiData_rxbufIn              ;\
 ldr  r2,[r2]   ;src.index (rd.ptr)     ;
 ldr  r3,=WifiData_rxbufOut             ; compute available rxbuf space
 ldr  r3,[r3]   ;dst.index (wr.ptr)     ;
 subs r2,r3                             ;
 addls r2,WIFI_RXBUFFER_SIZE/2          ;
 sub  r2,1        ;keep 1 free halfword ;
 mov  r2,r2,lsl 1 ;num bytes            ;/
 cmp  r5,r2                             ;\
 bls  @@rxbuf_not_full                  ; check if enough rxbuf space
 ldr  r3,=WifiData_stats                ; if not,
 ldr  r2,[r3,WSTAT_RXQUEUEDLOST*4] ;\   ; raise error stats and exit
 add  r2,1                         ;    ;
 str  r2,[r3,WSTAT_RXQUEUEDLOST*4] ;/   ;
        bl wrdot ;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX overrun
 mov  r0,0         ;\fail               ;
 b    @@return_r0  ;/                   ;/
;---
@@rxbuf_not_full:
 ldr  r3,=WifiData_stats                ;\
 ldr  r2,[r3,WSTAT_RXQUEUEDPACKETS*4];\ ;
 add  r2,1                           ;  ; okay, raise stats
 str  r2,[r3,WSTAT_RXQUEUEDPACKETS*4];/ ;
 ldr  r2,[r3,WSTAT_RXQUEUEDBYTES*4]  ;\ ;
 add  r2,r5  ;total.len              ;  ;
 str  r2,[r3,WSTAT_RXQUEUEDBYTES*4]  ;/ ;/
 ldr  r6,=WifiData_rxbufOut             ;\
 ldr  r7,[r6]  ;dst.index               ;/
@@lop:
 cmp   r4,r8  ;src.wrap.endaddr                         ;\wrap src.index
 subhs r4,r9  ;src.wrap.size                            ;/
 cmp   r7,WIFI_RXBUFFER_SIZE/2                          ;\wrap dst.index
 subhs r7,WIFI_RXBUFFER_SIZE/2                          ;/
 movs r2,r5                                             ;\get len and
 beq  @@lop_done                                        ;/check if done
 mov  r3,WIFI_RXBUFFER_SIZE                             ;\
 sub  r3,r3,r7,lsl 1    ;disp to src.end                ; clip len to
 cmp   r2,r3                                            ; dst.end
 movhi r2,r3                                            ;/
 sub  r3,r8,r4          ;disp to dst.end                ;\clip len to
 cmp   r2,r3                                            ; src.end
 movhi r2,r3                                            ;/
 ldr  r1,=WifiData_rxbufData                            ;\
 mov  r0,r4             ;base+src.index         ;src    ;
 add  r1,r1,r7,lsl 1    ;base+dst.index         ;dst    ; copy and
;mov  r2,r2                                     ;len    ; adjust index/len
 add  r4,r2             ;raise src.index                ;
 add  r7,r7,r2,lsr 1    ;raise dst.index                ;
 sub  r5,r2             ;decrease total.len             ;
 bl   memcopy_bytewise_halfwords                        ;/
 b    @@lop
@@lop_done:
;ldr  r6,=WifiData_rxbufOut
 str  r7,[r6]  ;dst.index               ;-apply new dst.index (for next packet)
 bl   arm7_synctoarm9   ;-call ARM7 sync handler (aka [arm7_synchandler])
 mov  r0,1      ;out: r0=1 (okay)
@@return_r0:
 pop  r4-r9,pc
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm7\source\wifi_arm7.c FLASH
;------------------
.data?
;arm7_synchandler dd 0    ; XXX shall be initially ZERO (!)
 keepalive_time   dd 0    ;
 chdata_save5     dd 0    ;/
;---
FlashData:      defs 512
.code
;------------------
;BLAH: original code contains several "ReadFlashXxx" functions, which do
;essentially read from memory [FlashData+n], so one could as well read
;from that memory directly, without using that functions (the functions
;can be useful for cases like "24bit reads" though)
;------------------
arm7_InitFlashData:  ;in/out: none
 mov  r0,0                 ;src ;\
 ldr  r1,=FlashData        ;dst ; load wifi flash firmware header
 mov  r2,200h              ;len ; (with wifi calibration data)
 b    arm7_readFirmware         ;/
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm7\source\wifi_arm7.c WFC Loading
;------------------
;BLAH: original code has TWO "crc16_slow" functions (one used, one outcommented)
;(neither of them is needed, because crc16 SWI function from BIOS can be used)
;XXXX, but the "crc16_slow" function is much more elegant than in gbatek
;(should adopt that there: simply XOR by "A001h" instead by "val[j] shl (7-j)"
;------------------
arm7_GetWfcSettings:  ;in/out: none
 ;BUGGED: original code relies only on CRC16 and entry [E6h]=00h, this will
 ;pass even on ZEROFILLED blocks (because Nintenndo had used 0000h as initial
 ;value, and updating the initial ZERO crc by ZERO data bytes results in ZERO)
 ;- - -
 ;to deal with ZERO checksum: check FLAGS (ie. [EFh].bit0-2 in FIRST block).
 ;- - -
 ;for DSi entries 4,5,6 one could also check that SSID length is 01h..20h
 ;(ie. [E8h] in CURRENT block), but that doesn't exist for NDS entries 1,2,3.
 ;- - -
 ;BLAH: original code computes ssid_len manually (instead of using [E8h])
 ;- - -
 ;XXX should also handle MTU entry (exist on DSi only, not on NDS)
 ;    (however, it won't exist on DSi either if configured by using a NDS game)
 ;XXX should also handle AOSS entries
 ;XXX on DSi, should also handle access points 4,5,6
 ;- - -
 ;XXXX nintendo didn't support that, but for fastest connection, one should
 ;also memorize the most recently used CHANNEL for EACH access point,
 ;and WHICH access point has been used most recently.
 ;  and, maybe also memorize RSSI for each access point, if RSSI is worse
 ;then previously, then it might make sense to search for a better access
 ;point (instead of trying to reconnect to the recently used one).
 ;  and, additionally, aside from WFC settings, connecting to OPEN NETWORKs
 ;should be also supported, even if they aren't listed in FLASH (except,
 ;local-network stuff like dslink wouldn't work too well, unless the desired
 ;local-network is NOT listed in WFC)
 ;- - -
 push r4-r7,lr
 sub  sp,100h   ;alloc buf
 ldr  r4,=WifiData_wfc_ap       ;\
 mov  r6,NUM_WFC_ENTRIES        ;
@@init_lop:                     ;
 mov  r0,0                      ; initially mark all entries as unused
 strb r0,[r4,sgWifiWfc_enable]  ;
 add  r4,sgWifiWfc_size         ;
 subs r6,1                      ;
 bne  @@init_lop                ;/
;- - -
 ldr  r1,=FlashData             ;\
 ldrh r5,[r1,20h]               ; get firmware offset for wifi settings
 mov  r5,r5,lsl 3  ;mul8        ; (address of user settings minus 400h)
 sub  r5,400h                   ;/
 add  r0,r5,0efh;wifi addr ;src ;\
 mov  r1,sp     ;buf       ;dst ; load FLAGS from wifi flash
 mov  r2,1      ;len       ;len ; (entry#1 [EFh] in FIRST block)
 bl   arm7_readFirmware         ;
 ldrb r7,[sp]   ;flags 1/2/3    ;
 and  r7,07h    ;isolate 1/2/3  ;/
 .if with_dsi_wifi
   ldr  r0,=001feh;wifi flash;src ;\
   mov  r1,sp     ;buf       ;dst ; load Wifi FLASH type from WifiHdr[001FEh]
   mov  r2,1      ;len       ;len ; (indicate with/without ap 4/5/6)
   bl   arm7_readFirmware         ;
   ldrb r0,[sp]   ;flash 4/5/6    ;
   cmp  r0,0ffh  ;\old nds value  ;
   moveq r0,10h  ;/               ;
   cmp  r0,20h   ;-new dsi value  ;
   blo  @@without_ap456           ;/
   add  r0,r5,0efh;wifi addr ;src ;\
   sub  r0,600h   ;entry#4   ;src ;
   mov  r1,sp     ;buf       ;dst ; load FLAGS from wifi flash
   mov  r2,1      ;len       ;len ; (entry#4 [EFh] in FIRST block)
   bl   arm7_readFirmware         ;
   ldrb r0,[sp]   ;flags 4/5/6    ;
   and  r0,07h    ;isolate 4/5/6  ;
   orr  r7,r7,r0,lsl 3  ;merge    ;/
        .if experimental_disable_ap123
          ;for enforcing WPA/WPA2... --- XXX for testing only
            ;and r7,01h ;ead.wep
            ;and r7,02h ;dlink.wep
            ;and r7,04h ;n/a
            ;and r7,08h ;dlink.wpa
            ;and r7,10h ;o2wlan64.wpa2   ;<-- worked a few times (only upon dhcp retries or so?)
            ;and r7,20h ;o2acc2.wpa2    ;FAIL disconnect? (works AFTER connection test)
               ;and r7,not 10h
        .endif
  @@without_ap456:
 .endif
;- - -
 ldr  r4,=WifiData_wfc_ap       ;\
 mov  r6,0      ;index          ; loop...
@@load_setting_lop:             ;/
 movs r7,r7,lsr 1  ;flags       ;\skip unused blocks (via flags)
 bcc  @@load_setting_next       ;/
 mov  r0,r5     ;wifi addr ;src ;\
 mov  r1,sp     ;buf       ;dst ; load entry from wifi flash
 mov  r2,100h   ;len       ;len ;
 bl   arm7_readFirmware         ;/
 mov  r0,0000h  ;initial        ;\compute CRC16 on the FEh-byte data
 mov  r1,sp     ;buf            ; AND on the appended 2-byte checksum
 mov  r2,0feh+2 ;len(data+crc)  ; (result will be 0000h on checksum match)
 swi  0eh shl 16  ;crc16        ; reject on mismatch
 cmp  r0,0000h                  ; CAUTION: will also match on ZEROFILLED blocks
 bne  @@load_setting_next  ;bad ;/
 ldrb r0,[sp,0e7h]              ;\
 cmp  r0,0ffh ;unused/deleted   ;
 beq  @@load_setting_next       ;
 cmp  r0,0ffh ;unused/deleted   ;
 beq  @@load_setting_next  ;bad ;
 cmp   r0,00h ;normal           ; check if entry is used/enabled
 cmpne r0,01h ;AOSS             ;
 cmpne r0,10h ;dsi:WPAx         ;
 cmpne r0,13h ;dsi:WPAx+WPS     ;
;cmpne r0,xxh ;dsi:WPAx+AOSS ?? ;
;cmpne r0,xxh ;dsi:NDS-USB   ?? ;
 bne  @@load_setting_next  ;bad ;/
;- - - okay, found a used block
;- - - apply PUBLIC data (which could be also obtained when scanning beacons)
 mov  r0,0                      ;\
 strb r0,[r4,sgWifiAp_channel]  ;
 strh r0,[r4,sgWifiAp_bssid+0]  ; initially set channel and BSSID to zero
 strh r0,[r4,sgWifiAp_bssid+2]  ;
 strh r0,[r4,sgWifiAp_bssid+4]  ;/
 add  r0,sp,40h            ;src ;\
 add  r1,r4,sgWifiAp_ssid  ;dst ; copy SSID (32 characters)
 mov  r2,20h               ;len ;
 call memcopy_bytewise          ;/
 add  r0,r4,sgWifiAp_ssid       ;\
 mov  r1,00h      ;\force       ; compute/apply SSID length (1..32)
 strb r1,[r0,20h] ;/eol         ; (entry 4/5/6 also have the length at [0E8h],
 bl   get_strlen                ; but entry 1/2/3 don't have that)
 strb r0,[r4,sgWifiAp_ssid_len] ;/
;- - - apply SECRET data (WEP keys, and user-specified Non-DHCP values)
 ldrb r0,[sp,0e6h]              ;\                      ;\
 and  r0,0fh  ;uh, what/why?    ; copy WEP mode         ;
 strb r0,[r4,sgWifiWfc_wepmode] ;/                      ;
 add  r0,sp,80h             ;src;\                      ; WEP key/mode
 add  r1,r4,sgWifiWfc_wepkey;dst; copy WEP key          ;
 mov  r2,10h                ;len; (16 bytes)            ;
 call memcopy_bytewise          ;/                      ;/
 ldr  r0,[sp,0C0h]              ;\copy IP               ;\
 str  r0,[r4,sgWifiWfc_ip]      ;/                      ;
 ldr  r0,[sp,0C4h]              ;\copy Gateway          ;
 str  r0,[r4,sgWifiWfc_gateway] ;/                      ; Non-DHCP settings
 ldr  r0,[sp,0C8h]              ;\copy 1st DNS          ; (all zero for DHCP)
 str  r0,[r4,sgWifiWfc_1st_dns] ;/                      ;
 ldr  r0,[sp,0CCh]              ;\copy 2nd DNS          ;
 str  r0,[r4,sgWifiWfc_2nd_dns] ;/                      ;
 ldrb r0,[sp,0D0h]              ;\                      ;
 rsb  r0,32 ;NumZeros=32-NumOnes; calc Subnet Mask      ;
 mov  r1,0ffffffffh             ;  NumZeroes=32-NumOnes ;
 mov  r0,r1,lsl r0  ;NumZeroes  ;  Mask=FFFFFFFFh shl N ;
 bl   htonl                     ;                       ;
 str  r0,[r4,sgWifiWfc_subnet]  ;/                      ;/
;- - - now load extra WPA/WPA2 data for 4/5/6 (if present, and only if needed)
 .if with_dsi_wifi
   mov  r0,0                      ;\initially mark WPA off
   strb r0,[r4,sgWifiWfc_wpamode] ;/
   cmp  r6,4-1  ;index            ;\only for entry 4/5/6
   blo  @@without_wpa_wpa2        ;/
   .if 0
     ldrb r0,[sp,0e8h]              ;\this exists for entry 4/5/6 only:
     sub  r0,1                      ; check that SSID length is 01h..20h
     cmp  r0,20h-1                  ; (reject 00h or 21h..FFh)
     bhi  @@load_setting_next  ;bad ;/
   .endif
   .if insist_on_selected_cipher
     ldrb r0,[sp,0e7h]  ;WPA/WPA2   ;\
     tst  r0,10h                    ; only if WPA/WPA2 used
     beq  @@without_wpa_wpa2        ;/
   .endif
   add  r0,r5,100h;wifi addr ;src ;\
   mov  r1,sp     ;buf       ;dst ; load entry extra bytes from wifi flash
   mov  r2,100h   ;len       ;len ;
   bl   arm7_readFirmware         ;/
   mov  r0,0000h  ;initial        ;\compute CRC16 on the FEh-byte data
   mov  r1,sp     ;buf            ; AND on the appended 2-byte checksum
   mov  r2,0feh+2 ;len(data+crc)  ; (result will be 0000h on checksum match)
   swi  0eh shl 16  ;crc16        ; reject on mismatch
   cmp  r0,0000h                  ; CAUTION: will also match on ZEROFILLED blocks
   bne  @@load_setting_next  ;bad ;/
   ldrb r0,[sp,081h]  ;aka 181h   ;\
   strb r0,[r4,sgWifiWfc_wpamode] ; copy WPA/WPA2 mode
   cmp  r0,0   ;0=none/wep ;\     ; done/okay if it's off,
   beq  @@without_wpa_wpa2 ;/     ;
  ;XXX with_nds_wpa...
   ldr  r1,=dsi_wifi_flag  ;\not  ; if it's on: refuse in NDS-mode!
   ldrb r1,[r1]            ; on   ; (XXX or maybe support WPA) (but refuse WPA2)
   cmp  r1,0    ;0=NDS     ; NDS  ;
   beq  @@load_setting_next;/     ;/
   add  r0,sp,00h   ;aka 100h ;src;\
   add  r1,r4,sgWifiWfc_psk   ;dst; copy PSK key for WPA/WPA2
   mov  r2,20h                ;len; (32 bytes)
   call memcopy_bytewise          ;/
        ;XXX could also apply proxy (and proxy name/password)
  @@without_wpa_wpa2:
 .endif
 mov  r0,80h                    ;\okay, mark entry as used
 strb r0,[r4,sgWifiWfc_enable]  ;/
 add  r4,sgWifiWfc_size         ;-next dest entry
;- - -
@@load_setting_next:            ;\
 .if with_dsi_wifi              ;
   cmp  r6,3-1  ;index          ;
   addlo r5,100h  ;1/2 --> 2/3  ;
   subeq r5,800h  ;3   --> 4    ; next source entry
   addhi r5,200h  ;4/5 --> 5/6  ;
 .else                          ;
   add  r5,100h  ;wifi addr     ;
 .endif                         ;
 add  r6,1     ;index           ;
 cmp  r6,NUM_WFC_ENTRIES        ;
 bne  @@load_setting_lop        ;/
 add  sp,100h   ;dealloc buf
 pop  r4-r7,pc
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm7\source\wifi_arm7.c Other Support
;------------------
        .if with_nds_wifi
;------------------
LED_LONGBLINK   equ 1
LED_SHORTBLINK  equ 3
LED_ON          equ 0
;---
.data?
led_state       dd 0
        ;XXXX_tx_log_request dd 0    ;XNAY
.code
;------------------
arm7_Wifi_BBRead:  ;in: r0=index, out: r0=data
 ldr  r3,=4808000h+100h
@@wait_lop1:                    ;\
 ldrh r2,[r3,W_BB_BUSY-100h]    ; wait if busy
 tst  r2,1                      ;
 bne  @@wait_lop1               ;/
 orr  r0,6000h                  ;\output index or 6000h
 strh r0,[r3,W_BB_CNT-100h]     ;/
@@wait_lop2:                    ;\
 ldrh r2,[r3,W_BB_BUSY-100h]    ; wait if busy
 tst  r2,1                      ;
 bne  @@wait_lop2               ;/
 ldrh r0,[r3,W_BB_READ-100h]    ;-read data (only 8bit used, MSB is zero)
 bx   lr
;------------------
arm7_Wifi_BBWrite:  ;in: r0=index, r1=data, out: r0=error
;note: original code supports BB-Write timeouts, but that feature seems useless
;(and anyways, it's supported only for BB-Writes, not for BB-Reads)
 ldr  r3,=4808000h+100h
@@wait_lop1:                    ;\
 ldrh r2,[r3,W_BB_BUSY-100h]    ; wait if busy
 tst  r2,1                      ;
 bne  @@wait_lop1               ;/
 strh r1,[r3,W_BB_WRITE-100h]   ;-output data (only lower 8bit used)
 orr  r0,5000h                  ;\output index or 5000h
 strh r0,[r3,W_BB_CNT-100h]     ;/
@@wait_lop2:                    ;\
 ldrh r2,[r3,W_BB_BUSY-100h]    ; wait if busy
 tst  r2,1                      ;
 bne  @@wait_lop2               ;/
 mov  r0,0      ;return r0=0=okay (no timeout)
 bx   lr
;------------------
arm7_Wifi_RFWrite:  ;in: r0=writedata, out: none
 ldr  r3,=4808000h+100h
@@wait_lop1:                            ;\
 ldrh r2,[r3,W_RF_BUSY-100h]            ; wait if busy
 tst  r2,1                              ;
 bne  @@wait_lop1                       ;/
 strh r0,[r3,W_RF_DATA1-100h]  ;LSW     ;\
 mov  r0,r0,lsr 16                      ; output data
 strh r0,[r3,W_RF_DATA2-100h]  ;MSW     ;/
@@wait_lop2:                            ;\
 ldrh r2,[r3,W_RF_BUSY-100h]            ; wait if busy
 tst  r2,1                              ;
 bne  @@wait_lop2                       ;/
 bx   lr
;------------------
arm7_PowerChip_ReadWrite:  ;in: r0=cmd, r1=data/write, out: r0=data/read
 mov  r3,4000000h
@@wait_lop1:                    ;\
 ldrb r2,[r3,REG_SPI_CNT]       ; wait if busy
 tst  r2,80h                    ;
 bne  @@wait_lop1               ;/
 mov  r2,8800h ;enable/pwr/start;\
 orr  r2,02h   ;baudrate        ; output CMD
 orr  r2,r2,r0,lsl 16  ;cmd     ;
 str  r2,[r3,REG_SPI_CNT_DATA]  ;/
@@wait_lop2:                    ;\
 ldrb r2,[r3,REG_SPI_CNT]       ; wait if busy
 tst  r2,80h                    ;
 bne  @@wait_lop2               ;/
 mov  r2,8000h ;enable/pwr/last ;\
 orr  r2,02h   ;baudrate        ; output DATA
 orr  r2,r2,r1,lsl 16  ;data    ; (or dummy if reading)
 str  r2,[r3,REG_SPI_CNT_DATA]  ;/
@@wait_lop3:                    ;\
 ldrb r2,[r3,REG_SPI_CNT]       ; wait if busy
 tst  r2,80h                    ;
 bne  @@wait_lop3               ;/
 ldrb r0,[r3,REG_SPI_DATA]      ;-read data
 bx   lr
;------------------
arm7_SetLedState:  ;in: r0=state, out: none
 push r4,lr
 mov  r4,r0 ;state
 cmp  r4,3                      ;\accept only state=0..3
 bhi  @@exit                    ;/
 ldr  r1,=led_state             ;\
 ldr  r1,[r1]                   ; exit if already same
 cmp  r4,r1                     ;
 beq  @@exit                    ;/
 str  r4,[r1]                   ;-apply new state in RAM
 mov  r0,0+80h ;index 0, read   ;\
 mov  r1,00h   ;data/dummy      ; read powerman[0]
 bl   arm7_PowerChip_ReadWrite  ;/
 and  r1,r0,0cfh ;strip bit4-5  ;\
 orr  r1,r1,r4,lsl 4  ;new bits ; write powerman[0] with new LED bits
 mov  r0,0+00h ;index 0, write  ;
 bl   arm7_PowerChip_ReadWrite  ;/
@@exit:
 pop  r4,pc
;------------------
arm7_ProxySetLedState:  ;in: r0=state, out: none
 ldr  r1,=WifiData_flags9       ;\
 ldr  r1,[r1]                   ; forward to LED
 tst  r1,WFLAG_ARM9_USELED      ; only if wanted
;mov  r0,r0  ;state             ;
 bne  arm7_SetLedState  ;-->    ;/
 bx   lr                        ;-else exit
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm7\source\wifi_arm7.c Main Stuff
;------------------
arm7_config_addr_list:
 ;uh, original code called this "RF_Reglist", unknown if/how it's "RF" related
 dw W_CONFIG_146h       ;\
 dw W_CONFIG_148h       ;
 dw W_CONFIG_14Ah       ;
 dw W_CONFIG_14Ch       ;
 dw W_CONFIG_120h       ; addresses for 10h wifi registers
 dw W_CONFIG_122h       ; (to be initialized from wifi flash [044h and up])
 dw W_CONFIG_154h       ;
 dw W_CONFIG_144h       ;
 dw W_CONFIG_130h       ;
 dw W_CONFIG_132h       ;
 dw W_CONFIG_140h       ;
 dw W_CONFIG_142h       ;
 dw W_POWER_TX          ;
 dw W_CONFIG_124h       ;
 dw W_CONFIG_128h       ;
 dw W_CONFIG_150h       ;/
;------------------
arm7_Wifi_RFInit:  ;in/out: none
 ;BUGGED: original code stores "number of RF entries" in a variable called
 ;"numchannels", that's certainly wrong, it's not related to "channels".
 ;BUGGED: channel_extrabytes should be "((channel_extrabits AND 1Fh)+7)/8",
 ;(or maybe "AND 3Fh" to allow 32bit length), anyways, MSBs of channel_extrabits
 ;have unknown purpose, especially bit7 is something else than bitcount.
 ;- - -
 push r4-r9,lr
 ldr  r6,=FlashData                             ;-
 ldr  r7,=4808000h                              ;-
 ldr  r0,=arm7_config_addr_list ;addr.list      ;\
 add  r1,r6,44h  ;wifi flash    ;data.list      ;
 mov  r2,10h                    ;num.entries    ; init W_CONFIG_xxx with
@@config_lop:                                   ; data from wifi flash
 ldrh r4,[r0],2  ;addr.list                     ;
 ldrh r5,[r1],2  ;data.list                     ;
 strh r5,[r7,r4] ;WifiReg[addr]=data  ;W_xxx    ;
 subs r2,1                                      ;
 bne  @@config_lop                              ;/
;- - -
 ldrb r4,[r6,41h] ;wifi flash                   ;\get and apply
 and  r0,r4,80h   ;isolate bit7                 ; width of RF entries
 add  r4,r0       ;move bit7 to bit8            ; (num_bits)
 ldr  r1,=4808000h+100h                         ;
 strh r4,[r1,W_RF_CNT-100h]                     ;/
 and  r4,3Fh ;isolate num_bits (for below loop) ;-num_bits
 ldrb r5,[r6,42h] ;wifi flash ;num_items        ;-num_items
 add  r8,r6,0CEh  ;ptr to wifi_data+CEh         ;-src addr
 ldrb r9,[r6,40h]  ;wifi flash                  ;\
 cmp  r9,03h                                    ; get and check type
 beq  @@type3                                   ;/
;- - -
@@item_lop:                                                     ;\
 mov   r0,0      ;data=0        ;\                              ;
 mov   r2,0      ;bit_number    ;                               ; init Type2
@@bit_lop:                      ; get data (with                ; (or Type5)
 ldrb  r1,[r8],1                ; size depending                ;
 orr   r0,r0,r1,lsl r2  ;data   ; on num_bits)                  ;
 add   r2,8      ;bit_number    ;                               ;
 cmp   r2,r4     ;cmp num_bits  ;                               ;
 blo   @@bit_lop                ;/                              ;
 cmp   r9,02h    ;type          ;\if Type2 (not Type5)          ;
 moveq r1,r0,lsr 18             ; and RF index=9,               ;
 cmpeq r1,9                     ; then memorize data            ;
 ldreq r2,=chdata_save5         ; as RF[9] value                ;
 biceq r1,r0,7c00h ;bit10-14=0  ; (with bit10-14=0)             ;
 streq r1,[r2]   ;data          ;/                              ;
;mov   r0,r0     ;data          ;\issue RF write                ;
 bl    arm7_Wifi_RFWrite        ;/                              ;
 subs r5,1            ;num_items                                ;
 bne  @@item_lop                                                ;/
 b    @@done
;---
@@type3:
 mov  r7,00h          ;index                                    ;\
@@type3_item_lop:                                               ;
 ldrb r0,[r8],1       ;data = wifi_data[CEh+index]  ;\          ; init Type3
 orr  r0,r0,r7,lsl 8  ;data+index*100h              ; RF[index] ;
 orr  r0,50000h       ;data+index*100h+50000h       ;           ;
 bl   arm7_Wifi_RFWrite                             ;/          ;
 add  r7,1            ;index                                    ;
 cmp  r7,r5           ;num_items                                ;
 bne  @@type3_item_lop                                          ;/
@@done:
 pop  r4-r9,pc
;------------------
arm7_Wifi_BBInit:  ;in/out: none
 push r4-r5,lr
 ldr  r3,=4808000h+100h         ;\
 mov  r0,0100h                  ; init BB mode
 strh r0,[r3,W_BB_MODE-100h]    ;/
 ldr  r4,=FlashData+64h  ;src   ;\
 mov  r5,0      ;BB index       ;
@@init_bb_lop:                  ;
 mov  r0,r5     ;BB index       ; init BB[0..68h] from wifi flash
 ldrb r1,[r4],1 ;BB data        ;
 bl   arm7_Wifi_BBWrite         ;
 add  r5,1      ;BB index       ;
 cmp  r5,69h                    ;
 bne  @@init_bb_lop             ;/
 pop  r4-r5,pc
;------------------
arm7_Wifi_MacInit:  ;in/out: none
 ldr  r0,=arm7_reg_list_mac_init        ;\
 b    arm7_Wifi_write_register_list     ;/
;---
arm7_reg_list_mac_init:
 dw W_MODE_RST      ,0
 dw W_TXSTATCNT     ,0
 dw W_X_00Ah        ,0
 dw W_IE            ,0
 dw W_IF            ,0FFFFh
 dw W_CONFIG_254h   ,0
 dw W_TXBUF_RESET   ,0FFFFh
 dw W_TXBUF_BEACON  ,0
 dw W_AID_FULL      ,0
 dw W_AID_LOW       ,0
 dw W_US_COUNTCNT   ,0
 dw W_US_COMPARECNT ,0
 dw W_CMD_COUNTCNT  ,1
 dw W_CONFIG_0ECh   ,3F03h
 dw W_X_1A2h        ,1
 dw W_X_1A0h        ,0
 dw W_PRE_BEACON    ,0800h
 dw W_PREAMBLE      ,1
 dw W_CONFIG_0D4h   ,3
 dw W_CONFIG_0D8h   ,4
 dw W_RX_LEN_CROP   ,0602h
 dw W_TXBUF_GAPDISP ,0
 dw 0,0  ;end of list
;------------------
arm7_Wifi_write_register_list:  ;in: r0=list
 ldr  r3,=4808000h                      ;\
@@lop:                                  ;
 ldrh r1,[r0],2  ;addr                  ; init wifi regs from addr/data list
 ldrh r2,[r0],2  ;data                  ;
 cmp  r1,0000h   ;end of list           ;
 strneh r2,[r3,r1] ;WifiReg[addr]=data  ;
 bne  @@lop                             ;/
 bx   lr
;------------------
arm7_Wifi_WakeUp:  ;in/out: none
 push r4,lr
 ldr  r1,=4808000h              ;\
 mov  r4,0                      ; enable BB and US_COUNT
 strh r4,[r1,W_POWER_US]        ;/
 bl   arm7_delay_8000us         ;-delay
 ldr  r1,=4808000h+100h         ;\
;mov  r4,0                      ; wakeup BB
 strh r4,[r1,W_BB_POWER-100h]   ;/
 mov  r0,01h     ;index         ;\
 bl   arm7_Wifi_BBRead          ;
 mov  r4,r0      ;old data      ; old = BB[01h]
 and  r1,r0,7fh  ;data AND 7Fh  ;
 mov  r0,01h     ;index         ; BB[01h] = old AND 7Fh
 bl   arm7_Wifi_BBWrite         ;
 mov  r1,r4      ;old data      ; BB[01h] = old
 mov  r0,01h     ;index         ;
 bl   arm7_Wifi_BBWrite         ;/
 bl   arm7_delay_40000us        ;-delay
 bl   arm7_Wifi_RFInit          ;-init RF registers
 pop  r4,pc
;------------------
arm7_Wifi_Shutdown:  ;in/out: none
 push lr
 ldr  r0,=FlashData+40h         ;\
 ldrb r0,[r0]                   ; for Type2 only:
 cmp  r0,02h  ;Type2            ; change a RF register
 ldreq r0,=00C008h        ;\    ;
 bleq  arm7_Wifi_RFWrite  ;/    ;/
 mov  r0,1Eh     ;index         ;\
 bl   arm7_Wifi_BBRead          ;
 orr  r1,r0,3Fh  ;data OR 3Fh   ; BB[1Eh]=BB[1Eh] or 3Fh
 mov  r0,1Eh     ;index         ;
 bl   arm7_Wifi_BBWrite         ;/
 ldr  r3,=4808000h+100h         ;\
 ldr  r0,=800dh                 ; disable BB
 strh r0,[r3,W_BB_POWER-100h]   ;/
 ldr  r3,=4808000h              ;\
 mov  r0,1                      ; disable BB and US_COUNT
 strh r0,[r3,W_POWER_US]        ;/
 pop  pc
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm7\source\wifi_arm7.c Mac Copy
;------------------
;MAC Copy functions (aka WifiRAM copy)
;------------------
arm7_Wifi_MACRead:  ;in: r0=MAC_Base, r1=MAC_Offset, out: r0=u16  ;"inline"
 ;read one halfword from WifiRAM
 ;- - -
 add  r0,r1     ;base+offset
 cmp   r0,WIFIRAM_RX_BUFFER_SIZE+WIFIRAM_RX_BUFFER_START        ;\wrap
 subhs r0,WIFIRAM_RX_BUFFER_SIZE                                ;/
 ldr  r1,=4804000h
 ldrh r0,[r1,r0]        ;out: r0=WifiRAM[addr]  ;16bit (halfword)
 bx   lr
;------------------
arm7_Wifi_MACCopy:  ;in: r0=u16 * dest, r1=u32 MAC_Base, r2=u32 MAC_Offset, r3=length, out: none
 ;memcopy from WifiRAM to normal memory (same as below, in opposite direction)
 ;- - -
 push r4-r5,lr
 mov  r4,r3     ;total.len
 add  r2,r1     ;src=base+offset
 mov  r1,r0     ;dst
 ldr  r3,=4804000h
 add  r0,r2,r3  ;src=base+offset+WifiRAM
 add  r5,r3,WIFIRAM_RX_BUFFER_SIZE+WIFIRAM_RX_BUFFER_START  ;rx.buf.top
@@lop:
 cmp  r0,r5     ;src,end                ;\wrap src
 subhs r0,WIFIRAM_RX_BUFFER_SIZE        ;/
 movs r2,r4     ;total.len              ;\
 beq  @@done                            ;
 sub  r3,r5,r0  ;part.len = top-src     ; len
 cmp   r2,r3                            ;
 movhi r2,r3    ;part.len               ;/
;mov  r0,r0           ;src (WifiRAM)    ;\
;mov  r1,r1           ;dst (normal mem) ; copy
;mov  r2,r2           ;len              ;
 sub  r4,r2  ;decrease total.len        ;
 bl   memcopy_bytewise_halfwords        ;/
 b    @@lop
@@done:
 pop  r4-r5,pc
;------------------
arm7_Wifi_MACWrite:  ;in: r0=src, r1=MAC_Base, r2=MAC_Offset, r3=length, out: none
 ;memcopy from normal memory to WifiRAM (same as above, in opposite direction)
 ;- - -
 ;BLAH: original code wraps at <RX> buffer end (although data is written to TX
 ;buffer (or TX beacon buffer), so wrapping at RX buffer end is total nonsense).
 ;Wrapping would make sense at <TX> buffer end (but the TX functions are using
 ;fixed packet addresses (so circular buffers wrapping isn't needed for TX)
 ;- - -
 ;BUGGED: original code did actually use <bugged> wrapping (messing up its
 ;"length" and "thislength" variables, anyways wrapping never occurs for TX,
 ;so the bug doesn't harm in practice).
 ;- - -
 ;XXX could/should use faster 32bit transfer (when alignment is okay)
 ;XXX or use "memcopy_bytewise_halfwords"
 ;XXX or even better, use DMA when possible
 ;- - -
 add  r1,r2     ;dst=base+offset
 ldr  r2,=4804000h
 add  r1,r2     ;dst=base+offset+WifiRAM
@@lop:
 ldrh r2,[r0],2  ;src (normal memory)
 strh r2,[r1],2  ;dst (WifiRAM)
 subs r3,2
 bne  @@lop
 bx   lr
;------------------
ARM7_QUEUE_SIZE     equ 2048  ;2Kbyte (1024 halfwords)
;---
.data?
arm7q:              defs ARM7_QUEUE_SIZE
arm7qlen            dd 0
.code
;------------------
arm7_Wifi_TxRaw:  ;in: r0=data/src, r1=datalen, out: none
 push lr
 add  r3,r1,3                                           ;\round-up length
 bic  r3,3                                              ;/
 ldr  r1,=WifiData_stats                                ;\
 ldr  r2,[r1,WSTAT_TXPACKETS*4]   ;\                    ;
 add  r2,1                        ; num TX packets      ;
 str  r2,[r1,WSTAT_TXPACKETS*4]   ;/                    ; raise stats
 ldr  r2,[r1,WSTAT_TXBYTES*4]     ;\                    ;
 add  r2,r3                       ; num TX bytes        ;
 str  r2,[r1,WSTAT_TXBYTES*4]     ;/                    ;
 ldr  r2,[r1,WSTAT_TXDATABYTES*4] ;\                    ;
 add  r2,r3                       ; num TX DATA bytes   ;
 sub  r2,12  ;exclude header      ;                     ;
 str  r2,[r1,WSTAT_TXDATABYTES*4] ;/                    ;/

.if 0       ;XNAY
push r0-r7
mov  r4,r0 ;src
mov  r5,r3 ;len
@@lop:
ldrb r0,[r4],1
mov  r6,r0
mov  r0,r0,lsr 4
cmp  r0,09h
addhi r0,07h
add r0,30h
bl  wrchr_r0
and  r0,r6,0fh
cmp  r0,09h
addhi r0,07h
add r0,30h
bl  wrchr_r0
mov r0,20h
bl  wrchr_r0
subs r5,1
bne @@lop
pop  r0-r7
.endif

;mov  r0,r0                     ;src (normal memory)    ;\
 mov  r1,WIFIRAM_TX_LOC3_START  ;dst (WifiRAM)          ; copy to WifiRAM
 mov  r2,0                      ;dst.offset             ;
;mov  r3,r3                     ;len                    ;
 bl   arm7_Wifi_MACWrite                                ;/
;- - -
 .if with_soft_wep
   bl   wifi_encrypt_loc3               ;-
 .endif
;- - -
 ldr  r3,=4808000h
 ldr  r0,=0101h*SGIP_TX_RETRIES         ;\TX retry limit
 strh r0,[r3,W_TX_RETRYLIMIT]           ;/
 mov  r0,8000h+(WIFIRAM_TX_LOC3_START/2);\TX addr (and start TX via bit15)
 strh r0,[r3,W_TXBUF_LOC3]              ;/
 mov  r0,000dh                          ;\TX request/enable (uh, blah?)
 strh r0,[r3,W_TXREQ_SET]               ;/
 pop  pc
;------------------
arm7_Wifi_TxCheck:  ;in: none, out: r0=ready
 ldr  r3,=4808000h              ;\
 ldrh r2,[r3,W_TXBUSY]          ; check if TX busy
 tst  r2,0008h  ;LOC3 busy      ;/
 movne r0,0  ;out: r0=0=busy
 moveq r0,1  ;out: r0=1=ready
 bx    lr
;------------------
.data?
beacon_channel      dw 0   ;Wifi RAM address of beacon's channel (0..1FFEh)
.align 4
.code
;------------------
.if with_gimmicks  ;needed only for TRANSMITTING beacons
arm7_Wifi_LoadBeacon:  ;in: r0=from, r1=to, out: none
 ;BLAH: original code does temporarily copy the source data to stack, and
 ;then copies it from stack to dest (although data could be copied directly,
 ;without needing to recurse wrapping ring-buffer addresses). and the stack
 ;area is limited to 512 bytes (slightly smaller than WIFIRAM_TX_BEACON_SIZE).
 ;and, exceeding the max len should disable beacon (as when len too small).
 ;- - -
 push r4-r10,lr
 mov  r4,r0  ;from
 mov  r5,r1  ;to
 ldr  r6,=4804000h  ;WifiRAM
 ldr  r7,=4808000h  ;WifiIO
 mov  r0,r4  ;from                      ;\
 mov  r1,10  ;index                     ; get len
 bl   arm7_Wifi_MACRead                 ;
 add  r8,r0,12-4  ;len                  ;/
 cmp  r8,12+24+12                       ;\
 bls  @@bad_length                      ; check min/max len
 cmp  r8,WIFIRAM_TX_BEACON_SIZE         ;
 bhi  @@bad_length                      ;/
 add  r0,r6,r4  ;WifiRAM+from      ;src ;\
 add  r1,r6,r5  ;WifiRAM+to        ;dst ; copy from --> to
 add  r2,r8,1   ;len+1             ;len ; (aka from TX_LOC3 to TX_BEACON)
 bic  r2,1      ;align len         ;len ;
 bl   memcopy_bytewise_halfwords        ;/
;- - -
 add  r10,r6,r5  ;WifiRAM+to
 mov  r9,12+24+12       ;index
@@scan_lop:
 cmp  r9,r8  ;index,len                 ;\
 bhs  @@scan_done                       ;/
 ldrb r0,[r10,r9]  ;tag                 ;\
 add  r9,1                              ; fetch tag,len
 ldrb r1,[r10,r9]  ;item_len            ;
 add  r9,1                              ;/
 cmp  r0,03h  ;tag=channel              ;\
 bne  @@not_channel                     ; tag=channel
 ldr  r2,=beacon_channel                ;  ;\
 add  r3,r5,r9  ;to+index               ;  ; memorize address of beacon channel
 strh r3,[r2]                           ;  ;/
@@not_channel:                          ;/
 cmp  r0,05h  ;tag=TIM                  ;\
 bne  @@not_tim                         ; tag=TIM
 sub  r3,r9,12+24              ;\       ;  ;\TIM offset within beacon
 strh r3,[r7,W_TXBUF_TIM]      ;/       ;  ;/
 add  r3,r9,1  ;index+1        ;\       ;  ;\
 ldrb r3,[r10,r3]              ;        ;  ; listen interval
 strh r3,[r7,W_LISTENINT]      ;/       ;  ;/
 ldrh   r2,[r7,W_LISTENCOUNT]  ;\       ;  ;\
 cmp    r3,r2                  ;        ;  ; listen count
 strloh r3,[r7,W_LISTENCOUNT]  ;/       ;  ;/
@@not_tim:                              ;/
 add  r9,r1                             ;-skip item_len
 b    @@scan_lop
@@scan_done:
 mov  r0,r5,lsr 1  ;to/2                ;\
 orr  r0,8000h     ;to/2+8000h (enable) ; apply beacon location
 strh r0,[r7,W_TXBUF_BEACON]            ;/
 ldrh r0,[r10,12+24+8]                  ;\apply [WifiRAM+to+12+24+8]
 strh r0,[r7,W_BEACONINT]               ;/as beacon interval
 b    @@done
;---
@@bad_length:
 mov  r0,0                              ;\disable beacon transmission
 strh r0,[r7,W_TXBUF_BEACON]            ;/
 mov  r0,0064h                          ;\set some dummy beacon interval (BLAH?)
 strh r0,[r7,W_BEACONINT]               ;/
@@done:
 pop  r4-r10,pc
.endif
;------------------
.if with_gimmicks  ;needed only for TRANSMITTING beacons
arm7_Wifi_SetBeaconChannel:  ;in: r0=channel, out: none
 ldr  r3,=4808000h              ;\
 ldrh r2,[r3,W_TXBUF_BEACON]    ; only if actually transmitting beacons
 tst  r2,8000h                  ;
 beq  @@exit                    ;/
 ldr  r2,=beacon_channel        ;\
 ldrh r2,[r2]  ;0..1FFFh        ; get address of channel byte
 ldr  r3,=4804000h              ; (if beacon's Wifi RAM area)
 add  r2,r3    ;4804000h..      ;/
 mov  r1,0ffh  ;BIC mask        ;\
 tst  r2,1  ;alignment          ; get location of that byte within halfword
 movne r0,r0,lsl 8 ;data to MSB ; (Wifi RAM can be written ONLY in halfword
 movne r1,r1,lsl 8 ;mask to MSB ; units; STRB byte writes are ignored)
 bicne r2,1        ;force align ;/
 ldrh  r3,[r2]                  ;\
 bic   r3,r1   ;strip old       ; apply new channel byte within the halfword
 orr   r3,r0   ;set new         ;
 strh  r3,[r2]                  ;/
@@exit:
 bx   lr
.endif
;------------------
.pool
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm7\source\wifi_arm7.c WifiIrq RX/TX
;------------------
;Wifi Interrupts...
;------------------
arm7_Wifi_Intr_RxEnd:  ;in/out: none
 push r4-r8,lr
 bl   arm7_disable_ime          ;\disable IME
 mov  r4,r0                     ;/
 ldr  r5,=4808000h
 mov  r6,6  ;limit max r6 packets
@@rx_packet_lop:
 ldrh r0,[r5,W_RXBUF_WRCSR]             ;\
 ldrh r1,[r5,W_RXBUF_READCSR]           ; check if data in rx queue
 cmp  r0,r1                             ;
 beq  @@rx_packet_lop_done              ;/
 mov  r7,r1,lsl 1  ;macbase=READCSR*2   ;-get base
 mov  r0,r7  ;macbase                   ;\
 mov  r1,8   ;index                     ;
 bl   arm7_Wifi_MACRead                 ; get length
 add  r8,r0,12+3 ;len                   ;
 bic  r8,3       ;len, align            ;/
 ldr  r1,=WifiData_stats                ;\
 ldr  r0,[r1,WSTAT_RXPACKETS*4]      ;\ ;
 add  r0,1                           ;  ;
 ldr  r0,[r1,WSTAT_RXPACKETS*4]      ;/ ;
 ldr  r0,[r1,WSTAT_RXBYTES*4]        ;\ ; raise stats
 add  r0,r8                          ;  ;
 ldr  r0,[r1,WSTAT_RXBYTES*4]        ;/ ;
 ldr  r0,[r1,WSTAT_RXDATABYTES*4]    ;\ ;
 add  r0,r8                          ;  ;
 sub  r0,12  ;exclude hw header      ;  ;
 ldr  r0,[r1,WSTAT_RXDATABYTES*4]    ;/ ;/

 .if with_soft_wep
   push r8  ;---> len (unadjusted)
   mov  r0,r7  ;macbase                   ;\overall DECRYPT HERE...
   bl   wifi_decrypt                      ;/
   mov  r0,r7  ;macbase                   ;\
   mov  r1,8   ;index                     ;
   bl   arm7_Wifi_MACRead                 ; get length (adjusted)
   add  r8,r0,12+3 ;len                   ;
   bic  r8,3       ;len, align            ;/
 .endif

 mov  r0,r7  ;macbase                   ;\
 mov  r1,r8  ;len                       ; process packet
 bl   arm7_Wifi_ProcessReceivedFrame    ; (returns packet type/flag, or 0)
;mov  r0,r0  ;flag (WFLAG_PACKET_xxx)   ;/
 ldr  r1,=WifiData_reqPacketFlags       ;\
 ldr  r1,[r1]                           ; check if above indicated
 tst  r1,r0   ;type (from above call)   ; a requested type (or if
 ldreq  r1,=WifiData_reqReqFlags        ; "PROMISC" is requested),
 ldreqh r1,[r1]                         ; ignore packet if not so
 tsteq  r1,WFLAG_REQ_PROMISC            ;
 beq  @@ignore_packet                   ;/
 ldr  r1,=keepalive_time                ;\
 mov  r0,0                              ; okay, reset keepalive (uh, upon RECEIVE? shouldn't it be done only when SENDING something to access point? so the access point KNOWS the connection is alive)
 str  r0,[r1]                           ;/
;- - -
 ldr  r2,=4804000h                                      ;\
 add  r0,r7,r2  ;src+macbase                            ;
 mov  r1,r8     ;len                                    ; okay,
 add  r2,WIFIRAM_RX_BUFFER_SIZE+WIFIRAM_RX_BUFFER_START ; forward to rx queue
 mov  r3,WIFIRAM_RX_BUFFER_SIZE  ;wrap.size             ;
 bl   arm7_Wifi_QueueRxMacData   ;--->                  ;
;cmp  r0,0  ;error (ignored for now)                    ;/
@@ignore_packet:
;- - -
 .if with_soft_wep
   pop  r8  ;<--- len (unadjusted)
 .endif

 add   r0,r7,r8     ;macbase+len                                ;\
 cmp   r0,WIFIRAM_RX_BUFFER_SIZE+WIFIRAM_RX_BUFFER_START ;\wrap ; raise rx
 subhs r0,WIFIRAM_RX_BUFFER_SIZE                         ;/     ; read addr
 mov   r0,r0,lsr 1                                              ;
 strh  r0,[r5,W_RXBUF_READCSR]                                  ;/
 subs r6,1                      ;\process more packets (if any, max r6)
 bne  @@rx_packet_lop           ;/
@@rx_packet_lop_done:
 mov  r0,r4                     ;\restore IME
 bl   arm7_restore_ime          ;/
 pop  r4-r8,pc
;------------------
arm7_Wifi_Intr_TxEnd:  ;in/out: none
 push r4,lr
 ldr  r4,=4808000h
 ldr  r1,=WifiData_stats        ;\
 ldrh r2,[r4,W_TXBUF_LOC3]      ;
 and  r2,8000h  ;isolate bit15  ;
 ldrh r3,[r4,W_TXBUSY]          ; stats
 bic  r3,8000h  ;clr bit15      ;
 orr  r2,r3     ;merge          ;
 str  r2,[r1,WSTAT_DEBUG*4]     ;/
 bl   arm7_Wifi_TxCheck         ;\
 cmp  r0,0      ;0=busy         ; exit if old TX is still busy
 beq  @@exit                    ;/
 ldr  r1,=arm7qlen              ;\
 ldr  r1,[r1]                   ;
 cmp  r1,0                      ; if there's ARM7 data queued,
 beq  @@no_arm7_data            ; send that now (instead of ARM9 data)
 ldr  r0,=arm7q   ;src  ;\      ;
;mov  r1,r1       ;len  ;       ;
 bl   arm7_Wifi_TxRaw   ;/      ;
 mov  r0,0                      ;
 ldr  r1,=keepalive_time        ;
 str  r0,[r1]     ;=0           ;
 ldr  r1,=arm7qlen              ;
 str  r0,[r1]     ;=0           ;
 b    @@exit            ;-->    ;
@@no_arm7_data:                 ;/
;- - -
 ldr  r0,=4804000h+WIFIRAM_TX_LOC3_START;\copy packet to TX_LOC3 in WifiRAM
 bl   arm7_Wifi_CopyFirstTxData         ; (exit if failed; ie. queue empty,
 cmp  r0,0   ;0=failed                  ; or packet not fully queued yet)
 beq  @@exit ;--> oops                  ;/
;- - -
 ldr  r1,=WIFIRAM_BASE32+WIFIRAM_TX_LOC3_START  ;-txhdr...
 ldrh r0,[r1,08h]   ;txhdr.rate ;\
 cmp  r0,0                      ; if rate dne, fill it in
 ldreq  r0,=WifiData_maxrate7   ;   ;uh, what means "dne" ?
 ldreqb r0,[r0]                 ;   (maybe Did/Do/Does Not Enter/Exist/Erase?)
 streqh r0,[r1,08h] ;txhdr.rate ;/
;XXXsoft_wep
 ldrh r0,[r1,0ch]   ;FC:        ;\
 tst  r0,4000h      ;FC.WEP flag;
 beq  @@no_wep                  ; if WEP enabled,
 ldrh r0,[r4,W_RANDOM]          ; fill in the IV
 eor  r0,r0,r0,lsl 7            ;
 eor  r0,r0,r0,lsl 15           ;
 strh r0,[r1,24h+0]             ;
 ldrh r0,[r4,W_RANDOM]          ;
 eor  r0,r0,r0,lsr 7            ;
 and  r0,00ffh                  ;
 ldr  r2,=WifiData_wepkeyid7    ;
 ldrb r2,[r2]                   ;
 orr  r0,r0,r2,lsl 14  ;id      ;
 strh r0,[r1,24h+2]             ;
@@no_wep:                       ;/
.if with_gimmicks
 ldrh r0,[r1,0ch]   ;FC:        ;\
 cmp  r0,0080h   ;Mgmt, Beacon  ; if FrameControl = Beacon
 bne  @@no_beacon               ; then
 mov  r0,WIFIRAM_TX_LOC3_START  ; copy packet from TX_LOC3 to TX_BEACON
 mov  r1,WIFIRAM_TX_BEACON_START; (and let it be sent repeatedly via
 bl   arm7_Wifi_LoadBeacon      ; TX_BEACON, ie. EXIT now, WITHOUT
 b    @@exit            ;-->    ; sending it via LOC3)
@@no_beacon:                    ;/
.endif

       .if show_tx_info
         ldr  r1,=WIFIRAM_BASE32+WIFIRAM_TX_LOC3_START  ;-txhdr...
         ldrh r0,[r1,0ch+4+6+6]  ;DA
         bl wrhex16bit
         ldrh r0,[r1,0ah]  ;len
         bl wrhex16bit
         bl wrdot
         bl wrdot
       .endif
;- - -
 .if with_soft_wep
   bl   wifi_encrypt_loc3               ;-
 .endif
;- - -
 ldr  r0,=0101h*SGIP_TX_RETRIES         ;\      ;\
 strh r0,[r4,W_TX_RETRYLIMIT]           ;/      ; okay, send via TX_LOC3
 mov  r0,8000h+(WIFIRAM_TX_LOC3_START/2);\      ;
 strh r0,[r4,W_TXBUF_LOC3]              ;/      ;
 mov  r0,000dh                          ;\      ;
 strh r0,[r4,W_TXREQ_SET]               ;/      ;/
@@exit:
 pop  r4,pc
;------------------
.if with_gimmicks
arm7_Wifi_Intr_CntOverflow:  ;in/out: none   ;half-overflow's
 push r4-r5,lr
 ldr  r1,=count_ofs_list              ;src.list
 mov  r2,8+2+8                        ;lopcount
 ldr  r3,=4808000h
 ldr  r4,=WifiData_stats+(WSTAT_HW_1B0*4)  ;dst
@@lop:
 ldrh r0,[r1],2   ;list                         ;\
 ldrh r0,[r3,r0]  ;W_STAT_xxx  ;read 16bit!     ;
 ldr  r5,[r4,4]         ;\                      ; update TWO entries at once
 add  r5,r5,r0,lsr 8    ; MSB                   ; (must be done so, because
 ldr  r5,[r4,4]         ;/                      ; reading auto-clears BOTH
 and  r0,0ffh   ;lsb                            ; 8bit fields in 16bit source)
 ldr  r5,[r4,0]         ;\                      ;
 add  r5,r0             ; LSB                   ;
 ldr  r5,[r4],4+4       ;/                      ;/
 subs r2,1
 bne  @@lop
 pop  r4-r5,pc
;---
count_ofs_list:
 dw W_RXSTAT_1B0    ;\
 dw W_RXSTAT_1B2    ;
 dw W_RXSTAT_1B4    ;
 dw W_RXSTAT_1B6    ;
 dw W_RXSTAT_1B8    ;
 dw W_RXSTAT_1BA    ;
 dw W_RXSTAT_1BC    ;
 dw W_RXSTAT_1BE    ;/
 dw W_TX_ERR_COUNT  ;\
 dw W_RX_COUNT      ;/
 dw W_CMD_STAT_1D0  ;\
 dw W_CMD_STAT_1D2  ;
 dw W_CMD_STAT_1D4  ;
 dw W_CMD_STAT_1D6  ;
 dw W_CMD_STAT_1D8  ;
 dw W_CMD_STAT_1DA  ;
 dw W_CMD_STAT_1DC  ;
 dw W_CMD_STAT_1DE  ;/
.endif
;------------------
;arm7_Wifi_Intr_DoNothing:  ;in/out: none
; bx   lr       ;BLAH
;------------------
arm7_Wifi_Interrupt:  ;in/out: none
 ;BUGGED: when not running/initialized, original code does exit WITHOUT
 ;acknowledging the IRQ (that'll hang the CPU by re-trying to handle the IRQ
 ;again and again) (it should first acknowledge IF and W_IF, and then exit)
 ;- - -
 push r4,lr
 mov  r1,4000000h               ;\
 mov  r0,IRQ_WIFI               ; ack IF.24 (wifi)
 str  r0,[r1,REG_IF]            ;/
 ldr  r3,=4808000h              ;\
 mov  r4,0  ;irq's              ;
@@try_more:                     ; get (W_IF AND W_IE),
 ldrh r1,[r3,W_IE]              ; ack W_IF,
 ldrh r0,[r3,W_IF]              ; and,

.if with_gimmicks
 XXXX BUGGED: fixme:
 Half-Overflow IRQs cannot be acknowledged before reading the counters!
.endif

 ands r0,r1           ;---> zf  ; make sure really ALL acknowledged
 orr  r4,r0 ;irq's              ; (else IF.24 won't trigger again)
 strneh r0,[r3,W_IF]  ;ack      ;
 bne    @@try_more    ;<--- zf  ;/

 ldr  r0,=arm7_WifiData         ;\
 ldr  r0,[r0]                   ; exit if not yet initialized
 cmp  r0,0                      ;
 beq  @@exit                    ;/
 ldr  r0,=WifiData_flags7       ;\
 ldr  r0,[r0]                   ; exit if not running
 tst  r0,WFLAG_ARM7_RUNNING     ;
 beq  @@exit                    ;/

 tst r4,01h     // blne arm7_Wifi_Intr_RxEnd            ;\
 tst r4,02h     // blne arm7_Wifi_Intr_TxEnd            ; process IRQ's
.if with_gimmicks
 tst r4,10h+20h // blne arm7_Wifi_Intr_CntOverflow      ;/
.endif
;- - -
;0001h // arm7_Wifi_Intr_RxEnd
;0002h // arm7_Wifi_Intr_TxEnd
;0004h // arm7_Wifi_Intr_RxEventIncrement
;0008h // arm7_Wifi_Intr_TxErrorIncrement
;0010h // arm7_Wifi_Intr_RxEventHalfOverflow
;0020h // arm7_Wifi_Intr_TxErrorHalfOverflow
;0040h // arm7_Wifi_Intr_RxStart
;0080h // arm7_Wifi_Intr_TxStart
;0100h // arm7_Wifi_Intr_TxCountExpired
;0200h // arm7_Wifi_Intr_RxCountExpired
;0400h // ---  ;unused (always zero)
;0800h // arm7_Wifi_Intr_RF_Wakeup
;1000h // arm7_Wifi_Intr_Multiplay?
;2000h // arm7_Wifi_Intr_PreBeaconTimeslot
;4000h // arm7_Wifi_Intr_BeaconTimeslot
;8000h // arm7_Wifi_Intr_PostBeaconTimeslot
;- - -
@@exit:
 pop  r4,pc
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm7\source\wifi_arm7.c WifiIrq Vblank
;------------------
arm7_Wifi_Update:  ;in/out: none   ;aka arm7_Wifi_Sync
 .if with_dsi_wifi
   ldr  r2,=dsi_wifi_flag       ;\
   ldrb r2,[r2]                 ; redirect to DSi
   cmp  r2,0                    ;
   bne  dsi7_Wifi_Update        ;/
 .endif
 push r4-r5,lr
 ldr  r4,=4808000h
 ldr  r0,=arm7_WifiData                 ;\
 ldr  r0,[r0]                           ; exit if not yet initialized
 cmp  r0,0                              ;
 beq  @@exit                            ;/
 ldr  r1,=WifiData_random               ;\
 ldr  r0,[r1]                           ;
 ldrh r2,[r4,W_RANDOM]                  ;
 eor  r0,r0,r2,lsl 0                    ; update random value
 eor  r0,r0,r2,lsl 11                   ;
 eor  r0,r0,r2,lsl 22                   ;
 str  r0,[r1]                           ;/
 ldr  r1,=WifiData_stats                ;\
 ldr  r2,[r1,WSTAT_ARM7_UPDATES*4] ;\   ; raise stats
 add  r2,1                         ;    ; (num ARM7 updates)
 str  r2,[r1,WSTAT_ARM7_UPDATES*4] ;/   ;/
;check flags/requests for current mode, see if we need to change anything...
 ldr  r5,=WifiData_reqMode                                              ;\
 ldrh r5,[r5]     ;reqMode                                              ;/
 ldr  r0,=WifiData_curMode                                              ;\
 ldrh r0,[r0]                                                           ;
 cmp  r0,WIFIMODE_DISABLED        // beq @@update_disabled_mode         ;
 cmp  r0,WIFIMODE_NORMAL          // beq @@update_normal_mode           ;
 cmp  r0,WIFIMODE_SCAN            // beq @@update_scan_mode             ;
 cmp  r0,WIFIMODE_ASSOCIATE       // beq @@update_associate_mode        ;
 cmp  r0,WIFIMODE_ASSOCIATED      // beq @@update_associated_mode       ;
 cmp  r0,WIFIMODE_CANNOTASSOCIATE // beq @@update_cannot_associate_mode ;
@@finish:   ;<-- return here after above mode jumps                     ;/
 ldr  r0,=WifiData_reqChannel                   ;\
 ldrh r0,[r0]     ;reqChannel                   ;
 ldr  r1,=WifiData_curChannel                   ; if a new/different channel is
 ldrh r1,[r1]     ;curChannel                   ; requested, then set channel
 cmp  r0,r1                                     ;
;movne r0,r0      ;reqChannel   ;\set channel   ;
 blne  arm7_Wifi_SetChannel     ;/              ;/
 bl   arm7_Wifi_Intr_RxEnd                      ;-check RX
 bl   arm7_Wifi_Intr_TxEnd                      ;-check if we need to TX anything, easiest way to do so at the moment.
@@exit:
 pop  r4-r5,pc
;---
@@finish_set_new_curMode:
 ldr  r1,=WifiData_curMode
 strh r0,[r1]
 b    @@finish
;--- --- --- ------
@@update_disabled_mode:   ;when in WIFIMODE_DISABLED
 mov  r0,LED_ON                                 ;\LED=On
 bl   arm7_ProxySetLedState                     ;/
 cmp  r5,WIFIMODE_DISABLED      ;reqMode        ;\if requested, stay DISABLED
 beq  @@finish                                  ;/
 bl   arm7_Wifi_Start           ;start          ;\start, and enter NORMAL mode
 mov  r0,WIFIMODE_NORMAL                        ; (may then switch from that
 b    @@finish_set_new_curMode                  ;/mode to another mode)
;--- --- --- ------
@@update_normal_mode:     ;when in WIFIMODE_NORMAL   ;main switcher function
 mov  r0,LED_LONGBLINK                          ;\LED=LongBlink
 bl   arm7_ProxySetLedState                     ;/
 cmp  r5,WIFIMODE_DISABLED      ;reqMode        ;\
 bne  @@dont_disable                            ;
 bl   arm7_Wifi_Stop            ;stop           ; if requested, stop and DISABLE
 mov  r0,WIFIMODE_DISABLED      ;disable...     ;
 b    @@finish_set_new_curMode  ;--> finish     ;
@@dont_disable:                                 ;/
 cmp  r5,WIFIMODE_SCAN          ;reqMode        ;\
 bne  @@dont_scan                               ;
 ldrh r0,[r4,W_US_COUNT1]  ;\memorize scan      ; if requested, SCAN
 ldr  r1,=WifiData_counter7; start time         ;
 str  r0,[r1]              ;/(65.5ms units)     ;  ;<-- in 65.5ms units (bit16-31 of US_COUNT)
 mov  r0,WIFIMODE_SCAN     ;-scan now...        ;
 b    @@finish_set_new_curMode  ;--> finish     ;
@@dont_scan:                                    ;/
 ldr  r1,=WifiData_curReqFlags  ;<-- curReq     ;\
 ldrh r0,[r1]                   ;\              ;
 tst  r0,WFLAG_REQ_APCONNECT    ; test          ; if already connected,
 beq  @@dont_disconnect         ;/              ; then disconnect now
 bic  r0,WFLAG_REQ_APCONNECT    ;\              ; ;\
;ldr  r1,=WifiData_curReqFlags  ; clear         ; ;
 strh r0,[r1]                   ;/              ; ;
 ldr  r0,=WifiData_MacAddr ;src         ;\      ; ; disconnect
 add  r1,r4,W_BSSID        ;dst         ;       ; ;
 bl   arm7_Wifi_CopyMacAddr             ;/      ; ;
 ldrh r0,[r4,W_RXFILTER]                ;\      ; ;
 bic  r0,400h  ;bit10=0 (no beacons)    ;       ; ;
 orr  r0,800h  ;bit11=1 (allow toDS ?)  ;       ; ;
 strh r0,[r4,W_RXFILTER]                ;/      ; ;
 ldrh r0,[r4,W_RXFILTER2]               ;\      ; ;
 bic  r0,2     ;clear bit1              ;       ; ;
 strh r0,[r4,W_RXFILTER2]               ;/      ; ;/
@@dont_disconnect:                              ;/
 ldr  r1,=WifiData_reqReqFlags  ;<-- reqReq     ;\
 ldrh r0,[r1]                   ;\              ;
 tst  r0,WFLAG_REQ_APCONNECT    ; test          ; if not connected,
 beq  @@dont_connect            ;/              ; then connect now

 bl   arm7_copy_ap_data_from_arm9  ;in: r0      ; ;\connect...
 ldr  r0,=WifiData_wepkey7      ;\set wep key   ; ; ;\
 bl   arm7_Wifi_SetWepKey       ;/              ; ; ;
 ldr  r0,=WifiData_wepmode7     ;\              ; ; ; apply wep
 ldrb r0,[r0]                   ; set wep mode  ; ; ;
 bl   arm7_Wifi_SetWepMode      ;/              ; ; ;/
 ldr  r0,=WifiData_bssid7  ;src ;\              ; ; ;\
 add  r1,r4,W_BSSID        ;dst ; apply bssid   ; ; ;
 bl   arm7_Wifi_CopyMacAddr     ;/              ; ; ; apply bssid
 ldrh r0,[r4,W_RXFILTER]                ;\      ; ; ; and change
 orr  r0,400h  ;bit10=1, want beacons   ;       ; ; ; rx filters
 bic  r0,800h  ;bit11=0, disallow toDS  ;       ; ; ;
 strh r0,[r4,W_RXFILTER]                ;/      ; ; ;
 ldrh r0,[r4,W_RXFILTER2]               ;\      ; ; ;
 orr  r0,2     ;set bit1                ;       ; ; ;
 strh r0,[r4,W_RXFILTER2]               ;/      ; ; ;/
 ldr  r0,=WifiData_apchannel7 ;\get channel     ; ; ;\
 ldrb r0,[r0]                 ;/                ; ; ;
 ldr  r1,=WifiData_reqChannel ;\req channel     ; ; ; req/apply channel
 strh r0,[r1]                 ;/                ; ; ;
 ldr  r1,=WifiData_curChannel ;\                ; ; ;
 ldrh r1,[r1]                 ; curr channel,   ; ; ;
 cmp  r0,r1                   ; if different:   ; ; ;
;movne r0,r0                  ; apply channel   ; ; ;
 blne  arm7_Wifi_SetChannel   ;/                ; ; ;/
 ldr  r0,=WifiData_curReqFlags                  ; ; ;\
 ldrh r0,[r0]                                   ; ; ; if adhoc
 tst  r0,WFLAG_REQ_APADHOC                      ; ; ; --> associated
 ldr  r1,=WifiData_authlevel               ;--> ; ; ; else
 movne r0,WIFI_AUTHLEVEL_ASSOCIATED   ;adhoc    ; ; ; --> disconnected
 moveq r0,WIFI_AUTHLEVEL_DISCONNECTED      ;<-- ; ; ; --> and send packet
 strh  r0,[r1]                                  ; ; ;
 bleq  arm7_Wifi_SendOpenSystemAuthPacket  ;<-- ; ; ;/
 ldr  r0,=WifiData_txbufOut                     ; ; ;\
 ldr  r0,[r0]                                   ; ; ; force empty
 ldr  r1,=WifiData_txbufIn                      ; ; ; tx buffer
 str  r0,[r1]                                   ; ; ;/
 ldr  r1,=WifiData_curReqFlags                  ; ; ;\
 ldrh r0,[r1]                                   ; ; ; connect request flag
 orr  r0,WFLAG_REQ_APCONNECT                    ; ; ;
 strh r0,[r1]                                   ; ; ;/
 ldrh r0,[r4,W_US_COUNT1]       ;\get time      ; ; ;\
 ldr  r1,=WifiData_counter7     ; (65.5ms units); ; ; init start time
 str  r0,[r1]                   ;/              ; ; ; and retry count
 mov  r0,0                      ;\init retry    ; ; ;
 ldr  r1,=WifiData_authctr      ; count         ; ; ;
 strh r0,[r1]                   ;/              ; ; ;/
 mov  r0,WIFIMODE_ASSOCIATE                     ; ; ;\new curMode
 b    @@finish_set_new_curMode   ;--> finish    ; ;/;/
@@dont_connect:                                 ;/
 b    @@finish
;--- --- --- ------
@@update_scan_mode:             ;when in WIFIMODE_SCAN
 mov  r0,LED_LONGBLINK                          ;\LED=LongBlink
 bl   arm7_ProxySetLedState                     ;/
 cmp  r5,WIFIMODE_SCAN          ;reqMode        ;\if scan no longer requested,
 movne r0,WIFIMODE_NORMAL                       ; switch to NORMAL
 bne   @@finish_set_new_curMode  ;--> finish    ;/
 ldrh r0,[r4,W_US_COUNT1]  ;\                   ;\
 ldr  r1,=WifiData_counter7; time since start   ;
 ldr  r2,[r1]    ;counter7 ; (65.5ms units)     ; every once and then,
 sub  r3,r0,r2             ;                    ; switch to a new channel...

;       cmp  r3,6   ;ca. 390ms    ;"jump ship!"  ;XNAY
;       cmp r3,2   ;<-- XXXX!!!! fast and reliable for me !!!!
;       cmp r3,1   ;<-- sometimes misses beacons (but works on next try, which is fast)
 ldr   r2,=boot_channel_wait    ;\
 ldr   r2,[r2]                  ;
 cmp   r2,7   ;ca. 460ms        ;
 movhi r2,7                     ;
 cmp   r3,r2                    ;/


 blo  @@no_channel_switch  ;/   ;--> stay       ;
 str  r0,[r1]    ;counter7 ;-new time origin    ; ;-
        ;XXXXchannel

 bl   arm7_get_next_scan_channel                ; ;-

@@no_channel_switch:                            ;/
 b    @@finish                                  ;-
;--- --- --- ------
@@update_associate_mode:        ;when in WIFIMODE_ASSOCIATE
 mov  r0,LED_LONGBLINK                          ;\LED=LongBlink
 bl   arm7_ProxySetLedState                     ;/
 ldr  r0,=WifiData_authlevel                    ;\
 ldrh r0,[r0]                                   ; if now associated okay,
 cmp  r0,WIFI_AUTHLEVEL_ASSOCIATED              ; switch to associated
 moveq r0,WIFIMODE_ASSOCIATED                   ;
 beq   @@finish_set_new_curMode  ;--> finish    ;/
 ldrh r0,[r4,W_US_COUNT1]  ;\                   ;\
 ldr  r1,=WifiData_counter7; time since start   ;
 ldr  r2,[r1]    ;counter7 ; (65.5ms units)     ; on associate timeout,
 sub  r3,r0,r2             ;                    ; reattempt connect stage...
 cmp  r3,20  ;ca. 1 sec    ;                    ;
 blo  @@no_assoc_timeout   ;/                   ;
 str  r0,[r1]    ;counter7 ;-new time origin    ;
 ldr  r1,=WifiData_authctr                      ; ;\
 ldrh r0,[r1]                                   ; ;
 add  r0,1                                      ; ; raise retry count,
 strh r0,[r1]                                   ; ; give up if too high
 cmp  r0,WIFI_MAX_ASSOC_RETRY                   ; ;
 movhi r0,WIFIMODE_CANNOTASSOCIATE              ; ;
 bhi   @@finish_set_new_curMode  ;--> finish    ; ;/
 ldr  r1,=WifiData_authlevel                    ; ;\
 ldrh r0,[r1]                                   ; ; check authlevel...
 cmp  r0,WIFI_AUTHLEVEL_DISCONNECTED            ; ; ;\
 bne  @@not_disconnected                        ; ; ; DISCONNECTED
 ldr  r0,=WifiData_curReqFlags                  ; ; ; ;\
 ldrh r0,[r0]                                   ; ; ; ; check flags
 tst  r0,WFLAG_REQ_APADHOC                      ; ; ; ;/
;ldreq  r1,=WifiData_authlevel                  ; ; ; ;\
 moveq  r0,WIFI_AUTHLEVEL_ASSOCIATED            ; ; ; ; change LEVEL to assoc
 streqh r0,[r1]                                 ; ; ; ;
 beq   @@finish   ;and STAY      ;--> finish    ; ; ; ;/
 bl   arm7_Wifi_SendOpenSystemAuthPacket        ; ; ; ;\or send auth packet
 b    @@finish   ;and STAY      ;--> finish     ; ; ; ;/
@@not_disconnected:                             ; ; ;/
 cmp   r0,WIFI_AUTHLEVEL_DEASSOCIATED           ; ; ;\
 cmpne r0,WIFI_AUTHLEVEL_AUTHENTICATED          ; ; ; if DEASSOCIATED
 bne   @@dont_assoc                             ; ; ; or AUTHENTICATED,
 bl    arm7_Wifi_SendAssocPacket                ; ; ; send ASSOC packet
 b     @@finish   ;and STAY      ;--> finish    ; ; ;
@@dont_assoc:                                   ; ; ;/
 cmp  r0,WIFI_AUTHLEVEL_ASSOCIATED              ; ; ;\
 moveq r0,WIFIMODE_ASSOCIATED                   ; ; ; ASSOCIATED
 beq   @@finish_set_new_curMode  ;--> finish    ; ; ;/
@@no_assoc_timeout:                             ;/
 ldr  r0,=WifiData_reqReqFlags                  ;\
 ldrh r0,[r0]     ;reqReqFlags                  ; if no APCONNECT request,
 tst  r0,WFLAG_REQ_APCONNECT                    ; switch to NORMAL
 moveq r0,WIFIMODE_NORMAL                       ;
 beq   @@finish_set_new_curMode  ;--> finish    ;/
 b    @@finish
;--- --- --- ------
@@update_associated_mode:       ;when in WIFIMODE_ASSOCIATED
 mov  r0,LED_SHORTBLINK                         ;\LED=ShortBlink !!!
 bl   arm7_ProxySetLedState                     ;/
;- - -
;BUGGED: keepalive_time could/should better be bound to "W_US_COUNTx",
;else it would highly depend on how often the arm7_Wifi_Update function is
;called... it's intended to be called on vblank, but that's maybe not 100%
;guaranteed (particulary it can be called MORE OFTEN from arm7_Wifi_Sync).
;- - -
 ldr  r1,=keepalive_time                        ;\
 ldr  r0,[r1]  ;get old time                    ;
 add  r0,1     ;raise time                      ; raise keepalive time,
 cmp   r0,WIFI_KEEPALIVE_COUNT  ;--> flags      ; and send NullFrame
 movhi r0,0    ;wrap time       ;<-- flags      ; every once and then
 str   r0,[r1] ;apply new time                  ;
 blhi  arm7_Wifi_SendNullFrame  ;<-- flags      ;/
 ldrh r0,[r4,W_US_COUNT1]                       ;\
 ldr  r1,=WifiData_pspoll_period                ;
 ldrh r2,[r1]   ;[pspoll_period]                ; send PowerSavePollFrame
 sub  r3,r0,r2  ;COUNT-[pspoll_period]          ; every once and then
 cmp  r3,WIFI_PS_POLL_CONST                     ; (outcommented)
 strhih r0,[r1] ;[pspoll_period]=COUNT          ;
;blhi   arm7_Wifi_SendPSPollFrame               ;/
 ldr  r0,=WifiData_reqReqFlags                  ;\
 ldrh r0,[r0]     ;reqReqFlags                  ; if no APCONNECT request,
 tst  r0,WFLAG_REQ_APCONNECT                    ; switch to NORMAL
 moveq r0,WIFIMODE_NORMAL                       ;
 beq   @@finish_set_new_curMode  ;--> finish    ;/
 ldr  r0,=WifiData_authlevel                    ;\
 ldrh r0,[r0]                                   ; if no longer associated,
 cmp  r0,WIFI_AUTHLEVEL_ASSOCIATED              ; switch to (re-)associate
 movne r0,WIFIMODE_ASSOCIATE                    ;
 bne   @@finish_set_new_curMode  ;--> finish    ;/
 b    @@finish
;--- --- --- ------
@@update_cannot_associate_mode: ;when in WIFIMODE_CANNOTASSOCIATE
 mov  r0,LED_LONGBLINK                          ;\LED=LongBlink
 bl   arm7_ProxySetLedState                     ;/
 ldr  r0,=WifiData_reqReqFlags                  ;\
 ldrh r0,[r0]     ;reqReqFlags                  ; if no APCONNECT request,
 tst  r0,WFLAG_REQ_APCONNECT                    ; switch to NORMAL
 moveq r0,WIFIMODE_NORMAL                       ;
 beq   @@finish_set_new_curMode  ;--> finish    ;/
 b    @@finish                                  ;-stay
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm7\source\wifi_arm7.c User Funcs
;------------------
;Wifi User-called Functions...
;------------------
;arm7_erasemem:  ;in: r0=dest, r1=length, out: none
;BLAH/UNUSED (unless it's actually meant to be "User-called")
;mov  r2,00h  ;fillbyte
;@@lop:
;subs   r1,1
;strhsb r2,[r0],1
;bhi    @@lop
;bx   lr
;------------------
arm7_Wifi_Init:  ;in: r0=wifidata, out: none    ;aka "arm7_wifiAddressHandler"
 push r4,lr
 ldr  r4,=4808000h
 ldr  r1,=arm7_WifiData         ;\memorize ptr to wifidata (BLAH, except
 str  r0,[r1]                   ;/maybe needed as "init-done" flag)
;- - -
 mov  r0,IRQ_WIFI               ;\enable IRQ (this was originally done by "arm7_wifiAddressHandler", which did then call "Wifi_Init", which is now merged to single "Wifi_Init" function)
 bl   arm7_irqEnable            ;/
;- - -
 ldr  r1,=REGBASE_GPIO          ;\
 ldrh r0,[r1,REG_GPIO_WIFI]     ;
 tst  r0,0100h                  ; unlock NDS-WIFI for DWM-W024 boards, 4/2018
 bne  @@is_dsi_and_already_set  ; (works, provided that launcher/unlaunch has
 orr  r0,0100h                  ; previously uploaded the wifi firmware)
 strh r0,[r1,REG_GPIO_WIFI]     ;
 ldrh r0,[r1,REG_GPIO_WIFI]     ;
 tst  r0,0100h                  ;
 beq  @@is_nds_and_cannot_set   ;
 ldr  r0,=0A410h ;42000 decimal ;
 swi  03h shl 16 ;waitbyloop    ;
@@is_nds_and_cannot_set:        ;
@@is_dsi_and_already_set:       ;/
;- - -
 .if with_soft_wep
   bl   create_crc32_table
 .endif
;- - -
 ldr  r1,=4000000h+POWERCNT7    ;\
 ldrh r0,[r1]                   ; enable power for the wifi
 orr  r0,02h    ;set bit1       ;
 strh r0,[r1]                   ;/
;ldr  r1,=4000000h+WIFIWAITCNT  ;\init wifi waitstates
;mov  r0,30h                    ; (uh, should be already set by firmware)
;strh r0,[r1]                   ;/
 bl   arm7_InitFlashData        ;-load wifi flash calibration data
 bl   arm7_GetWfcSettings       ;-load wifi flash access point data
 ldr  r0,=FlashData+36h    ;src ;\
 ldr  r1,=WifiData_MacAddr ;dst ; copy MAC addr to RAM
 bl   arm7_Wifi_CopyMacAddr     ;/
;- - -reset/shutdown wifi...
 mov  r0,-1   ;aka FFFFh        ;\reset wifi I/O
 strh r0,[r4,W_MODE_RST]        ;/
 bl   arm7_Wifi_Stop            ;-
 bl   arm7_Wifi_Shutdown        ;-power off wifi
;- - -


 mov  r0,1                      ;\
        ;XXXXchannel
        mov r0,11  ;XXXX????!!!! speedup boot (when using that channel)

    ldr  r1,=boot_channel_index
    mov  r0,0
    str  r0,[r1]
    ldr  r1,=boot_channel_wait
    mov  r0,2  ;1   ;2
    str  r0,[r1]
    ldr  r1,=boot_channel_list+0
    ldrb r0,[r1]

 ldr  r1,=WifiData_curChannel   ;
 strh r0,[r1]  ;=0001h          ; initially mark as channel 1
 ldr  r1,=WifiData_reqChannel   ;
 strh r0,[r1]  ;=0001h          ;/
 mov  r0,WIFIMODE_DISABLED      ;\
 ldr  r1,=WifiData_curMode      ;
 strh r0,[r1]  ;=disabled       ; initially mark as disabled
 ldr  r1,=WifiData_reqMode      ;
 strh r0,[r1]  ;=disabled       ;/
 ldr  r0,=WFLAG_PACKET_ALL-WFLAG_PACKET_BEACON  ;\initial packet requests
 ldr  r1,=WifiData_reqPacketFlags               ; (all, except beacon)
 str  r0,[r1]  ;32bit                           ;/(uh, why no beacons?)
 mov  r0,0                      ;\
 ldr  r1,=WifiData_curReqFlags  ;
 strh r0,[r1]  ;=0000h          ; initially mark req'flags zero (WFLAG_REQ_xxx)
 ldr  r1,=WifiData_reqReqFlags  ;
 strh r0,[r1]  ;=0000h          ;/
 mov  r0,0ah   ;1Mbit/s         ;\
 ldr  r1,=WifiData_maxrate7     ; initially max rate 1Mbit/s
 strh r0,[r1]  ;=000ah          ;/
 mov  r0,0  ;fillvalue          ;\
 ldr  r1,=WIFIRAM_BASE32        ;
 mov  r2,WIFIRAM_TOTAL_SIZE     ; initially zerofill Wifi RAM
@@clear_ram_lop:                ; (XXX could use faster function,
 str  r0,[r1],4                 ; may NOT use 8bit writes for Wifi RAM)
 subs r2,4                      ;
 bne  @@clear_ram_lop           ;/
;- - -
 ldrh r0,[r4,W_ID]  ;chip id    ;\
 ldr  r1,=nds_wifi_chip_id      ; Chip ID (1440h=DS, C340h=DS-Lite)
 strh r0,[r1]                   ;/
 ldr  r1,=FlashData             ;\
 ldrb r0,[r1,40h]  ;type2/3/5   ; BB/RF chip type (02h/03h/05h)
 ldr  r1,=nds_wifi_bb_rf_type   ;
 strh r0,[r1]                   ;/
;- - -
 mov  r0,0                      ;\disable wifi IRQs
 strh r0,[r4,W_IE]              ;/
 bl   arm7_Wifi_WakeUp
 bl   arm7_Wifi_MacInit
 bl   arm7_Wifi_RFInit          ;-uh, again? (was already in arm7_Wifi_WakeUp)
 bl   arm7_Wifi_BBInit
;- - - set default settings...
 ldr  r0,=WifiData_MacAddr ;src ;\
 add  r1,r4,W_MACADDR      ;dst ; apply MAC addr to I/O
 bl   arm7_Wifi_CopyMacAddr     ;/
 mov  r0,0001h*SGIP_TX_RETRIES  ;\set retry limit
   ;;; orr r0,100h*SGIP_TX_RETRIES ;XNAY
 strh r0,[r4,W_TX_RETRYLIMIT]   ;/
 mov  r0,2                      ;\set mode 2
 bl   arm7_Wifi_SetMode         ;/
 mov  r0,WEPMODE_NONE           ;\set WEP off
 bl   arm7_Wifi_SetWepMode      ;/
 mov  r0,1                              ;\initially select channel 1
 bl   arm7_Wifi_SetChannel              ;/
 mov  r0,13h  ;index                    ;\
 mov  r1,00h  ;data                     ; BB[13h]=00h
 bl   arm7_Wifi_BBWrite                 ;/
 mov  r0,35h  ;index                    ;\
 mov  r1,1Fh  ;data                     ; BB[35h]=1Fh
 bl   arm7_Wifi_BBWrite                 ;/
 ldr  r1,=WifiData_random               ;\
 ldr  r0,[r1]                           ;
   ldr r2,=4805F40h     ;XXXX try so..?
   ldrh r3,[r2]
   add  r0,r3
   add  r3,123
   strh r3,[r2]
   ;;;ldr  r2,=sgIP_timems   ;XXXX can't do this on ARM7 (arm9 only)
   ;;;str  r0,[r2]
 ldrh r2,[r4,W_RANDOM]                  ;
 eor  r0,r0,r2,lsl 0                    ; update random value
 eor  r0,r0,r2,lsl 11                   ;
 eor  r0,r0,r2,lsl 22                   ;
 str  r0,[r1]                           ;/
 ldr  r1,=WifiData_flags7               ;\
 ldr  r0,[r1]                           ; mark active
 orr  r0,WFLAG_ARM7_ACTIVE              ;
 str  r0,[r1]                           ;/
 pop  r4,pc
;------------------
arm7_Wifi_Deinit:  ;in/out: none
 .if with_dsi_wifi
   ldr  r2,=dsi_wifi_flag       ;\
   ldrb r2,[r2]                 ; redirect to DSi
   cmp  r2,0                    ;
   bne  dsi7_Wifi_Deinit        ;/
 .endif
 push lr
 bl   arm7_Wifi_Stop            ;-
 ldr  r1,=4000000h+POWERCNT7    ;\
 ldrh r0,[r1]                   ;
 bic  r0,02h    ;clear bit1     ;
 strh r0,[r1]                   ;/
 pop  pc
;------------------
arm7_Wifi_Start:  ;in/out: none
;BLAH: original code contains lots of unused/outcommented stuff, and it's also
;doing irrational nonsense like initializing BSSID twice; with different values.
 push r4-r5,lr
 bl   arm7_disable_ime          ;\disable IME
 mov  r4,r0                     ;/
 ldr  r5,=4808000h
 bl   arm7_Wifi_Stop                    ;-
 ldr  r0,=arm7_reg_list_wifi_start      ;\init wifi registers
 bl   arm7_Wifi_write_register_list     ;/
 bl   arm7_Wifi_DisableTempPowerSave    ;-
 ldrh r0,[r5,W_POWERSTATE]              ;\
 orr  r0,2   ;set bit1                  ;
 strh r0,[r5,W_POWERSTATE]              ;/
 mov  r0,-1  ;aka FFFFh                 ;\
 strh r0,[r5,W_TXREQ_RESET]             ;/
 mov  r1,0FA0h ;4000 decimal  ;timeout  ;\
 ldr  r2,=4808000h+100h                 ;
@@wait_lop:                             ;
 ldrh r0,[r2,W_RF_PINS-100h] ;\         ;
 tst  r0,80h  ;"RX.ON"?      ;          ; wait ready
 bne  @@wait_done ;1=active  ;/         ;
 subs r1,1                    ;timeout  ;
 bne  @@wait_lop                        ;
        b @@wait_lop ;XNAY
@@wait_done:                            ;/
 ldr  r1,=WifiData_flags7               ;\
 ldr  r0,[r1]                           ; mark wifi running
 orr  r0,WFLAG_ARM7_RUNNING  ;set       ;
 str  r0,[r1]                           ;/
 mov  r0,r4                     ;\restore IME
 bl   arm7_restore_ime          ;/
 pop  r4-r5,pc
;--- --- --- ------
arm7_reg_list_wifi_start:
 ;- - - part 1, as done by 1st part of  original "arm7_Wifi_Start" function
 .if with_soft_wep                              ;\
   dw   W_WEP_CNT     ,0000h                    ;
 .else                                          ;
   dw   W_WEP_CNT     ,8000h                    ;
 .endif                                         ;
 dw   W_BEACONCOUNT2  ,0FFFFh                   ;
 dw   W_AID_FULL      ,0                        ;
 dw   W_AID_LOW       ,0                        ;
 dw   W_US_COUNTCNT   ,1                        ;
 dw   W_POWER_TX      ,0000h                    ;

         dw   W_POWER_TX      ,0002h   ;XNAY?           ;

 dw   W_BSSID+0       ,0000h ;\                 ;
 dw   W_BSSID+2       ,0000h ;                  ;
 dw   W_BSSID+4       ,0000h ;/                 ;/
 ;- - - part 2, as done by original "arm7_Wifi_TxSetup" function
 ;BLAH: original code additionally contains outcommented/nonsense code
 ;(storing garbage values in Wifi RAM, and setting W_TXREQ_SET=1)
 ;BLAH: writes W_TXREQ_SET=000Dh, but it's used only be "arm7_Wifi_Start"
 ;(which sets W_TXREQ_RESET=FFFFh shortly after calling this function, so
 ;the newly SET bits are almost instantly RESET again).
 ;dw  W_TXREQ_SET     ,000Dh                    ;-blah
 ;- - - part 3, as done by original "arm7_Wifi_RxSetup" function
 ;BLAH: original code additionally contains outcommented/nonsense code
 ;(writing garbage values to W_RXBUF_BEGIN and W_RXBUF_WR_ADDR)
 dw   W_RXCNT         ,8000h
 dw   W_RXBUF_BEGIN   ,WIFIRAM_RX_BUFFER_START+4000h
 dw   W_RXBUF_END     ,WIFIRAM_RX_BUFFER_START+4000h+WIFIRAM_RX_BUFFER_SIZE
 dw   W_RXBUF_GAP     ,WIFIRAM_RX_BUFFER_START+4000h+WIFIRAM_RX_BUFFER_SIZE-2 ;uh?
 dw   W_RXBUF_WR_ADDR ,WIFIRAM_RX_BUFFER_START/2
 dw   W_RXBUF_READCSR ,WIFIRAM_RX_BUFFER_START/2
 dw   W_RXCNT         ,8001h   ;bit0=latch WR_ADDR to WRCSR, bit15=enable RX
 ;- - - part 4, as done by 2nd part of  original "arm7_Wifi_Start" function
;dw   W_BSSID+0       , [WifiData_MacAddr+0]    ;\
;dw   W_BSSID+2       , [WifiData_MacAddr+2]    ;  uh, why?
;dw   W_BSSID+4       , [WifiData_MacAddr+4]    ;    (maybe as dummy addr,
;- - -                                          ;    ensured to be NOT same
;;XXX.CODE: ldr  r0,=WifiData_MacAddr ;src      ;    as access point/router?)
;;XXX.CODE: add  r1,rX,W_BSSID        ;dst      ;
;;XXX.CODE: bl   arm7_Wifi_CopyMacAddr          ;/
 dw   W_RXCNT         , 8000h                   ;\
 dw   W_IF            , 0FFFFh                  ;
;dw   W_IE            , 040B3h                  ;   <-- uh, nonsense
 dw   W_IE            , 00003h+(with_gimmicks*30h)
 dw   W_RXSTAT_OVF_IE , 1fffh                   ;
 dw   W_RXSTAT_INC_IE , 0      ;;;0x0068h       ;
 dw   W_RXFILTER      , 0981h  ;;;0x0181h       ;
 dw   W_RXFILTER2     , 0009h  ;;;0x000Bh       ;
 dw   W_TXSTATCNT     , 0                       ;
 dw   W_X_00Ah        , 0                       ;
 dw   W_MODE_RST      , 1                       ;
 dw   W_US_COUNTCNT   , 1                       ;
 dw   W_US_COMPARECNT , 1                       ;


       ;dw   W_US_COMPARECNT , 0           ;XNAY
       ;dw   W_BEACONCOUNT2 , 100h  ;XNAY !!!!!
       ;dw   W_BEACONINT    , 0h  ;XNAY !!!!!
       ;dw   W_BEACONCOUNT1 , 0h  ;XNAY !!!!!

 dw   W_POWER_OR_SO   , 0000h                   ;/
 dw   0,0  ;end of list
;------------------
arm7_Wifi_Stop:  ;in/out: none
 push r4,lr
 bl   arm7_disable_ime          ;\disable IME
 mov  r4,r0                     ;/
 ldr  r1,=WifiData_flags7               ;\
 ldr  r0,[r1]                           ; mark wifi stopped
 bic  r0,WFLAG_ARM7_RUNNING  ;clear     ;
 str  r0,[r1]                           ;/
 ldr  r0,=arm7_reg_list_wifi_stop       ;\change wifi registers
 bl   arm7_Wifi_write_register_list     ;/
 mov  r0,r4                     ;\restore IME
 bl   arm7_restore_ime          ;/
 pop  r4,pc
;---
arm7_reg_list_wifi_stop:
 dw W_IE            , 0
 dw W_MODE_RST      , 0
 dw W_US_COMPARECNT , 0
 dw W_US_COUNTCNT   , 0
 dw W_TXSTATCNT     , 0
 dw W_X_00Ah        , 0
 dw W_TXBUF_BEACON  , 0
 dw W_TXREQ_RESET   , 0FFFFh
 dw W_TXBUF_RESET   , 0FFFFh
 dw 0,0  ;end of list
;------------------
arm7_Wifi_SetChannel:  ;in: r0=channel(1..13), out: none
 push r4-r7,lr
 mov  r4,r0    ;memorize channel (1..13)
 ldr  r5,=FlashData
 sub  r1,r0,1  ;channel-1 (0..12)       ;\
 cmp  r1,12                             ; accept only channel 1..13
 bhi  @@done   ;reject                  ;/
 ldr  r1,=WifiData_curChannel           ;\
;mov  r0,r4    ;channel (1..13)         ; apply channel to a RAM variable
 strh r0,[r1]                           ;/
.if with_gimmicks
;mov  r0,r4    ;channel (1..13)         ;\adjust channel in transmitted
 bl   arm7_Wifi_SetBeaconChannel        ;/beacon (if beacon is transmitted)
.endif
 ldrb r0,[r5,40h]  ;wifi flash                  ;\
 cmp  r0,03h                                    ; check type
 beq  @@type3                                   ;/
;- - -                                                      ;Type2 or Type5...
 sub  r4,1      ;channel-1                          ;-                  ;\
 add  r6,r4,r4,lsl 1  ;(channel-1)*3                ;\addr for          ;
 add  r6,r5,r6,lsl 1  ;(channel-1)*6+wifi_flash     ;/channel data      ;
 add  r1,r6,0f2h      ;(channel-1)*6+wifi_flash+F2h ;\                  ; Type2
 bl   ldr_24bit_r0_from_r1                          ; 1st RF register   ; or
;mov  r0,r0                                         ;                   ; Type5
 bl   arm7_Wifi_RFWrite                             ;/                  ;
 add  r1,r6,0f5h      ;(channel-1)*6+wifi_flash+F5h ;\                  ;
 bl   ldr_24bit_r0_from_r1                          ; 2nd RF register   ;
;mov  r0,r0                                         ;                   ;
 bl   arm7_Wifi_RFWrite                             ;/                  ;
 bl   arm7_delay_1500us                             ;-delay             ;
;- - -                                                                  ;
 ldr  r0,=chdata_save5  ;\memorized RF[9]                           ;\  ;
 ldr  r0,[r0]           ;/                                          ;   ;
 add  r1,r5,r4          ;-wifi_flash+(channel-1)                    ;   ;
 tst  r0,10000h         ;\bit16=0 --> ext.gain                      ;   ;
 beq  @@external_gain   ;/                                          ;   ;
 tst  r0,8000h          ;\bit15=0 --> int.gain                      ;   ;
 beq  @@internal_gain   ;/                                          ;   ;
 b    @@done                                                        ;   ;
;---                                                                ;   ;
@@internal_gain:                                                    ;   ;
 ldrb r1,[r1,154h]          ;wifi_flash+(channel-1)+154h;\          ;   ;
 and  r1,1Fh            ;\RF[9].bit10-14 = (r1 AND 1Fh) ; RF[09h]   ;   ;
 orr  r0,r0,r1,lsl 10   ;/                              ;           ;   ;
 bl   arm7_Wifi_RFWrite                                 ;/          ;   ;
 b    @@done                                                        ;   ;
;---                                                                ;   ;
@@external_gain:                                                    ;   ;
 mov  r0,1Eh       ;index                               ;\          ;   ;
 ldrb r1,[r1,146h] ;data  ;wifi_flash+(channel-1)+146h  ; BB[1Eh]   ;   ;
 bl   arm7_Wifi_BBWrite                                 ;/          ;   ;
 b    @@done                                                        ;/  ;/
;---
@@type3:                                                    ;Type3...
 ldrb r0,[r5,42h]  ;wifi flash                          ;\
 add  r0,0CEh   ;\ptr to [CEh+[42h]]                    ; begin of channel data
 add  r6,r5,r0  ;/                                      ;/
 ldrb r7,[r6],1    ;wifi flash, num BB entries          ;\
@@type3_bb_lop:                                         ;
 ldrb r0,[r6]      ;get BB index from [ptr]             ;
 ldrb r1,[r6,r4]   ;get BB data from [ptr+channel]      ; new BB registers
 bl   arm7_Wifi_BBWrite                                 ;
 add  r6,15                                             ;
 subs r7,1                                              ;
 bne  @@type3_bb_lop                                    ;/
 ldrb r7,[r5,43h]  ;wifi flash, num RF entries          ;\
@@type3_rf_lop:                                         ;
 ldrb r0,[r6]      ;get RF index from [ptr]             ;
 ldrb r1,[r6,r4]   ;get RF data from [ptr+channel]      ; new RF registers
 orr  r0,r1,r0,lsl 8   ;data+index*100h                 ;
 orr  r0,50000h        ;data+index*100h+50000h          ;
 bl   arm7_Wifi_RFWrite                                 ;
 add  r6,15                                             ;
 subs r7,1                                              ;
 bne  @@type3_rf_lop                                    ;/
 bl   arm7_delay_1500us                                 ;-delay
@@done:
 pop  r4-r7,pc
;------------------
arm7_delay_1500us:  ;in/out: none
 ldr  r0,=12583    ;1.5ms delay
 swi  03h shl 16   ;WaitByLoop
 bx   lr
;------------------
arm7_delay_8000us:
 ldr  r0,=67109    ;8ms delay
 swi  03h shl 16   ;WaitByLoop
 bx   lr
;------------------
arm7_delay_40000us:
 ldr  r0,=335544   ;40ms delay
 swi  03h shl 16   ;WaitByLoop
 bx   lr
;------------------
arm7_Wifi_SetWepKey:  ;in: r0=wepkey, out: none
 ;BUGGED: original code copies 32-BYTE per key in this function, whilst WFC
 ;data is only 16-BYTE per key, and the wepkey9/wepkey7 arrays are 20-BYTE
 ;per key... that three different sizes don't really fit together at all.
 ;note: the hardware key slots (in Wifi RAM) could to be really 32-BYTE each?
 ;- - -
 ;note: DSi firmware allows to type max 64-CHARACTERS as WEP key, but doing
 ;so causes it to tell that the data was incorrect.
 ;maybe it must have certain length and/or must be digits only?
 ;- - -
.if with_soft_wep
 ldr  r1,=wep_key+3   ;dst
 mov  r2,20h-3        ;len
 b    memcopy_bytewise
.else
 ldr  r1,=WIFIRAM_BASE32+WIFIRAM_WEP_KEY_START
 mov  r2,20h    ;uh, len 32-BYTE ?
@@lop:
 ldrh r3,[r0],2
 strh r3,[r1,60h]  ;key3        ;copy same values to ALL four keys...?
 strh r3,[r1,40h]  ;key2
 strh r3,[r1,20h]  ;key1
 strh r3,[r1],2    ;key0
 subs r2,2
 bne  @@lop
 bx   lr
.endif
;------------------
arm7_Wifi_SetWepMode:  ;in: r0=wepmode, out: none
 cmp  r0,7              ;\accept 0..7 only
 bhi  @@fail            ;/
 .if with_soft_wep
   ldr  r1,=wep_keylen
   mov  r2,3+0  ;?
   cmp  r0,1 // moveq r2,3+5
   cmp  r0,2 // moveq r2,3+13  ;normal
   cmp  r0,3 // moveq r2,3+16
  ;cmp  r0,? // moveq r2,3+29
   strb r2,[r1]
  ;- - -
   mov  r0,0
 .endif
 ldr  r3,=4808000h
 cmp   r0,0  ;0=off             ;\
 moveq r1,0000h ;off            ; enable/disable WEP
 movne r1,8000h ;on             ; (disable when mode=0)
 strh  r1,[r3,W_WEP_CNT]        ;/
;cmp   r0,0  ;0=off             ;\change mode=0 (off) to mode=1 (uh, why?)
 moveq r0,1                     ;/
 ldrh  r1,[r3,W_MODE_WEP]       ;\
 bic   r1,07h shl 3  ;clear old ; apply new WEP mode bits (bit3 and up)
 orr   r1,r1,r0,lsl 3 ;set new  ;
 strh  r1,[r3,W_MODE_WEP]       ;/
@@fail:
 bx   lr
;------------------
arm7_Wifi_SetMode:  ;in: r0=wifimode, out: none
;uh, used ONLY with r0=2
 cmp  r0,3              ;\accept 0..3 only
 bhi  @@fail            ;/
 ldr  r3,=4808000h
 ldrh  r1,[r3,W_MODE_WEP]       ;\
 bic   r1,07h  ;clear old 3BIT  ; apply new MODE bits (whatever/unknown LSBs)
 orr   r1,r1,r0  ;set new 2BIT  ; (hmmm, clears 3bit, but set 2bit?)
 strh  r1,[r3,W_MODE_WEP]       ;/
@@fail:
 bx   lr
;------------------
;arm7_Wifi_SetBeaconPeriod:  ;in: r0=beacon_period, out: none
;BLAH: UNUSED
;sub  r1,r0,10h         ;\
;cmp  r1,3E8h-10h       ; accept 10h..3E7h only
;bhs  @@fail            ;/
;ldr  r3,=4808000h
;strh r0,[r3,W_BEACONINT]       ;-apply new value
;@@fail:
;bx   lr
;------------------
;arm7_Wifi_SetPreambleType:  ;in: r0=preamble_type, out: none
;BLAH: UNUSED
;cmp  r0,1              ;\accept 0..1 only
;bhi  @@fail            ;/
;ldr  r3,=4808000h
;ldrh r1,[r3,W_PREAMBLE]        ;\
;bic  r1,40h    ;clear old bit6 ; apply new bit
;orr  r1,r1,r0,lsl 6  ;new bit6 ;
;strh r1,[r3,W_PREAMBLE]        ;/
;@@fail:
;bx   lr
;------------------
arm7_Wifi_DisableTempPowerSave:  ;in/out: none
 ;BUGGED: original code does CLEAR W_POWER_TX.bit1 (correct should be SETTING
 ;that bit when intending to disable automatic power-save mode) (the bit would
 ;be relevant only on W_BEACONCOUNT2 underflows, which usually won't happen)
 ;- - -
 ldr  r3,=4808000h
 ldrh r0,[r3,W_POWER_TX]        ;\
 orr  r0,02h    ;SET bit1       ; disable automatic power-saving mode
 strh r0,[r3,W_POWER_TX]        ;/
 mov  r0,0000h                  ;\
 strh r0,[r3,W_POWER_OR_SO]     ;/
 bx   lr
;------------------
.pool
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm7\source\wifi_arm7.c 802.11b send
;------------------
arm7_Wifi_TxQueue:  ;in: r0=data, r1=datalen, out: r0
;note: this auto-adjusts the TX header's length entry (unlike original code)
 push r4-r7,lr
 mov  r4,r0     ;data                           ;\memorize params
 mov  r5,r1     ;datalen                        ;/
 ldr  r6,=arm7q    ;ptr to arm7 queue           ;\get ptr's to queue/len
 ldr  r7,=arm7qlen ;ptr to arm7 queuelen        ;/
 add  r0,r5,4-12  ;len+chksum(4)-txhdr(12)      ;\adjust length entry
 strh r0,[r4,0ah]                               ;/in TX hardware header
 ldr  r1,[r7]  ;queue len       ;\
 cmp  r1,0                      ; check if queue empty
 beq  @@queue_empty             ;/
 bl   arm7_Wifi_TxCheck         ;\queue is full, check if hardware is busy,
 cmp  r0,0     ;0=busy          ; fail if draining queue isn't possible yet
 beq  @@fail_return_0           ;/
 mov  r0,r6    ;queue           ;\
 ldr  r1,[r7]  ;queue len       ; send OLD queued data to hardware
 bl   arm7_Wifi_TxRaw           ;/
 mov  r0,0                      ;\mark queue empty
 str  r0,[r7]  ;queue len       ;/(so that NEW data can be added to queue)
;- - -
@@add_to_queue:
 cmp  r5,ARM7_QUEUE_SIZE        ;\check max datalen for queue
 bhs  @@fail_return_0           ;/
 mov  r0,r4   ;data     ;src    ;\
 mov  r1,r6   ;queue    ;dst    ; store NEW data in empty queue
 mov  r2,r5   ;datalen  ;len    ;
 bl   memcopy_bytewise          ;/
 str  r5,[r7] ;queue len        ;-apply new queue length
 b    @@done_okay
;---
@@queue_empty:
 bl   arm7_Wifi_TxCheck         ;\
 cmp  r0,0      ;0=busy         ; check if hardware is busy
 beq  @@add_to_queue            ;/
 mov  r0,r4     ;data           ;\
 mov  r1,r5     ;datalen        ; send NEW data right now
 bl   arm7_Wifi_TxRaw           ;/
;- - -
@@done_okay:
 mov  r0,1              ;okay (sent, or at least queued)
 b    @@return_r0
;---
@@fail_return_0:
 mov  r0,0              ;fail (not sent, not queued)
@@return_r0:
 pop  r4-r7,pc
;------------------
arm7_Wifi_GenMgtHeader:  ;in: r0=FrameControl, r1=dest, out: r1=increased
;note: original code had incoming r0/r1 swapped, and return len instead dest+len
 push r4,lr
 mov  r4,r0  ;FC (FrameControl aka headerflags)
 mov  r2,0                              ;\                              ;\
 str  r2,[r1],4                         ; status/reserved               ; TX HW
 str  r2,[r1],4                         ;/                              ; header
 mov  r2,0ah  ;RATE_1MBIT               ;\rate/length                   ; 12byte
 str  r2,[r1],4                         ;/                              ;/
;mov  r4,r4      ;incoming FC           ;\FC: Mgmt... (incoming param)  ;\
 strh r4,[r1],2                         ;/                              ;
 mov  r0,0                              ;\Duration                      ; packet
 strh r0,[r1],2                         ;/                              ; header
 ldr  r0,=WifiData_apmac7        ;src   ;\Addr1=DA                      ; 24byte
 bl   arm7_Wifi_CopyMacAddr             ;/                              ;
 ldr  r0,=WifiData_MacAddr       ;src   ;\Addr2=SA                      ;
 bl   arm7_Wifi_CopyMacAddr             ;/                              ;
 ldr  r0,=WifiData_bssid7        ;src   ;\Addr3=BSSID                   ;
 bl   arm7_Wifi_CopyMacAddr             ;/                              ;
 mov  r0,0                              ;\Sequence Control              ;
 strh r0,[r1],2                         ;/                              ;/
;XXXsoft_wep
 tst  r4,4000h   ;FC.WEP                        ;\
 beq  @@no_wep                                  ;
 ldr  r3,=4808000h                              ; for WEP only:
 ldrh r0,[r3,W_RANDOM]                          ; extra 4byte  ;uh, aka WEP IV ?
 eor  r0,r0,r0,lsl 7                            ;
;eor  r0,r0,r0,lsl 15  ;BLAH: masked off below  ; "random or wepkeyid7 shl 30"
 ldr  r1,=0FFFh                                 ;
 and  r0,r1            ;mask random             ; (done lazy, certainly
 ldr  r1,=WifiData_wepkeyid7                    ; doesn't match to spec)
 ldrb r1,[r1]                                   ;
 orr  r0,r0,r1,lsl 30  ;bit30-31 = key.id       ;
 str  r0,[r1],4                                 ;
@@no_wep:                                       ;/
 pop  r4,pc        ;out: r1=increased
;------------------
arm7_Wifi_SendOpenSystemAuthPacket:  ;in: none, out: r0
 push lr
 sub  sp,40h            ;\alloc packet (max is 12+24+6 = 42 = 2Ah)

        ;mov r0,'E' // bl wrchr_r0       ;XNAY pack

 mov  r1,sp             ;/
 mov  r0,(0 shl 2)+(0Bh shl 4)+000h  ;FC: Mgmt,Auth     ;\create TX header
 bl   arm7_Wifi_GenMgtHeader                            ;/and packet header
 mov  r0,0      ;\Authentication algorithm number (0=open system) ;\
 strh r0,[r1],2 ;/                                                ;
 mov  r0,1      ;\Authentication sequence number                  ; 6 bytes
 strh r0,[r1],2 ;/                                                ;
 mov  r0,0      ;\Authentication status code (reserved/zero)      ;
 strh r0,[r1],2 ;/                                                ;/
;XXX .if with_nds_wpa ---> insert RSNIE element here?
 mov  r0,sp   ;packet                           ;\
 sub  r1,r0   ;len                              ; send queued
 bl   arm7_Wifi_TxQueue        ;out: r0         ;/
 add  sp,40h            ;-dealloc packet
 pop  pc
;------------------
arm7_Wifi_SendSharedKeyAuthPacket1:  ;in: none, out: r0
 push lr

        ;mov r0,'K' // bl wrchr_r0       ;XNAY pack

 sub  sp,40h            ;\alloc packet (max is 12+24+6 = 42 = 2Ah)
 mov  r1,sp             ;/
 mov  r0,(0 shl 2)+(0Bh shl 4)+000h  ;FC: Mgmt,Auth     ;\create TX header
 bl   arm7_Wifi_GenMgtHeader                            ;/and packet header
 mov  r0,1      ;\Authentication algorithm number (1=shared key) ;\
 strh r0,[r1],2 ;/                                               ;
 mov  r0,1      ;\Authentication sequence number                 ; 6 bytes
 strh r0,[r1],2 ;/                                               ;
 mov  r0,0      ;\Authentication status code (reserved/zero)     ;
 strh r0,[r1],2 ;/                                               ;/
 mov  r0,sp   ;packet                           ;\
 sub  r1,r0   ;len                              ; send queued
 bl   arm7_Wifi_TxQueue        ;out: r0         ;/
 add  sp,40h            ;-dealloc packet
 pop  pc
;------------------
arm7_Wifi_SendSharedKeyAuthPacket2:  ;in: r0=challenge_length, r1=challenge_Text, out: r0
 ;BUGGED: original code comment claimed "max size is 12+24+4+6 = 46", that
 ;doesn't include the "challenge", which could be max 257 bytes
 ;- - -
 push r4-r5,lr
 mov  r4,r0  ;challenge_length (max 255)
 mov  r5,r1  ;challenge_text

        ;mov r0,'U' // bl wrchr_r0       ;XNAY pack

 sub  sp,140h           ;\alloc packet (max is 12+24+4+6+257 = 303 = 12Fh)
 mov  r1,sp             ;/
 ldr  r0,=(0 shl 2)+(0Bh shl 4)+4000h ;FC.WEP,Mgmt,Auth ;\create TX header
 bl   arm7_Wifi_GenMgtHeader                            ;/and packet header
 mov  r0,1      ;\Authentication algorithm number (1=shared key);\
 strh r0,[r1],2 ;/                                              ;
 mov  r0,3      ;\Authentication sequence number (3)            ; 6 bytes
 strh r0,[r1],2 ;/                                              ;
 mov  r0,0      ;\Authentication status code (reserved/zero)    ;
 strh r0,[r1],2 ;/                                              ;/
 mov  r0,10h                    ;\Challenge Text Block (10h)    ;\
 strb r0,[r1],1                 ;/                              ;
 strb r4,[r1],1  ;chall_len     ;\                              ; max 2+255
 mov  r0,r5  ;chall_text  ;src  ; Challenge len, text           ; bytes
 mov  r2,r4  ;chall_len   ;len  ;                               ;
 bl   memcopy_bytewise          ;/                              ;/
 mov  r0,sp     ;packet                         ;\
 sub  r1,r0     ;len                            ; send queued
 bl   arm7_Wifi_TxQueue        ;out: r0         ;/
 add  sp,140h           ;-dealloc packet
 pop  r4-r5,pc
;------------------
arm7_Wifi_SendAssocPacket:  ;in: none, out: r0  ;uses arm7 data in our struct
 ;BUGGED: original code comment claimed "max size is 12+24+4+34+4 = 66", that
 ;counts only 4 bytes for rateset, although it could be max 17 bytes.
 ;- - -
 ;BUGGED: original code inserts two extra baserates, using two INCREASING loops
 ;that are copying baserates7[j]=baserates7[j-1], that is self-overwriting
 ;itself, so all "copied" baserates will be set to the SAME value.
 ;- - -
 ;XXX uh, what are those baserates good for anyways? the DS supports only two
 ;rates (which are forcefully inserted), so the other specified rates wouldn't
 ;be actually supported... is that good/intended?
 ;- - -
 push r4,lr

        ;mov r0,'S' // bl wrchr_r0       ;XNAY pack

 sub  sp,80h            ;\alloc packet (max is 12+24+4+34+17 = 91 = 5Bh)
 mov  r1,sp             ;/
 mov  r0,(0 shl 2)+(00h shl 4)+000h  ;FC: Mgmt,AssocReq ;\create TX header
 bl   arm7_Wifi_GenMgtHeader                            ;/and packet header
 ldr  r0,=WifiData_wepmode7     ;\                      ;\
 ldrb r0,[r0]                   ;                       ;
 cmp  r0,0                      ; CAPS info             ;
 moveq r0,21h  ;no WEP          ;                       ;
 movne r0,31h  ;WEP             ;                       ; 4 bytes
 strh r0,[r1],2           ;caps ;/                      ;
 ldr  r0,=4808000h              ;\                      ;
 ldrh r0,[r0,W_LISTENINT]       ; Listen interval       ;
 strh r0,[r1],2                 ;/                      ;/
 mov  r0,00h                    ;\SSID element          ;\
 strb r0,[r1],1           ;id   ;/                      ; SSID element
 ldr  r0,=WifiData_ssid7        ;\                      ; max 2+32 bytes
 ldrb r2,[r0],1  ;byte[0]=len   ; SSID len, name        ;
 strb r2,[r1],1           ;len  ;                       ;
 bl   memcopy_bytewise    ;name ;/                      ;/
 ldr  r4,=WifiData_baserates7                           ;\
 ldrb r0,[r4,0]                 ;\                      ;
 and  r0,7fh                    ; force insert rate 82h ;
 cmp  r0,02h     ;1Mbit/s       ; (unless 02h/82h is    ;
 beq  @@already_have_1Mbit      ; already there)        ;
 mov  r3,0eh                    ;                       ;
@@insert_1Mbit_lop:             ;                       ;
 ldrb r0,[r4,r3]                ;                       ;
 add  r3,1                      ;                       ;
 strb r0,[r4,r3]                ;                       ;
 subs r3,1+1                    ;                       ;
 bhs  @@insert_1Mbit_lop  ;>=0  ;                       ; adjust baserates
@@already_have_1Mbit:           ;                       ; (before issuing
 mov  r0,82h     ;1Mbit/s +80h  ;                       ; the rate set below)
 strb r0,[r4,0]                 ;/                      ;
 ldrb r0,[r4,1]                 ;\                      ;
 and  r0,7fh                    ; force insert rate 04h ;
 cmp  r0,04h     ;2Mbit/s       ; (unless 04h/84h is    ;
 beq  @@already_have_2Mbit      ; already there)        ;
 mov  r3,0eh                    ;                       ;
@@insert_2Mbit_lop:             ;                       ;
 ldrb r0,[r4,r3]                ;                       ;
 add  r3,1                      ;                       ;
 strb r0,[r4,r3]                ;                       ;
 subs r3,1+1                    ;                       ;
 bhi  @@insert_2Mbit_lop  ;>0   ;                       ;
@@already_have_2Mbit:           ;                       ;
 mov  r0,04h     ;2Mbit/s +0    ;                       ;
 strb r0,[r4,1]                 ;/                      ;
 mov  r0,00h                    ;\force end of list     ;
 strb r0,[r4,15]                ;/                      ;
 mov  r2,0   ;numrates          ;\                      ;
 mov  r3,r4                     ;                       ;
@@count_rates_lop:              ; count rates (r2)      ;
 ldrb r0,[r3],1                 ;                       ;
 cmp  r0,0                      ;                       ;
 addne r2,1  ;numrates          ;                       ;
 bne   @@count_rates_lop        ;/                      ;
 add  r3,r4,2                   ;\                      ;
@@clr_rate_msb_lop:             ; clear bit7 on all     ;
 ldrb r0,[r3]                   ; rates (except first   ;
 ands r0,7fh                    ; two rates)            ;
 strb r0,[r3],1                 ;                       ;
 bne  @@clr_rate_msb_lop        ;/                      ;/
 mov  r0,01h                    ;\Rate Set element      ;\
 strb r0,[r1],1           ;id   ;/                      ; rate set...
;mov  r2,r2  ;numrates          ;\                      ; max 2+15 bytes
 strb r2,[r1],1           ;len  ; Rate Set len, rates   ;
 ldr  r0,=WifiData_baserates7   ;                       ;
 bl   memcopy_bytewise    ;name ;/                      ;/
;XXX .if with_nds_wpa ---> insert RSNIE element here?
 mov  r0,sp     ;packet                         ;\
 sub  r1,r0     ;len                            ; send queued
 bl   arm7_Wifi_TxQueue        ;out: r0         ;/
 add  sp,80h            ;-dealloc packet
 pop  r4,pc
;------------------
arm7_Wifi_SendNullFrame:  ;in: none, out: r0
;BUGGED: original code has wrong size ("18+4", "30") (should be "16+4", "28")
;XXX should send BSSID as Addr1 (not apmac7... which is "DA"?)
;XXX "Data, toDS" should usually send "DA" as Addr3, but not done here?
;XXX and, there should be a 2-byte SequenceControl field at end of packet
 push lr

        ;mov r0,'N' // bl wrchr_r0       ;XNAY pack

 sub  sp,40h            ;\alloc packet (max is 12+16 = 28 = 1Ch)
 mov  r1,sp             ;/
 mov  r0,0                              ;\                              ;\
 str  r0,[r1],4                         ; status/reserved               ; TX HW
 str  r0,[r1],4                         ;/                              ; header
 ldr  r0,=WifiData_maxrate7             ;\rate/length                   ; 12byte
 ldrb r0,[r0]                           ; (len set later)               ;
 str  r0,[r1],4                         ;/                              ;/
 mov  r0,(2 shl 2)+(04h shl 4)+100h     ;\FC: Data, NullFunc, toDS      ;\

            ;;;orr r0,1000h  ;<-- power save ;XNAY (would cause DisAssoc)

 strh r0,[r1],2                         ;/                              ;
 mov  r0,0                              ;\Duration                      ; packet
 strh r0,[r1],2                         ;/                              ; header
 ldr  r0,=WifiData_apmac7        ;src   ;\Addr1=BSSID                   ;
 bl   arm7_Wifi_CopyMacAddr             ;/                              ;
 ldr  r0,=WifiData_MacAddr       ;src   ;\Addr2=SA                      ;
 bl   arm7_Wifi_CopyMacAddr             ;/                              ;/
 mov  r0,sp     ;packet                         ;\
 sub  r1,r0     ;len                            ; send queued
 bl   arm7_Wifi_TxQueue        ;out: r0         ;/
 add  sp,40h            ;-dealloc packet
 pop  pc
;------------------
arm7_Wifi_SendPSPollFrame:  ;in: none, out: r0    ;PS Power Save Poll
;BUGGED: original code used 4bit W_AID_LOW (instead of 12bit W_AID_FULL)
;UNUSED: used only by outcommented code
 push lr

        ;mov r0,'P' // bl wrchr_r0       ;XNAY pack

 sub  sp,40h            ;\alloc packet (max is 12+16 = 28 = 1Ch)
 mov  r1,sp             ;/
 mov  r0,0                              ;\                              ;\
 str  r0,[r1],4                         ; status/reserved               ; TX HW
 str  r0,[r1],4                         ;/                              ; header
 ldr  r0,=WifiData_maxrate7             ;\rate/length                   ; 12byte
 ldrb r0,[r0]                           ; (len set later)               ;
 str  r0,[r1],4                         ;/                              ;/
 mov  r0,(1 shl 2)+(0Ah shl 4)+100h     ;\FC: Ctrl, PSpoll, toDS        ;\
 strh r0,[r1],2                         ;/                              ;
 ldr  r0,=4808000h                      ;\                              ; packet
 ldrh r0,[r0,W_AID_FULL]                ; AID                           ; header
 orr  r0,0c000h  ;AID or C000h          ;                               ;
 strh r0,[r1],2                         ;/                              ;
 ldr  r0,=WifiData_apmac7        ;src   ;\Addr1=BSSID                   ;
 bl   arm7_Wifi_CopyMacAddr             ;/                              ;
 ldr  r0,=WifiData_MacAddr       ;src   ;\Addr2=TA                      ;
 bl   arm7_Wifi_CopyMacAddr             ;/                              ;/
 mov  r0,sp     ;packet                         ;\
 sub  r1,r0     ;len                            ; send queued
 bl   arm7_Wifi_TxQueue        ;out: r0         ;/
 add  sp,40h            ;-dealloc packet
 pop  pc
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm7\source\wifi_arm7.c 802.11b recv
;------------------
arm7_Wifi_ProcessReceivedFrame:  ;in: r0=macbase, r1=framelen, out: r0
;CHAOS: original code uses MORE than INSANE tabulation/indent in source code
;- - -
 push r4-r5,lr
 mov  r4,r0     ;macbase
 mov  r5,r1     ;framelen (BLAH: UNUSED)
 mov  r0,r4  ;macbase                   ;\
 mov  r1,0Ch            ;index to FC    ; get FC (type/subtype)
 bl   arm7_Wifi_MACRead ;get FC         ;/
 ands r1,r0,000ch           ;type       ;\
 and  r0,r0,00f0h           ;subtype    ;
 beq  @@managment_frames    ;type=0     ; handle FC: frame type
 cmp  r1,8                              ; (and get FC: subtype)
 blo  @@control_frames      ;type=1     ;
 beq  @@data_frames         ;type=2     ;
;bhi  @@reserved_frames     ;type=3     ;/
@@reserved_frames:
@@reserved_subtype:
 mov  r0,0      ;unexpected frame type/subtype
@@return_r0:
 pop  r4-r5,pc
;--- --- --- ------
@@control_frames:  ;in: r0=subtype*10h
 ;control.subtype 00h..09h = reserved
 ;control.subtype 0Ah      = PowerSave Poll
 ;control.subtype 0Bh      = RTS
 ;control.subtype 0Ch      = CTS
 ;control.subtype 0Dh      = ACK
 ;control.subtype 0Eh      = CF-End
 ;control.subtype 0Fh      = CF-End+CF-Ack
 cmp  r0,0a0h                   ;\reject control.subtype 0..9 (reserved)
 blo  @@reserved_subtype        ;/
 mov  r0,WFLAG_PACKET_CTRL      ;\accept control.subtype A..F
 b    @@return_r0               ;/
;--- --- --- ------
@@data_frames:  ;in: r0=subtype*10h
 ;data.subtype 00h      = Data                        ;\
 ;data.subtype 01h      = Data + CF-Ack               ; we like data!
 ;data.subtype 02h      = Data + CF-Poll              ;
 ;data.subtype 03h      = Data + CF-Ack + CF-Poll     ;/
 ;data.subtype 04h      = Null Function               ;\
 ;data.subtype 05h      = CF-Ack                      ; null-data
 ;data.subtype 06h      = CF-Poll                     ;
 ;data.subtype 07h      = CF-Ack + CF-Poll            ;/
 ;data.subtype 08h..0Fh = reserved                    ;-reserved
 cmp  r0,080h                   ;\reject data.subtype 8..F (reserved)
 bhs  @@reserved_subtype        ;/
 mov  r0,WFLAG_PACKET_DATA      ;\accept data.subtype 0..7
 b    @@return_r0               ;/
;--- --- --- ------
@@managment_frames:  ;in: r0=subtype*10h
 ldr  r1,=@@mgmt_jump_list
 ldr  r1,[r1,r0,lsr 4-2]   ;subtype 0..F
 bx   r1    ;---> jump
;---
@@mgmt_jump_list:        ;Subtype 0-F ;Frame Body:
 dd @@mgmt_Association_request     ;0 ;Capability, ListenInterval, SSID, SuppRates
 dd @@mgmt_Association_response    ;1 ;Capability, Status, AID, SuppRates
 dd @@mgmt_Reassociation_request   ;2 ;Capability, ListenInterval, CurrAP, SSID, SuppRates
 dd @@mgmt_Reassociation_response  ;3 ;Capability, Status, AID, SuppRates
 dd @@mgmt_probe_request           ;4 ;SSID, SuppRates
 dd @@mgmt_probe_response          ;5 ;Same as for Beacon (but without TIM)
 dd @@reserved_subtype             ;6 ;--reserved--
 dd @@reserved_subtype             ;7 ;--reserved--
 dd @@mgmt_Beacon                  ;8 ;Timestamp,BeaconInterval,Capability,SSID,SuppRates, FH Parameter Set (when using Frequency Hopping), DS Parameter Set (when using Direct Sequence), CF Parameter Set (when supporting PCF), IBSS Parameter Set (when in an IBSS), TIM (when generated by AP)
 dd @@mgmt_ATIM_traffic_indication ;9 ;Body is "null" (=none?)
 dd @@mgmt_Disassociation          ;A ;ReasonCode
 dd @@mgmt_Authentication          ;B ;AuthAlgorithm, AuthSequence, Status, ChallengeText
 dd @@mgmt_Deauthentication        ;C ;ReasonCode
 dd @@reserved_subtype             ;D ;--reserved--
 dd @@reserved_subtype             ;E ;--reserved--
 dd @@reserved_subtype             ;F ;--reserved--
;--- --- --- ------
@@mgmt_Disassociation:          ;A ;ReasonCode

   mov  r0,'-' // bl wrchr_r0    ;XNAY --- this does occur sometimes on reboot?
   mov  r0,'-' // bl wrchr_r0
   mov  r0,'D' // bl wrchr_r0
   mov  r0,'I' // bl wrchr_r0
   mov  r0,'S' // bl wrchr_r0
   mov  r0,'-' // bl wrchr_r0
   mov  r0,'-' // bl wrchr_r0

         ldr   r1,=WifiData_authlevel                   ;\ XNAY? XYES!
         mov   r0,WIFI_AUTHLEVEL_DEASSOCIATED           ;  not done by original code !?!
         strh  r0,[r1]                                  ;/ (and NOT NEEDED by original code, ie. unwanted disassoc occurs only in ASM port, probably due to some error elsewhere in ASM code)

            ;above HELPs for recovering from unwanted Dissassoc
            ;reason WHY unwanted Disassoc occurs seems to be initialization issue:
            ; - occurs on COLDBOOT (when console was OFF for several hours)
            ; - occurs after playing DownhillJam in wifi-mode (as master of 2-player local game)


@@mgmt_Association_request:     ;0 ;Capability, ListenInterval, SSID, SuppRates
@@mgmt_Reassociation_request:   ;2 ;Capability, ListenInterval, CurrAP, SSID, SuppRates
@@mgmt_probe_request:           ;4 ;SSID, SuppRates
@@mgmt_ATIM_traffic_indication: ;9 ;Body is "null" (=none?)  ;ATIM (Announcement traffic indication message)
 mov  r0,WFLAG_PACKET_MGT   ;\
 b    @@return_r0           ;/
;--- --- --- ------
@@mgmt_probe_response:          ;5 ;Same as for Beacon (but without TIM)
 mov  r0,r4  ;macbase
 bl   arm7_process_beacon_or_probe_response
 mov  r0,WFLAG_PACKET_MGT   ;\
 b    @@return_r0           ;/
;---
@@mgmt_Beacon:                  ;8 ;Timestamp,BeaconInterval,Capability,SSID,SuppRates, FH Parameter Set (when using Frequency Hopping), DS Parameter Set (when using Direct Sequence), CF Parameter Set (when supporting PCF), IBSS Parameter Set (when in an IBSS), TIM (when generated by AP)
 mov  r0,r4  ;macbase
 bl   arm7_process_beacon_or_probe_response
 mov  r0,WFLAG_PACKET_BEACON;\
 b    @@return_r0           ;/
;--- --- --- ------
@@mgmt_Association_response:    ;1 ;Capability, Status, AID, SuppRates
@@mgmt_Reassociation_response:  ;3 ;Capability, Status, AID, SuppRates
 ;we might have been associated, let's check...
 sub  sp,64     ;alloc buf
 mov  r0,r4  ;macbase                   ;\
 mov  r1,08h            ;index to LEN   ;
 bl   arm7_Wifi_MACRead ;get LEN        ;
 add  r3,r0,1                           ; get length (from RX hw header)
 bic  r3,1      ;align                  ;
 cmp  r3,64                             ;
 movhi r3,64    ;max                    ;/
 mov  r0,sp                   ;dst      ;\
 mov  r1,r4  ;macbase         ;src.base ;
 mov  r2,0ch                  ;src.offs ;
;mov  r3,r3                   ;len      ;
 bl   arm7_Wifi_MACCopy                 ;/
 add  r0,sp,4                 ;src1     ;\
 ldr  r1,=WifiData_MacAddr    ;src2     ;
 bl   arm7_Wifi_CmpMacAddr              ; check if packet is indeed sent to us
 cmp  r0,0                              ;
 beq  @@assoc_mismatch                  ;/
 add  r0,sp,16                ;src1     ;\
 ldr  r1,=WifiData_bssid7     ;src2     ; check if packet is indeed from the
 bl   arm7_Wifi_CmpMacAddr              ; base station we're trying to
 cmp  r0,0                              ; associate to.
 beq  @@assoc_mismatch                  ;/
 ldrh r0,[sp,24+2]                      ;\
 cmp  r0,0  ;status code (0=success)    ;
 movne  r0,WIFIMODE_CANNOTASSOCIATE     ; check if failed
 ldrne  r1,=WifiData_curMode            ;
 strneh r0,[r1]                         ;
 bne    @@assoc_done                    ;/
 ldr  r1,=4808000h                      ;\
 ldrh r0,[sp,24+4]                      ; okay, apply AID
 strh r0,[r1,W_AID_LOW]                 ;
 strh r0,[r1,W_AID_FULL]                ;/
 mov  r0,0ah  ;initially 1Mbit/s        ;\
 ldrb r2,[sp,24+7] ;num rates           ;
 add  r1,sp,24+8   ;rate list           ;
 cmp  r2,0         ;num rates           ; set max rate
 beq  @@rate_done                       ;
@@rate_lop:                             ;
 ldrb r3,[r1],1    ;rate list           ;
 and  r3,7fh                            ;
 cmp  r3,04h                            ;
 moveq r0,14h ;support 2Mbit/s          ;
 subs r2,1                              ;
 bne  @@rate_lop                        ;
@@rate_done:                            ;
 ldr  r1,=WifiData_maxrate7             ;
 strb r0,[r1]                           ;/
 ldr  r1,=WifiData_authlevel            ;\
 ldrh r0,[r1]                           ;
 cmp    r0,WIFI_AUTHLEVEL_AUTHENTICATED ; if old level was
 cmpne  r0,WIFI_AUTHLEVEL_DEASSOCIATED  ; authenticated or deassociated,
 moveq  r0,WIFI_AUTHLEVEL_ASSOCIATED    ; set new level to associated and
;ldreq  r1,=WifiData_authlevel          ; reset auth ctr
 streqh r0,[r1]  ;new auth level        ;
 moveq  r0,0                            ;
 ldreq  r1,=WifiData_authctr            ;
 streqh r0,[r1]  ;new auth ctr          ;/
@@assoc_done:
@@assoc_mismatch:
 add  sp,64     ;dealloc buf
 mov  r0,WFLAG_PACKET_MGT   ;\
 b    @@return_r0           ;/
;--- --- --- ------
@@mgmt_Authentication:          ;B ;AuthAlgorithm, AuthSequence, Status, ChallengeText
 .if with_soft_wep
    ;;;mov  r0,r4  ;macbase
    ;;;bl   wifi_decrypt    ;XXXsoft_wep decrypt here
 .endif
;- - -
 sub  sp,384    ;alloc buf
 mov  r0,r4  ;macbase                   ;\
 mov  r1,08h            ;index to LEN   ;
 bl   arm7_Wifi_MACRead ;get LEN        ;
 add  r3,r0,1                           ; get length (from RX hw header)
 bic  r3,1      ;align                  ;
 cmp  r3,384                            ;
 movhi r3,384   ;max                    ;/
 mov  r0,sp                   ;dst      ;\
 mov  r1,r4  ;macbase         ;src.base ;
 mov  r2,0ch                  ;src.offs ;
;mov  r3,r3                   ;len      ;
 bl   arm7_Wifi_MACCopy                 ;/
 add  r0,sp,4                 ;src1     ;\
 ldr  r1,=WifiData_MacAddr    ;src2     ;
 bl   arm7_Wifi_CmpMacAddr              ; check if packet is indeed sent to us
 cmp  r0,0                              ;
 beq  @@auth_mismatch                   ;/
 add  r0,sp,16                ;src1     ;\
 ldr  r1,=WifiData_bssid7     ;src2     ; check if packet is indeed from the
 bl   arm7_Wifi_CmpMacAddr              ; base station we're trying to
 cmp  r0,0                              ; associate to.
 beq  @@auth_mismatch                   ;/
 ldrh r0,[sp,24+0]  ;type               ;\
 cmp  r0,0                              ;
 beq  @@auth_open_system                ; check auth type
 cmp  r0,1                              ;
 beq  @@auth_shared_key                 ;
 b    @@auth_mismatch                   ;/
;- - -
@@auth_open_system:
 ldrh r0,[sp,24+2]  ;seq                ;\
 cmp  r0,2                              ; want seq 2, should be final sequence
 bne  @@auth_mismatch                   ;/
 ldrh r0,[sp,24+4]  ;stat               ;\
 cmp  r0,0                              ; want status okay
 bne  @@auth_open_system_fail           ;/
@@auth_finish_final_seq:
 ldr  r1,=WifiData_authlevel            ;\
 ldrh r0,[r1]                           ; want old level = disconnected
 cmp  r0,WIFI_AUTHLEVEL_DISCONNECTED    ;
 bne  @@auth_mismatch                   ;/
;ldr  r1,=WifiData_authlevel            ;\
 mov  r0,WIFI_AUTHLEVEL_AUTHENTICATED   ; okay, set new level
 strh r0,[r1]                           ;/
 mov  r0,0                              ;\
 ldr  r1,=WifiData_authctr              ; okay, reset auth ctr
 strh r0,[r1]  ;new auth ctr            ;/
 bl   arm7_Wifi_SendAssocPacket         ;-okay, send assoc packet
 b    @@auth_done
;---
@@auth_open_system_fail:                ;\status code: rejected,
 bl   arm7_Wifi_SendSharedKeyAuthPacket1; try something else
 b    @@auth_mismatch                   ;/
;---
@@auth_shared_key:
 ldrh r0,[sp,24+4]  ;stat               ;\
 cmp  r0,0                              ; want status okay
 bne  @@auth_shared_key_fail            ;/
 ldrh r0,[sp,24+2]  ;seq                ;\
 cmp  r0,4                              ; want seq 4 (final, accept/deny)
 beq  @@auth_finish_final_seq           ; or
 cmp  r0,2                              ; want seq 2 (challenge text)
 bne  @@auth_mismatch                   ;/
 ldrb r0,[sp,24+6]  ;id                 ;\
 cmp  r0,10h  ;id challenge text        ; seq 2, want challenge text...
 bne  @@auth_mismatch                   ;/
 ldrb r0,[sp,24+7]  ;len                ;\scrape challenge text and
 add  r1,sp,24+8    ;text               ; send challenge reply
 bl   arm7_Wifi_SendSharedKeyAuthPacket2;/
 b    @@auth_done
@@auth_shared_key_fail:
 ldr  r1,=WifiData_curMode              ;\status code: rejected,
 mov  r0,WIFIMODE_CANNOTASSOCIATE       ; give up, cry in the corner
 strh r0,[r1]                           ;/
@@auth_done:
@@auth_mismatch:
 add  sp,384    ;dealloc buf
 mov  r0,WFLAG_PACKET_MGT   ;\
 b    @@return_r0           ;/
;--- --- --- ------
@@mgmt_Deauthentication:        ;C ;ReasonCode


      ;XXXXXX this DOES occur after some minutes !!!!!!!!!!!!!
      ;(maybe due to still bugged NullFrame's?)
   mov  r0,'-' // bl wrchr_r0     ;XNAY
   mov  r0,'-' // bl wrchr_r0
   mov  r0,'D' // bl wrchr_r0
   mov  r0,'E' // bl wrchr_r0
   mov  r0,'A' // bl wrchr_r0
   mov  r0,'U' // bl wrchr_r0
   mov  r0,'T' // bl wrchr_r0
   mov  r0,'H' // bl wrchr_r0
   mov  r0,'-' // bl wrchr_r0
   mov  r0,'-' // bl wrchr_r0

 sub  sp,64     ;alloc buf
 mov  r0,r4  ;macbase                   ;\
 mov  r1,08h            ;index to LEN   ;
 bl   arm7_Wifi_MACRead ;get LEN        ;
 add  r3,r0,1                           ; get length (from RX hw header)
 bic  r3,1      ;align                  ;
 cmp  r3,64                             ;
 movhi r3,64    ;max                    ;/
 mov  r0,sp                   ;dst      ;\
 mov  r1,r4  ;macbase         ;src.base ;
 mov  r2,0ch                  ;src.offs ;
;mov  r3,r3                   ;len      ;
 bl   arm7_Wifi_MACCopy                 ;/
 add  r0,sp,4                 ;src1     ;\
 ldr  r1,=WifiData_MacAddr    ;src2     ;
 bl   arm7_Wifi_CmpMacAddr              ; check if packet is indeed sent to us
 cmp  r0,0                              ;
 beq  @@deauth_mismatch                 ;/
 add  r0,sp,16                ;src1     ;\
 ldr  r1,=WifiData_bssid7     ;src2     ; check if packet is indeed from the
 bl   arm7_Wifi_CmpMacAddr              ; base station we're trying to
 cmp  r0,0                              ; associate to.
 beq  @@deauth_mismatch                 ;/
;bad things! they booted us! back to square 1...
 ldr  r0,=WifiData_curReqFlags          ;\
 ldrh r0,[r0]                           ; check adhoc
 tst  r0,WFLAG_REQ_APADHOC              ;
 beq  @@deauth_non_adhoc                ;/
 ldr  r1,=WifiData_authlevel            ;\uh, mark as AUTHENTICAED,
 mov  r0,WIFI_AUTHLEVEL_AUTHENTICATED   ;     upon DE-AUTHENTICATION ???
 strh r0,[r1]                           ;/    maybe that's correct/intended?
 bl   arm7_Wifi_SendAssocPacket         ;-
 b    @@deauth_done
@@deauth_non_adhoc:
 ldr  r1,=WifiData_authlevel            ;\
 mov  r0,WIFI_AUTHLEVEL_DISCONNECTED    ; mark as disconnected
 strh r0,[r1]                           ;/
 bl   arm7_Wifi_SendOpenSystemAuthPacket;-
@@deauth_done:
@@deauth_mismatch:
 add  sp,64     ;dealloc buf
 mov  r0,WFLAG_PACKET_MGT   ;\
 b    @@return_r0           ;/
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm7\source\wifi_arm7.c 802.11b beacon
;------------------
arm7_process_beacon_or_probe_response:  ;in: r0=macbase
 ;mine data from the beacon (or probe response)...
 ;- - -
 ;CHAOS: original code used a nightmare codeflow/codingstyle for doing this...
 ;with variable "seglen" misused as "bssid_found" flag
 ;with variable "segtype" misused as "oldest_entry" index
 ;with two huge (but nearly identical) code blocks for create/update entry
 ;with "WFLAG_APDATA_xxx" flags disguised as "wepmode,wpamode,compatible" etc
 ;with confusing "12+24" (actually ordered 24+12) and "5+12" (actually mul2)
 ;- - -
 ;BUGGED: original code leaves SSID uninitialized (if no SSID transferred)
 ;BUGGED: original code sets base_rates to GARBAGE (if no rateset transferred)
 ;- - -
 ;uh, original code has very weird rateset handling (not sure if it's correct):
 ;can set ONLY one of WFLAG_APDATA_COMPATIBLE and WFLAG_APDATA_EXTCOMPATIBLE
 ;(in cases where BOTH flags could/should get set, it does set ONLY one of
 ;those flags: whichever occurs LAST in the rateset list).
 ;if the rateset list contains a rate that matches to NEITHER of the above
 ;types, then it does abort rateset handling, and treats the accesspoint as not
 ;compatible (even if it does ALSO contain compatible rates in the rateset).
 ;in case of WFLAG_APDATA_EXTCOMPATIBLE we "have to fake our way in" (whut?)
 ;- - -
 push r4-r7,lr
 sub  sp,sgBeacon_size  ;\alloc beacon header info
 mov  r4,sp             ;/
 sub  sp,512            ;\alloc frame data buffer
 mov  r5,sp             ;/
 mov  r7,r0             ;-macbase
;- - - - - -
 mov  r0,r7  ;macbase                   ;\
 mov  r1,08h            ;index to LEN   ;
 bl   arm7_Wifi_MACRead ;get LEN        ; get packet len
 mov  r6,r0   ;packet_len               ;
 cmp  r6,512  ;packet_len ;\crop max    ;
 movhi r6,512 ;packet_len ;/buffer size ;/
 mov  r0,r7  ;macbase                   ;\
 mov  r1,0Ah   ;"rssi_" ;index to RSSI  ;
 bl   arm7_Wifi_MACRead ;get RSSI       ; get RSSI (signal strength)
;and  r0,00ffh          ;isolate RSSI   ;
 strb r0,[r4,sgBeacon_strength]         ;/
 mov  r0,r5  ;data buffer          ;dst ;\
 mov  r1,r7  ;macbase         ;src.base ;
 mov  r2,0ch                  ;src.offs ; copy packet to
 add  r3,r6,1 ;packet_len round-up ;len ; data buffer
 bic  r3,1    ;align               ;len ;
 bl   arm7_Wifi_MACCopy                 ;/
 add  r0,r5,10   ;SA               ;src ;\
 add  r1,r4,sgBeacon_sa            ;dst ; get SA
 bl   arm7_Wifi_CopyMacAddr             ;/
 add  r0,r5,16   ;BSSID            ;src ;\
 add  r1,r4,sgBeacon_bssid         ;dst ; get BSSID
 bl   arm7_Wifi_CopyMacAddr             ;/
;- - -
 mov  r0,r4     ;beacon info                    ;\
 add  r1,r5,24  ;frame body, after IEEE(24)     ;
 subs r2,r6,24  ;frame len                      ;
 blhi arm7_parse_beacon_or_probe_response       ;/
;- - -
 add  sp,512            ;dealloc data buffer
 add  sp,sgBeacon_size  ;dealloc
 pop  r4-r7,pc
;------------------
;:----------------- dswifi-src-0.3.17.tar\arm7\source\wifi_arm7.c Sync Funcs
;------------------
;arm7_Wifi_Sync:  ;in/out: none
; b    arm7_Wifi_Update
;------------------
;arm7_Wifi_SetSyncHandler:  ;in: r0=WifiSyncHandler, out: none
; ldr  r1,=arm7_synchandler      ;\apply sync handler
; str  r0,[r1]                   ;/(always with r0=arm7_synctoarm9)
; bx   lr
;------------------
arm7_wifiValue32Handler:  ;in: r0=value, r1=data/optional, out: none  ;"static"
 cmp   r0,WIFI_SYNC                     ;\WIFI_SYNC    --> sync Wifi
 beq   arm7_Wifi_Update                 ;/
 cmp   r0,WIFI_DISABLE                  ;\
 moveq r0,IRQ_WIFI                      ; WIFI_DISABLE --> disable Wifi IRQ
 beq   arm7_irqDisable                  ;/
 cmp   r0,WIFI_ENABLE                   ;\
 moveq r0,IRQ_WIFI                      ; WIFI_ENABLE  --> enable Wifi IRQ
 beq   arm7_irqEnable                   ;/
 cmp   r0,WIFI_STARTUP                  ;\
 ldreq r0,=Wifi_Data_Struct_start       ; WIFI_STARTUP
 beq   arm7_Wifi_Init                   ;/
 bx    lr                               ;-OTHER        --> exit/ignore
;------------------
;:----------------- dswifi---soft_wep
;------------------
.if with_soft_wep
;------------------



.comment
In cryptography, RC4 (Rivest Cipher 4 also known as ARC4 or ARCFOUR meaning
Alleged RC4, see below) is a stream cipher.

Key-scheduling algorithm (KSA)[edit]
The key-scheduling algorithm is used to initialize the permutation in the
array "S". "keylength" is defined as the number of bytes in the key and can
be in the range 1 = keylength = 256, typically between 5 and 16, corresponding
to a key length of 40 - 128 bits. First, the array "S" is initialized to the
identity permutation. S is then processed for 256 iterations in a similar way
to the main PRGA, but also mixes in bytes of the key at the same time.
  for i from 0 to 255
      S[i] := i
  endfor
  j := 0
  for i from 0 to 255
      j := (j + S[i] + key[i mod keylength]) mod 256
      swap values of S[i] and S[j]
  endfor



Pseudo-random generation algorithm (PRGA)[edit]
For as many iterations as are needed, the PRGA modifies the state and outputs
a byte of the keystream. In each iteration, the PRGA increments i, looks up
the ith element of S, S[i], and adds that to j, exchanges the values of S[i]
and S[j], and then uses the sum S[i] + S[j] (modulo 256) as an index to fetch
a third element of S, (the keystream value K below) which is bitwise exclusive
OR'ed (XOR'ed) with the next byte of the message to produce the next byte of
either ciphertext or plaintext. Each element of S is swapped with another
element at least once every 256 iterations.
  i := 0
  j := 0
  while GeneratingOutput:
      i := (i + 1) mod 256
      j := (j + S[i]) mod 256
      swap values of S[i] and S[j]
      K := S[(S[i] + S[j]) mod 256]
      output K
  endwhile



WEP was included as the privacy component of the original IEEE 802.11 standard
ratified in 1997.[6][7] WEP uses the stream cipher RC4 for confidentiality,[8]
and the CRC-32 checksum for integrity.[9] It was deprecated in 2004 and is
documented in the current standard.[10]

  Basic WEP encryption: RC4 keystream XORed with plaintext

Standard 64-bit WEP uses a 40 bit key (also known as WEP-40), which is
concatenated with a 24-bit initialization vector (IV) to form the RC4 key.
At the time that the original WEP standard was drafted, the U.S. Government's
export restrictions on cryptographic technology limited the key size. Once
the restrictions were lifted, manufacturers of access points implemented an
extended 128-bit WEP protocol using a 104-bit key size (WEP-104).

A 64-bit WEP key is usually entered as a string of 10 hexadecimal (base 16)
characters (0-9 and A-F). Each character represents 4 bits, 10 digits of 4
bits each gives 40 bits; adding the 24-bit IV produces the complete 64-bit
WEP key (4 bits  10 + 24 bits IV = 64 bits of WEP key). Most devices also
allow the user to enter the key as 5 ASCII characters (0-9, a-z, A-Z), each
of which is turned into 8 bits using the character's byte value in ASCII
(8 bits  5 + 24 bits IV = 64 bits of WEP key); however, this restricts each
byte to be a printable ASCII character, which is only a small fraction of
possible byte values, greatly reducing the space of possible keys.

A 128-bit WEP key is usually entered as a string of 26 hexadecimal characters.
26 digits of 4 bits each gives 104 bits; adding the 24-bit IV produces the
complete 128-bit WEP key (4 bits  26 + 24 bits IV = 128 bits of WEP key).
Most devices also allow the user to enter it as 13 ASCII characters
(8 bits  13 + 24 bits IV = 128 bits of WEP key).

A 152-bit and a 256-bit WEP systems are available from some vendors. As with
the other WEP variants, 24 bits of that is for the IV, leaving 128 or 232 bits
for actual protection. These 128 or 232 bits are typically entered as 32 or 58
hexadecimal characters (4 bits  32 + 24 bits IV = 152 bits of WEP key,
4 bits  58 + 24 bits IV = 256 bits of WEP key). Most devices also allow the
user to enter it as 16 or 29 ASCII characters
(8 bits  16 + 24 bits IV = 152 bits of WEP key,
8 bits  29 + 24 bits IV = 256 bits of WEP key).


In Open System authentication, the WLAN client need not provide its credentials to the Access Point during authentication. Any client can authenticate with the Access Point and then attempt to associate. In effect, no authentication occurs. Subsequently, WEP keys can be used for encrypting data frames. At this point, the client must have the correct keys.

In Shared Key authentication, the WEP key is used for authentication in a four-step challenge-response handshake:
 1.The client sends an authentication request to the Access Point.
 2.The Access Point replies with a clear-text challenge.
 3.The client encrypts the challenge-text using the configured WEP key and
   sends it back in another authentication request.
 4.The Access Point decrypts the response. If this matches the challenge text,
   the Access Point sends back a positive reply.
After the authentication and association, the pre-shared WEP key is also used for encrypting the data frames using RC4.


"The Protected Frame field is 1 bit in length. It The Protected Frame field is
set to 1 if the Frame Body field contains information that has been processed
by a cryptographic encapsulation algorithm.The Protected Frame field is set to
1 only within data frames of type Data and within management frames of type
Management, subtype Authentication. The Protected Frame field is set to 0 in
all other frames. When the bit Protected Frame field is set to 1 in a data
frame, the Frame Body field is protected utilizing the cryptographic
encapsulation algorithm and expanded as defined in Clause 8. Only WEP is
allowed as the cryptographic encapsulation algorithm for management frames of
subtype Authentication."





.comment


;------------------
wifi_encrypt_loc3:
 ldr  r0,=WIFIRAM_BASE32+WIFIRAM_TX_LOC3_START
 ldrh r2,[r0,0ch] ;FC:          ;\
 tst  r2,4000h    ;FC.WEP flag  ; exit if FCS.WEP=0
 bxeq lr                        ;/
;- - -
 push r4-r5,lr
;XXX could adjust IV here (instead currently done elsewhere)

 ldrh r1,[r0,0ah]  ;TX[0Ah]  2   Length of IEEE Frame Header+Body+checksum(s) in bytes
      ;push r0
      ;mov  r0,r1 // bl wrhex32bit   ;=174h
      ;pop  r0
 sub  r1,4+4 ;exclude WEP.FCS, FCS              ;
 bl   wep_compute_raw_addr_len                  ;
 mov  r4,r0  ;addr                              ;
 mov  r5,r1  ;len                               ;/

   ;;;mov  r0,r1 // bl wrhex32bit   ;=150h
   ;;;ldrh r0,[r4,-2] // bl wrhex16bit  ;=00xxh  (IV.MSB=xx and KEY.ID=00)

 mov  r1,r4  ;addr                              ;\
 mov  r2,r5  ;len                               ;
 bl   calc_crc32                                ;
       mvn  r0,r0 ;invert   ;maybe? yes?

   sub sp,8
 add  r2,r4,r5  ;addr=addr+len
 and  r1,r2,3   ;addr lsbs
 bic  r2,3      ;addr aligned
 ldr  r3,[r2,0] ;\
 str  r3,[sp,0] ; grab              ;append_crc32 (to UNALIGNED 16bit RAM)
 ldr  r3,[r2,4] ;
 str  r3,[sp,4] ;/
 .rept 4
  strb r0,[sp,r1];-modify
  add  r1,1
  mov  r0,r0,ror 8
 .endm
 ldr  r3,[sp,0] ;\
 str  r3,[r2,0] ; putback
 ldr  r3,[sp,4] ;
 str  r3,[r2,4] ;/
   add sp,8

   mov  r0,'E' // bl wrchr_r0

 mov  r0,r4   ;addr                             ;\
 add  r1,r5,4 ;len (including crc32)            ; encrypt to 16bit RAM using IV and KEY
 mov  r2,r4   ;dst
 mov  r3,-1   ;max (no limit)
 bl   wep_rc4_crypt                             ;/

 pop  r4-r5,pc
;------------------
wifi_decrypt:   ;in: r0=addr
 ldr  r1,=4804000h
 ldr  r3,=4804000h+WIFIRAM_RX_BUFFER_SIZE+WIFIRAM_RX_BUFFER_START
 add  r0,r1

 add  r1,r0,0ch    ;base+offset(FC)
 cmp   r1,r3                                                    ;\wrap
 subhs r1,WIFIRAM_RX_BUFFER_SIZE                                ;/
 ldrh r2,[r1]     ;FC:          ;\
 tst  r2,4000h    ;FC.WEP flag  ; exit if FCS.WEP=0
 bxeq lr                        ;/
;- - -
 push r4-r5,lr
 add  r1,r0,08h    ;base+offset(LEN)
 cmp   r1,r3                                                    ;\wrap
 subhs r1,WIFIRAM_RX_BUFFER_SIZE                                ;/
 ldrh r5,[r1]  ;RX[08h]  2   Length of IEEE Frame Header+Body in bytes (excluding FCS checksum)
 sub  r5,4+4 ;exclude WEP.IV, WEP.FCS
 strh r5,[r1]  ;RX[08h] ;writeback RX[08h] (exclude IV and WEP.FCS)
 add  r1,r5,4   ;re-include WEP.IV
 bl   wep_compute_raw_addr_len                  ;
 mov  r4,r0  ;addr                              ;
 mov  r5,r1  ;len                               ;/
;mov  r0,r0   ;addr                             ;\
 add  r1,r1,4 ;len (including crc32)            ; decrypt RAM using IV and KEY
 sub  r2,r0,4 ;dst (reloc to IV excluded)
 ldr  r3,=4804000h+WIFIRAM_RX_BUFFER_SIZE+WIFIRAM_RX_BUFFER_START
 bl   wep_rc4_crypt    ;in: r0=addr, r1=len     ;/

   mov  r0,'D' // bl wrchr_r0

;XXX optionally calc_crc32 + verify_crc32 (from UNALIGNED RAM)
                ;XXX but crc32 calc should WRAP in RXBUF if needed

 pop  r4-r5,pc
;------------------
wep_compute_raw_addr_len:   ;io: r0=addr, r1=len, r2=FC
 ands r3,r2,03h shl 2  ;FC.type
 beq  @@type0_managment
 cmp  r3,02h shl 2     ;FC.type
 beq  @@type2_data
;blo  @@type1_control
;bhi  @@type3_reserved
 mov  r1,0  ;len (oops, control/reserved shall not have WEP)
 bx   lr
;---
@@type0_managment:
 add  r0,4+(2+2+6+6+6+2)+0ch   ;skip IV,FrameHdr,HwHdr
 sub  r1,4+(2+2+6+6+6+2)
 bx   lr
;---
@@type2_data:
;All Data Frames consist of the following components:
;FC, Duration/ID, Address 1, Address 2, Address 3, Sequence Control,
;Address 4 (only on From DS to DS), Frame Body, FCS.
 add  r0,4+(2+2+6+6+6+2)+0ch   ;skip IV,FrameHdr,HwHdr
 sub  r1,4+(2+2+6+6+6+2)
 and  r3,r2,03h shl 8  ;FC.FromDStoDS
 cmp  r3,03h shl 8
 addeq r0,(6)  ;Addr4 (only on From DS to DS)
 subeq r1,(6)  ;Addr4 (only on From DS to DS)
 bx   lr
;------------------
wep_rc4_crypt:    ;in: r0=addr.src, r1=len, r2=addr.dst, r3=max (and [addr-4]=IV)
 push r4-r12,lr
 sub  sp,100h   ;alloc sbox
 mov  r8,r0             ;addr
 mov  r9,r1             ;len
 mov  r10,r2            ;dst
 mov  r11,r3            ;max
 ldr  r4,=wep_key
 ldrh r0,[r8,-4]        ;[addr-4]       ;\                 XXX wrap in RXBUF if needed
 ldrh r1,[r8,-2]        ;[addr-2]       ; insert 24bit IV to key
 strh r0,[r4,0]         ;key[0..1]      ;
 strb r1,[r4,2]         ;key[2]         ;/
 mov  r0,sp             ;sbox           ;\
 ldr  r5,=03020100h     ;i              ;
 ldr  r6,=04040404h     ;step           ;
@@init_lop:                             ; clear sbox
 str  r5,[r0],4         ;sbox[i]        ;
 adds r5,r6             ;i+step         ;
 bcc  @@init_lop                        ;/
 ldr  r2,=wep_keylen                    ;\
 ldrb r2,[r2]           ;keylen         ;
 mov  r5,00h shl 24     ;i=0            ;
 mov  r6,00h shl 24     ;j=0            ;
 mov  r7,0              ;k=0            ;
@@shuffle_lop:                          ;
 ldrb r0,[r4,r7]        ;key[k]         ;
 ldrb r1,[sp,r5,lsr 24] ;sbox[i]        ; apply key to sbox
 add  r6,r6,r0,lsl 24   ;j+r0           ;
 add  r6,r6,r1,lsl 24   ;j+r1           ;
 ldrb r0,[sp,r6,lsr 24] ;sbox[j] ;\     ;
 strb r1,[sp,r6,lsr 24] ;sbox[j] ; swap ;
 strb r0,[sp,r5,lsr 24] ;sbox[i] ;/     ;
 add  r7,1              ;\              ;
 cmp  r7,r2  ;keylen    ; k+1           ;
 moveq r7,0             ;/              ;
 adds r5,01h shl 24     ;\i+1           ;
 bcc  @@shuffle_lop     ;/              ;/
;- - -
;mov  r5,00h shl 24     ;i=0            ;\
 mov  r6,00h shl 24     ;j=0            ;
@@crypt_lop:                            ;
 .macro @@crypt
  add  r5,01h shl 24     ;i+1            ;
  ldrb r0,[sp,r5,lsr 24] ;sbox[i] ;\     ; crypt
  add  r6,r6,r0,lsl 24   ;j+r0    ;/     ;
  ldrb r1,[sp,r6,lsr 24] ;sbox[j] ;\     ;
  strb r0,[sp,r6,lsr 24] ;sbox[j] ; swap ;
  strb r1,[sp,r5,lsr 24] ;sbox[i] ;/     ;
  add  r0,r1                      ;\     ;
  and  r0,0ffh                    ;      ;
  ldrb r0,[sp,r0]        ;sbox[x] ;/     ;
 .endm
 @@crypt
 mov  r7,r0
 @@crypt
 orr  r0,r7,r0,lsl 8

 cmp   r8,r11                                                   ;\wrap
 subhs r8,WIFIRAM_RX_BUFFER_SIZE                                ;/
 cmp   r10,r11                                                   ;\wrap
 subhs r10,WIFIRAM_RX_BUFFER_SIZE                                ;/

 ldrh r1,[r8],2         ;\              ;
 eor  r1,r0             ; crypt         ;
 strh r1,[r10],2        ;/              ;
 subs r9,2      ;len                    ;
 bhi  @@crypt_lop                       ;/
 add  sp,100h   ;dealloc sbox
 pop  r4-r12,pc
;------------------
create_crc32_table:   ;for WEP
 mov   r1,0                     ;\
 ldr   r2,=crc32_table          ;
 ldr   r3,=0edb88320h           ;
@@lop1:                         ;
 mov   r0,r1                    ;
@@lop2: ;looped 8 times         ;
 movs  r0,r0,lsr 1              ; make crc table
 eorcs r0,r0,r3 ;r3=0edb88320h  ;
 adds  r1,20000000h             ;
 bcc   @@lop2                   ;
 str   r0,[r2,r1,lsl 2]         ;
 add   r1,1                     ;
 cmp   r1,100h                  ;
 bne   @@lop1                   ;/
 bx    lr
;------------------
calc_crc32:      ;in: r1=src, r2=len - out: r0   ;for WEP
 mov  r0,-1   ;initial value
;- - - - - --------
update_crc32:    ;in: r0=initial value (usually -1), r1=src, r2=len - out: r0
 push r4,lr
 ldr  r4,=crc32_table
@@lop:                          ;\
 ldrb r3,[r1],1                 ;
 eor  r3,r3,r0                  ;
 and  r3,0ffh                   ; update crc
 ldr  r3,[r4,r3,lsl 2]          ;
 eor  r0,r3,r0,lsr 8            ;
 subs r2,1                      ;
 bne  @@lop                     ;/
 pop  r4,pc
;------------------
.endif ;with_soft_wep
;------------------
;:----------------- dswifi-src-0.3.17.tar\ END
;------------------
.pool
;.end
;------------------

        .endif ;with_nds_wifi


;XXX 2018
; - sgDhcpPkt_secs should be BIG-ENDIAN !?!!!
; - dhcp_tid is BIG-ENDIAN or LITTLE-ENDIAN ? don't matter, it should be "random" PER CLIENT (eg. change only on REBOOT, or set fixed to MAC addr LSB's or so)
; - fixed "LLC/SLIP header" typo (was meant to be "LLC/SNAP header")
; - dsi-wifi...


;spotted RSNIEs from beacons:
;  AP                   WPA             WPA2
;  o2acc                0048h           0048h   ;both WPA+WPA2! ;with AES, each
;  fritzbox.wep         0000h           0000h   ;none for WEP
;  fritzbox.wpa         0024h           0000h   ;only WPA       ;with TKIP
;  fritzbox.wpa2        0000h           0048h   ;only WPA2      ;with AES
;  o2wlan64.router.wpa2 0000h           0048h   ;only WPA2      ;with AES  (bssid: E8:37..02) ROUTER   (AES only)
;  o2wlan64.repeater    0000h           0064h   ;only WPA2      ;with TKIP (bssid: 0C:80..30) REPEATER (TKIP, and optional pairwise AES)
;  dlink.wep:128bit     0000h           0000h   ;none for WEP
;  dlink.wpa-psk:tkip   0024h           0000h   ;only WPA       ;with TKIP
;  dlink.wpa-psk:aes    0048h           0000h   ;only WPA       ;with AES
;  dlink.wpa2-personal  0000h           0048h   ;only WPA2      ;with AES
;  dlink.wpa+wpa2-pers  0024h           0064h   ;only WPA2      ;with GOOD-MIXED
;  dlink.802.1x:radius...
;  dlink.wpa:radius...
;  dlink.wpa2-enterprise:radius...


;;; Nintendo Wi-Fi USB Connector ?? maybe in unused-100h-byte-FLASH-slot?
;;; AOSS settings? and WPAx+AOSS?
